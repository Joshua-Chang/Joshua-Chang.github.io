<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Joshua-Chang.github.io</id>
    <title>Joshua-Chang`Blog</title>
    <updated>2021-08-05T07:54:24.279Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Joshua-Chang.github.io"/>
    <link rel="self" href="https://Joshua-Chang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Joshua-Chang.github.io/images/avatar.png</logo>
    <icon>https://Joshua-Chang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Joshua-Chang`Blog</rights>
    <entry>
        <title type="html"><![CDATA[getLocalVisibleRect可见区域的变化推演]]></title>
        <id>https://Joshua-Chang.github.io/post/getlocalvisiblerect-ke-jian-qu-yu-de-bian-hua-tui-yan/</id>
        <link href="https://Joshua-Chang.github.io/post/getlocalvisiblerect-ke-jian-qu-yu-de-bian-hua-tui-yan/">
        </link>
        <updated>2021-07-24T19:38:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官方文档">官方文档</h1>
<p>文档翻译：<em>如果该view的某些区域未被父view给clipped，then就通过r 根据全局(根)座标返回这些区域。</em></p>
<p><em>若通过r 根据当前座标返回的话，对其做偏移r.offset(-globalOffset.x, -globalOffset.y)</em></p>
<p><em>如果该view完全被父view给clip掉，或已经平移出去则返回false</em></p>
<p>由文档可知，<u>在View部分或完全显示时</u>：</p>
<p><code>getGlobalVisibleRect</code><strong>显示的区域</strong>以<strong>屏幕左上角</strong>为座标原点的Rect表示</p>
<p><code>getLocalVisibleRect</code><strong>显示的区域</strong>以<strong>自身左上角</strong>为座标原点的Rect表示</p>
<p><strong>屏幕左上角和view左上角存在偏移量</strong>。在view部分或完全显示的情况下，<code>getLocalVisibleRect</code>返回的<code>Rect</code>等于对<code>getGlobalVisibleRect</code>中返回的<code>Rect</code> 的<code>left、top、right、bottom</code>四项加取反的偏移量。</p>
<blockquote>
<p>屏幕左上角的座标为(0,0)，view自身左上角的在屏幕上的(500,800)位置时</p>
<p>globalOffset.x=500；globalOffset.y=500。</p>
<p>当<code>getGlobalVisibleRect</code>返回的<code>Rect</code>为(500,800,550,900)时</p>
<p>和<code>getLocalVisibleRect</code>返回的<code>Rect</code>是<code>Global</code> 的<code>left、right</code>-500<code>top、bottom</code>-800，(0,0,50,100)</p>
</blockquote>
<blockquote>
<p>两个方法同<code>getLocationInWindow/InSurface/OnScreen</code>（获得在目标容器中定位：int[]）一样。最好在	<code>view.getViewTreeObserver().addOnGlobalLayoutListener</code>  view摆放完成后使用。</p>
</blockquote>
<h1 id="应用">应用</h1>
<p>两个方法都有<code>boolean</code>返回值，用来判断view显示与否。</p>
<blockquote>
<p>两个方法对于被同一级view遮挡的view还是判断为显示的，同一级view盖在一起只算重复绘制。子view超出了父view的区域被父view给clipped裁切掉；或子view从父view中移动出去才判断为不显示。</p>
</blockquote>
<p>在实际开发中，不但会在view显示的情况下求其显示区域。还会在未显示的情况下获得其返回的Rect。如横向tab超出屏幕的部分的自动移动等情景。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/getLocalVisibleRect.png" alt="getLocalVisibleRect" loading="lazy"></figure>
<p>View在单横向或纵向划动的情况下，有<strong>完全不可见、部分或完全可见</strong>两种情况：</p>
<ul>
<li>
<p>二者在View<strong>还未显示</strong>或<strong>已经完全移出去</strong>，即<strong>完全不可见时</strong>：<code>getLocalVisibleRect</code>和<code>getGlobalVisibleRect</code>返回的<code>Rect</code>相同。</p>
<ul>
<li>
<p><code>left、top、right、bottom</code>其中随移动方向变化的两项，以<strong>屏幕左上角</strong>为座标原点而变化；</p>
</li>
<li>
<p>另外不变化的两项，以view<strong>自身左上角</strong>为座标原点相对值，并保持不变。</p>
<blockquote>
<p>如横向移动时，<code>left、right</code>的值参照左边原点而变化，<code>top、bottom</code>的值参照自身取0和height保持不变</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>二者在View<strong>部分或完全可见</strong>时返回的<code>Rect</code>是：</p>
<ul>
<li><code>getGlobalVisibleRect</code><strong>显示的区域</strong>以<strong>屏幕左上角</strong>为座标原点的Rect表示（别忘了Rect中不随view移动而变化的两项也要换成屏幕左上角的绝对座标）</li>
<li><code>getLocalVisibleRect</code><strong>显示的区域</strong>以<strong>自身左上角</strong>为座标原点的Rect表示</li>
</ul>
</li>
<li>
<p>当View在<strong>完全不显示</strong>与<strong>部分或完全显示</strong>之间变化时，如从座标正方向<strong>即将开始进入屏幕或即将完全移出屏幕</strong>时<code>getLocalVisibleRect</code>返回的<code>Rect</code>会有特别的变化。</p>
<ul>
<li>
<p>当View进入屏幕前：<code>getLocalVisibleRect</code>返回的<code>Rect</code>中随移动方向变化的两项，以<strong>屏幕左上角</strong>为座标原点而变化。在进入屏幕前达到极值<code>left=ScreenWidth</code>、<code>right=ScreenWidth+ViewWidth</code>(当从座标正方向纵向进入屏幕时为<code>top=ScreenHeight</code>、<code>bottom=ScreenHeight+ViewHeight</code>)</p>
</li>
<li>
<p>当View进入屏幕后：<code>getLocalVisibleRect</code>返回的<code>Rect</code>中随移动方向变化的两项，以<strong>自身左上角</strong>为座标原点而变化。在进入屏幕的一瞬间<code>left=0</code>、<code>right=0</code>(纵向情况<code>top=0</code>、<code>bottom=0</code>)</p>
<blockquote>
<p>view进入屏幕的一瞬间，返回的<code>Rect</code>中随方向变化的两项，发生巨大变化。<code>width</code>从<code>screenwidth</code>变为<code>0</code></p>
</blockquote>
</li>
<li>
<p>当View完全移出屏幕前：<code>getLocalVisibleRect</code>以<strong>自身左上角</strong>为座标原点，跟屏幕原点无关，所以自身的左上角已在屏幕之外也没有关系。此时的<code>Rect</code>中随移动方向变化的两项<code>left=viewwidth</code>、<code>right=viewwidth</code></p>
</li>
<li>
<p>当View完全移出屏幕后：<code>getLocalVisibleRect</code>返回的<code>Rect</code>中随移动方向变化的两项，以<strong>屏幕左上角</strong>为座标原点而变化。<code>left=-viewwidth</code>、<code>right=0</code></p>
<blockquote>
<p>view完全移出屏幕的一瞬间，返回的<code>Rect</code>中<code>left</code>从<code>viewwidth</code>变成<code>-viewwidth</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如当view横向从屏幕外进入屏幕，完全移出屏幕时<code>getLocalVisibleRect</code>返回的<code>Rect</code>的<code>left</code>的变化</p>
<table>
<thead>
<tr>
<th>在屏幕外很远处</th>
<th>进入屏幕前</th>
<th>进入屏幕后</th>
<th></th>
<th>完全移出前</th>
<th>完全移出后</th>
<th>继续移</th>
</tr>
</thead>
<tbody>
<tr>
<td>∞</td>
<td>screenWidth</td>
<td>0</td>
<td></td>
<td>width</td>
<td>-width</td>
<td>-∞</td>
</tr>
</tbody>
</table>
</blockquote>
<h1 id="总结">总结：</h1>
<p><code>View</code>完全不显示时，二者返回的<code>Rect</code>相同，其中随移动方向变化的两项，参照<strong>屏幕左上角</strong>而变化；不变的两项参照<strong>自身左上角</strong>保持不变。</p>
<p><code>View</code>部分或完全显示时，<code>getGlobalVisibleRect</code><strong>显示的区域</strong>以<strong>屏幕左上角</strong>为座标原点的Rect表示；<code>getLocalVisibleRect</code><strong>显示的区域</strong>以<strong>自身左上角</strong>为座标原点的Rect表示。二者可通过对返回的Rect做加上或减去<strong>屏幕左上角和view左上角之间的偏移量</strong>而互换。</p>
<p>当View在<strong>完全不显示</strong>与<strong>部分或完全显示</strong>之间变化时，<code>getLocalVisibleRect</code>返回的<code>Rect</code>	在屏幕左上角和平补左上角不同参照系中切换，会产生特殊的邻接值变化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节码操作]]></title>
        <id>https://Joshua-Chang.github.io/post/zi-jie-ma-cao-zuo/</id>
        <link href="https://Joshua-Chang.github.io/post/zi-jie-ma-cao-zuo/">
        </link>
        <updated>2021-07-07T17:09:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="字节码">字节码</h1>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/20190919203632299.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>.class文件内的操作指令（OpCode）被固定为一个字节，是由两个十六进制组即1字节组成的，所以叫字节码。</p>
<blockquote>
<p>1byte字节=8bit位=2十六进制</p>
</blockquote>
<p>通过javap反汇编器，以可读的方式查看java编译器生成的字节码。-c方法为主 -v详情</p>
<blockquote>
<p>把源码编译成机器识别的机器码的过程叫汇编。</p>
<p>把源码整个编译成可执行文件叫编译执行；源码逐行翻译执行叫解释执行。和汇编是不同的维度。</p>
<p>把java编译成字节码，（字节码可看特殊的给虚拟机用的机器码）</p>
</blockquote>
<p>java 字节码工具有：</p>
<p>ASMifier从<code>.class</code>文件生成asm java代码，再修改代码，生成新的<code>.class</code>文件。</p>
<p>openjdk 的<code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p>
<ul>
<li>
<p>JASM用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p>
<p>查看<code>java -jar asmtools.jar jdis Test.class</code></p>
<p>生成<code>java -jar asmtools.jar jasm Test.jasm</code></p>
</li>
<li>
<p>JCOD 整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p>
<p>查看<code>java -jar asmtools.jar jdec Test.class</code></p>
<p>生成<code>java -jar asmtools.jar jcoder Test.jasm</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/393097261d80d730f434561157e219c657820-20210708182124274.png" alt="图3 JVM规定的字节码结构" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/27b4609c522ee39916f14ee3f510af8a296734.png" alt="图13 反编译后的方法表" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/ac90457d635b90e2c08bf7659b0b7dfd50229.png" alt="图4 常量池的结构" style="zoom:200%;" /></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/0f795d2b2b28ce96b5963efb2e564e5a197874.png" alt="图10 字段表结构" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>魔数4字节。</p>
</li>
<li>
<p>版本号4字节。</p>
</li>
<li>
<p>常量池计数器2字节，就是常量个数。（-1排除下标0）</p>
<p>常量池数据区中存储两类常量字面量与符号引用：字面量为代码中声明为Final的常量值；符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。（各种都用cp_info结构表示：Tag标识类型+index+数据，javap对照查看）。</p>
</li>
<li>
<p>访问标识2字节，就是Public、Abstract、Final等修饰符，如ACC_PUBLIC | ACC_FINAL</p>
</li>
<li>
<p>当前类名，2字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p>
</li>
<li>
<p>父类名称，2字节，描述父类的全限定名，保存的也是常量池中的索引值。</p>
</li>
<li>
<p>接口信息，2字节，表示该类或父类实现的接口数量，紧接着的n个字节是所有接口名称的字符串常量的索引值。</p>
</li>
<li>
<p>字段表，类级别的变量以及实例变量。计数器2字节，数据区。（各种都用fields_info结构表示：访问标识+字段名(常量表索引)+字段描述符(如:I代表Int)</p>
</li>
<li>
<p><strong>方法表</strong>，计数器2字节。数据区：基本描述（名称、描述符、访问标识等）和Code区：</p>
</li>
</ol>
<p>具体的操作数栈指令</p>
<p>LocalVariableTable：**本地变量表，**包含This和方法参数和局部变量，（在实例方法内部可以调用This，是因为JVM将This作为每一个方法的第一个参数隐式进行传入。这是针对非Static方法而言。）</p>
<p>LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，debug用。</p>
<ol start="10">
<li>附加属性表，字节码的最后一部分，存放了在该文件中类或接口所定义属性的基本信息。</li>
</ol>
<h1 id="操作数栈及指令">操作数栈及指令</h1>
<p>每当为 Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/ac42012daa48396d66eda1e9adcdb8c5624301.gif" alt="图14 控制操作数栈示意图" loading="lazy"></figure>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/13/21/13720f6eb83d096ec600309648330821.png" alt="iadd" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/13/db/138c20e60c081c8698770ff8d5d93fdb.png" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>以加法指令 iadd 为例。假设在执行该指令前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值 3 压入栈中。</p>
</blockquote>
<ol>
<li>
<p>Java 字节码中直接作用在操作数栈上的指令有</p>
<p>dup： 复制栈顶元素，以及 pop：舍弃栈顶元素(处理long、double时要用dup2/pop2)。dup 指令常用于复制 new 指令所生成的未经初始化的引用，然后用invokespecial 指令来调用构造器。pop 指令则常用于舍弃调用指令的返回结果，如调用方法却不用其返回值。</p>
<p>还有 swap 指令，它将交换栈顶两个元素的值。</p>
</li>
<li>
<p>直接将常量加载到操作数栈上的指令</p>
<p>如iconst 指令加载 -1 至 5 之间的 int 值。( bipush、sipush 加载一个字节、两个字节所能代表的 int 值。 )</p>
<p>ldc 指令加载常量池中的常量值，例如 ldc #18 将加载常量池中的第 18 项。其他类型如下</p>
<blockquote>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/0dfbecf954660bcdc76eac65beac1e8f.jpg" alt="c" style="zoom:50%;" />
</blockquote>
</li>
<li>
<p>操作本地变量表的指令。存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算，得到计算结果后再存储至局部变量数组中。这些加载、存储指令是区分类型的。</p>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/83/f9/83ece83ecd260c2eda282747467e49f9.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/c5/32/c57cb9c2222f0f79459bf4c58e1a4c32.png"  style="zoom:30%;" ></th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-java">public static int bar(int i) {
  return ((i + 1) - 2) * 3 / 4;
}
Code:
  stack=2, locals=1, args_size=1//操作数栈空间为 2 局部变量数组空间为 1, 调用bar(5)如图
     0: iload_0
     1: iconst_1
     2: iadd
     3: iconst_2
     4: isub
     5: iconst_3
     6: imul
     7: iconst_4
     8: idiv
     9: ireturn
</code></pre>
</blockquote>
</li>
<li>
<p>其他高层语义的字节码指令：</p>
<blockquote>
<ul>
<li>new（后跟目标类，生成该类的未初始化的对象）</li>
<li>instanceof（后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0）</li>
<li>checkcast（后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常）athrow（将栈顶异常抛出）</li>
<li>锁指令：monitorenter（为栈顶对象加锁）和 monitorexit（为栈顶对象解锁）。</li>
<li>字段访问指令：getstatic、putstatic（静态字段访问指令），getfield、putfield（实例字段访问指令 ）。这四条指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。</li>
<li>方法调用指令：invokestatic，invokespecial，invokevirtual，invokeinterface 以及 invokedynamic。（方法调用指令）在进行方法调用之前，程序需要依次压入调用者（invokestatic 不需要），以及各个参数。消耗的操作数栈元素以情况而定。</li>
<li>数组相关指令：newarray/ anewarray（新建基本类型/引用数据类型数组），生成多维数组（multianewarray），arraylength（求数组长度），iaload/iastore（int数组加载/存储指令）</li>
<li>控制流指令：goto（无条件跳转），tableswitch 和 lookupswtich（条件跳转指令：前者针对密集的 cases，后者针对稀疏的 cases），ireturn（返回 int 值的指令）。除返回指令外的控制流指令，均附带一个或者多个字节码偏移量，代表需要跳转到的位置。</li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/5d/1f/5d935dcdd55e9f8461a6e5b0ac22001f.jpg" style="zoom:80%;" /></th>
<th><img src="https://static001.geekbang.org/resource/image/f5/f0/f5195b5425a9547af9ce8371aef5c4f0.jpg" alt="1" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
</blockquote>
</li>
</ol>
<h1 id="jvmti后门-javaagent-instrumentation">JVMTI后门、javaagent、Instrumentation</h1>
<p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。JVMTI可以用来开发并监控虚拟机，可以查看JVM内部的状态，并控制JVM应用程序的执行。可实现的功能包括但不限于：调试、监控、线程分析、覆盖率分析工具等。从Android9.0开始，Android ART已经加入了JVMTI的相关功能了。</p>
<p>JVMTI只是一套接口，<strong>我们要开发JVM工具就需要写一个Agent程序来使用这些接口</strong>。Agent程序其实就是一个C/C++语言编写的动态链接库。可以在jvm启动时指定加载运行该agent，JVM启动后该agent程序就会开始工作。开发者可以构建一个基于Java编写的Agent来监控或者操作JVM了，比如替换或者修改某些类的定义等。</p>
<p>虽然java提供了JVMTI，但是对应的agent需要用C/C++开发，直到Java SE 5的新特性中加入了<strong>Instrumentation机制</strong>。</p>
<blockquote>
<ol>
<li>
<p>JDK 1.5中提供的，开发者只能在main加载之前添加premain</p>
</li>
<li>
<p>Java SE 6 的 Instrumentation 当中，提供了一个新的代理操作方法：agentmain，可以在 main 函数开始运行之后再运行。</p>
<p>同样，agentmain 方法中带Instrumentation参数的方法也比不带优先级更高。开发者必须在 manifest 文件里面设置“Agent-Class”来指定包含 agentmain 函数的类。在Java6 以后实现启动后加载的新实现是Attach api。</p>
</li>
</ol>
</blockquote>
<p>Instrumention支持的功能都在<code>java.lang.instrument.Instrumentation</code>接口中体现，常用方法有:</p>
<ol>
<li>
<p>addTransformer方法注册一个ClassFileTransformer，后面类加载的时候都会经过这个ClassFileTransformer处理。这是使用字节码编译工具（如javassist、ASM）即可对某些类对象进行改写。</p>
<p>Transformer里的transform方法以被加载字节码byte数组为参数，可对此修改。</p>
</li>
<li>
<p><strong>retransformClasses对于已加载过的类，重新触发这个Transformer的转换</strong>。即修改transfrom方法</p>
</li>
<li>
<p>redefineClasses<strong>它需要直接给出新的类byte流，然后替换旧的</strong>。</p>
<p>ClassFileTransformer可以判断是否需要修改类定义并根据自己的代码规则修改类定义然后返回给JVM。利用这个Transformer类，我们可以很好的实现虚拟机层面的AOP。</p>
</li>
</ol>
<p>Attach API 主要的类是 <code>com.sun.tools.attach</code> 包里面的</p>
<ol>
<li>
<p><code>VirtualMachine</code> 程序需要监控的目标虚拟机，提供了获取系统信息(比如获取内存dump、线程dump，类信息统计(比如已加载的类以及实例个数等)， 有loadAgent，Attach 和 Detach 等处理agent代理的方法。</p>
<p><code>attach(pid)</code>远程连接到该pid的java进程上，即jvm上。</p>
<p><code>loadAgent</code>方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。</p>
</li>
<li>
<p><code>VirtualMachineDescriptor</code> 则是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。</p>
</li>
</ol>
<p>通过VirtualMachine类的<code>attach(pid)</code>方法，便可以attach到一个运行中的java进程上，之后便可以通过<code>loadAgent(agentJarPath)</code>来将agent的jar包注入(启动了一个socket进程去传输agent.jar)到对应的进程，然后对应的进程会调用agentmain方法。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/1607781-20190817155003876-767522290.png" alt="img" loading="lazy"></figure>
<blockquote>
<p>在mac上安装了的jdk是能直接找到 VirtualMachine 类的，但是在windows中安装的jdk无法找到，如果你遇到这种情况，请手动将你jdk安装目录下：lib目录中的tools.jar添加进当前工程的Libraries中。</p>
<p>tools包找不到，在idea可先javac编译后执行</p>
</blockquote>
<p><strong>premain与agentmain的区别</strong>：</p>
<p>premain对应的就是VM启动时的Instrument Agent加载，即<code>agent on load</code></p>
<p>agentmain对应的是VM运行时的Instrument Agent加载，即<code>agent on attach</code></p>
<p>两种加载形式所加载的<code>Instrument Agent</code>都关注同一个<code>JVMTI</code>事件 – <code>ClassFileLoadHook</code>事件，这个事件是在读取字节码文件之后回调时用，也就是说**premain和agentmain方式的回调时机都是类文件字节码读取之后（或者说是类加载之后），之后对字节码进行重定义或重转换。</p>
<p><code>premain</code>和<code>agentmain</code>两种方式最终的目的都是为了回调<code>Instrumentation</code>实例并激活<code>sun.instrument.InstrumentationImpl#transform()</code>（InstrumentationImpl是Instrumentation的实现类）从而回调注册到<code>Instrumentation</code>中的<code>ClassFileTransformer</code>实现字节码修改，本质功能上没有很大区别。两者的非本质功能的区别如下：</p>
<ul>
<li>premain方式是JDK1.5引入的，agentmain方式是JDK1.6引入的，JDK1.6之后可以自行选择使用<code>premain</code>或者<code>agentmain</code>。</li>
<li><code>premain</code>需要通过命令行使用外部代理jar包，即<code>-javaagent:代理jar包路径</code>；<code>agentmain</code>则可以通过<code>attach</code>机制直接附着到目标VM中加载代理，也就是使用<code>agentmain</code>方式下，操作<code>attach</code>的程序和被代理的程序可以是完全不同的两个程序。</li>
<li><code>premain</code>方式回调到<code>ClassFileTransformer</code>中的类是虚拟机加载的所有类，这个是由于代理加载的顺序比较靠前决定的，在开发者逻辑看来就是：所有类首次加载并且进入程序<code>main()</code>方法之前，<code>premain</code>方法会被激活，然后所有被加载的类都会执行<code>ClassFileTransformer</code>列表中的回调。</li>
<li><code>agentmain</code>方式由于是采用<code>attach</code>机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助<code>Instrumentation#retransformClasses(Class&lt;?&gt;... classes)</code>让对应的类可以重新转换，从而激活重新转换的类执行<code>ClassFileTransformer</code>列表中的回调。</li>
<li>通过premain方式的代理Jar包进行了更新的话，需要重启服务器，而agentmain方式的Jar包如果进行了更新的话，需要重新attach，但是agentmain重新attach还会导致重复的字节码插入问题，不过也有<code>Hotswap</code>和<code>DCE VM</code>方式来避免。</li>
</ul>
<p>使用 javaagent 的premain例子：</p>
<ol>
<li>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</li>
<li>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</li>
<li>将 premain 的类class和 MANIFEST.MF 文件打成 jar 包。（要在被打包的类的包名之上的目录运行jar命令）</li>
<li>使用参数 -javaagent: jar包路径 启动要代理的方法。</li>
</ol>
<blockquote>
<p>在执行以上步骤后，JVM 会先执行 premain 方法，在 main 方法启动前拦截大部分类的加载活动(遗漏的主要是系统类)，既然可以拦截类的加载，那么就可以去做重写类这样的操作，结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p>
<p>可以附上多个<code>-javaagent</code>参数添加多个代理。</p>
</blockquote>
<p>使用agentmain前三步同上,MANIFEST.MF 文件里是Agent-Class选项。然后先 attach 到已经运行的VM上，再loadAgent加载有agentmain的jar包。</p>
<p>Java agent 的这些功能都是通过 JVMTI agent，也就是 C agent 来实现的。JVMTI 是一个事件驱动的工具实现接口，通常，我们会在 C agent 加载后的入口方法<code>Agent_OnLoad</code>处注册各个事件的钩子（hook）方法。当 Java 虚拟机触发了这些事件时，便会调用对应的钩子方法。</p>
<pre><code class="language-c">JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved);
</code></pre>
<p>如为 JVMTI 中的<code>ClassFileLoadHook</code>事件设置钩子，从而在 C 层面拦截所有的类加载事件。</p>
<p>JDK 本身也使用了 ASM 库，如用来生成 Lambda 表达式的适配器类。</p>
<h1 id="字节码增强">字节码增强</h1>
<p><strong>字节码增强技术就是对现有字节码进行修改或者动态生成全新字节码文件的技术。</strong> asm/Javassist可以直接生产 .class字节码文件，也可以在<strong>类被加载入JVM之前</strong>动态修改类行为。应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。可以配合JVMTI的<em>Instrumentation机制</em> 添加agent对premain/agentmain的ClassFileTransformer.transform方法中的class二进制数组，使用asm/Javassist修改class二进制数据，在运行前/运行时替换字节码。</p>
<blockquote>
<p>通过JVMTI，可以实现对JVM的多种操作，它通过接口注册各种事件勾子，在JVM事件触发时，同时触发预定义的勾子，以实现对各个JVM事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC开始和结束、方法调用进入和退出、临界区竞争与等待、VM启动与退出等等。</p>
<p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，Agent程序其实就是一个C/C++语言编写的动态链接库，后来出现了java agent可以用java写agent程序。</p>
<p>JVMTI的<em>Instrumentation机制</em>可以把agent attench到运行中的jvm上。</p>
</blockquote>
<h2 id="asm">ASM</h2>
<img src="https://img-blog.csdnimg.cn/20191106150639622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvc2Fvcw==,size_16,color_FFFFFF,t_70" alt="sam" style="zoom:50%;" />
<p>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。</p>
<p>然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</p>
<ul>
<li>ClassReader：用于读取已经编译好的.class文件。</li>
<li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li>
<li>各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li>
</ul>
<p>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</p>
<ol>
<li>
<p>先通过ClassReader读取编译好的.class文件</p>
</li>
<li>
<p>再通过访问者模式（Visitor）对字节码进行修改，常见的Visitor类有：对方法进行修改的MethodVisitor，或者对变量进行修改的FieldVisitor等，MethodVisitor中的方法有</p>
<p>visitCode会在某个方法被访问时调用，故前置增强逻辑在此编写，<br>
visitInsn会在无参数的指令的执行时调用，退出语句return被调用时就会调用visitInsn方法，因此，后置增强逻辑可以写在这里</p>
<p>重写上述方法，手动写入或者修改字节码。通过调用methodVisitor的visitXXXXInsn()方法就可以实现字节码的插入，XXXX对应相应的操作码助记符类型，比如mv.visitLdcInsn(“end”)对应的操作码就是ldc “end”，即将字符串“end”压入栈。使用idea插件ASM ByteCode Outline 查看ASMified并和原来的原文件生成的asm比较。</p>
</li>
<li>
<p>通过ClassWriter重新构建编译修改后的字节码文件、或者将修改后的字节码文件输出到文件中</p>
</li>
</ol>
<h3 id="cglib">Cglib</h3>
<p>CGLIB创建一个继承实现类的子类，用Asm库动态修改子类的代码来实现AOP效果</p>
<p>调用<code>Enhancer</code>来动态生成子类，设置其父类和并在<code>MethodInterceptor</code>方法拦截器中对方法修改。</p>
<h2 id="javassist">Javassist</h2>
<p>ASM是在指令层次上操作字节码的，在指令层次上操作字节码的框架实现起来比较晦涩。利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：</p>
<ul>
<li>CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。</li>
<li>ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。</li>
<li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li>
</ul>
<p>从pool中获取到相应的CtClass对象和其中的方法，然后执行method.insertBefore和insertAfter方法，参数为要插入的Java代码，再以字符串的形式传入即可，实现起来极为简单。</p>
<h2 id="运行时注入">运行时注入</h2>
<p>果只能在类加载前对类中字节码进行修改，那将失去其存在意义，毕竟大部分运行的Java系统，都是在运行状态的线上系统。结合之前的JVMTI 的Instrumentation机制，定义一个agentmain attach到运行的jvm进程上。</p>
<blockquote>
<p>Agent是JVMTI的一种实现，Agent有两种启动方式</p>
<ol>
<li>一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；</li>
<li>二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvc2Fvcw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>通过Attach API的loadAgent()方法，将打包好的Agent jar包动态Attach到目标JVM上</p>
</blockquote>
<ol>
<li>
<p>定义agent：在agentmain中addTransformer添加ClassFileTransformer后，在ClassFileTransformer.transform内使用javassist或asm完成字节码的修改。然后retransformClasses把修改的类从新载入。ctClass要引入classpath和解冻</p>
<pre><code class="language-java">//CtClass ctClass = classPool.get(&quot;com.aop.inst.RuntimeInstr&quot;);
//若NotFoundException可能是不同classloader造成的。用如下方法先加cp
classPool.insertClassPath(new ClassClassPath(RuntimeInstr.class));
ctClass= classPool.get(RuntimeInstr.class.getName());
</code></pre>
<p>CtClass有如下操作时writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass会被冻结，操作完成后要解冻ctClass.defrost()</p>
</li>
<li>
<p>打包agent为jar，javac -cp 引入所依赖的包并编译成class，依赖其他类时也可以将其打成jar再依赖。:分割(win是/)；-cp即classpath即查找class的路径。<br>
把编译成的class打包成jar，必须在manifest.mf中定义Agent-Class:代理类和Class-Path:。manifest.mf要在末尾空一行。manifest.mf的键值对(key： value)值前空格。要添加多个cp时要换行，换行时在行尾要空格，在新行的行首也要空格。</p>
<pre><code class="language-bash">javac -cp /Users/joshuachang/.m2/repository/org/javassist/javassist/3.28.0-GA/javassist-3.28.0-GA.jar:runtime.jar com/aop/inst/RuntimeAgent.java 

jar cvfm inst.jar com/aop/inst/MANIFEST.MF com/aop/inst/RuntimeAgent.class com/aop/inst/RuntimeAgent\$1.class com/aop/inst/RuntimeAgent\$1\$1.class com/aop/inst/RuntimeAgent\$1\$1\$1.class com/aop/inst/RuntimeInstr.class 
</code></pre>
</li>
<li>
<p>先运行jvm(agent所代理的类)并得到pid。再运行VirtualMachine.attach(pid)把agent连上jvm，再loadAgent把agent所在的jar包加载。</p>
</li>
</ol>
<p>面向切面编程（Aspect-Oriented Programming，AOP）。面向方面编程的核心理念是定义切入点（pointcut）以及通知（advice）。程序控制流中所有匹配该切入点的连接点（joinpoint）都将执行这段通知代码。面向切面的一种实现方式就是字节码注入，比如AspectJ、DiSL(它支持用注解来定义切入点，用普通 Java 方法来定义通知)</p>
<p>1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<blockquote>
<p>无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，浅拷贝和深拷贝只是相对的，如果一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。</p>
<p>深拷贝比较常用的方案有两种：</p>
<ol>
<li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li>
<li>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。</li>
</ol>
</blockquote>
<h1 id="unsafe">UnSafe</h1>
<p>Unsafe 是 java 留给开发者的后门，用于直接操作系统内存且不受 jvm 管辖。在java 的并发包和众多偏向底层的框架中都有大量应用。该类的大部分方法均为 native方法，供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/1607781-20190811141555811-1035387188.png" alt="unsafe" loading="lazy"></figure>
<p>Unsafe类为一单例实现。使用方式</p>
<ol>
<li>受限制的getUnsafe() ，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法。把调用unSafe方法的类打成的jar包路径追加到bootstrap中<code>-Xbootclasspath/a</code></li>
<li>反射获取单例对象theUnsafe</li>
</ol>
<h3 id="内存操作">内存操作</h3>
<p>我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p>
<p>unsafe提供内存的分配、拷贝、释放、给定地址值操作等方法。</p>
<h4 id="典型应用directbytebuffer">典型应用DirectByteBuffer。</h4>
<p>其构造函数中创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。</p>
<blockquote>
<p>如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？</p>
<p>Cleaner继承自虚引用PhantomReference，通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。</p>
</blockquote>
<h3 id="cas相关">CAS相关</h3>
<p>当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。<strong>CAS有三个操作数：内存值V、旧的预期值E、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false</strong>。</p>
<p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p>
<blockquote>
<p>执行函数：CAS(V,E,N)</p>
</blockquote>
<p>包含3个参数</p>
<ol>
<li>V表示要更新的变量</li>
<li>E表示预期值</li>
<li>N表示新值</li>
</ol>
<p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。</p>
<p>CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包。CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p>
<h4 id="典型应用atomicinteger">典型应用AtomicInteger</h4>
<p>CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。</p>
<p>在AtomicInteger的实现中，静态字段valueOffset即为字段value的<strong>内存偏移地址</strong>。在AtomicInteger初始化时的静态代码块中通过Unsafe的objectFieldOffset方法获取valueOffset的值。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。</p>
<h3 id="线程调度">线程调度</h3>
<p>park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。</p>
<h4 id="典型应用">典型应用</h4>
<p>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p>
<h3 id="class相关">Class相关</h3>
<p>主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。</p>
<h4 id="典型应用-2">典型应用</h4>
<p>从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。</p>
<p>通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用<strong>Unsafe的defineAnonymousClass</strong>方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。</p>
<blockquote>
<ul>
<li><strong>invokedynamic</strong>： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。</li>
<li><strong>VM Anonymous Class</strong>：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。</li>
</ul>
</blockquote>
<h3 id="对象操作">对象操作</h3>
<p>主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。</p>
<h4 id="典型应用-3">典型应用</h4>
<ul>
<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li><strong>非常规的实例化方式</strong>：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>
</ul>
<p>在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。</p>
<h3 id="数组相关">数组相关</h3>
<p>数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。</p>
<pre><code class="language-java">//返回数组中第一个元素的偏移地址
public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);
//返回数组中一个元素占用的大小
public native int arrayIndexScale(Class&lt;?&gt; arrayClass);
</code></pre>
<h4 id="典型应用-4">典型应用</h4>
<p>这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用。AtomicIntegerArray源码中，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。</p>
<h2 id="内部类">内部类</h2>
<p>javap查看其字节码和源码不同。</p>
<ol>
<li>
<p>编译器给内部类和外部类的每个私有属性，都生成了相应的<code>access$0 access$1..access$5</code> 等静态方法，以供对方<strong>访问</strong>。</p>
</li>
<li>
<p>内部类构造的时候，会将外部类的引用<code>this$0</code>传递进来，并且作为内部类的一个属性。<strong>内部类会持有一个其外部类的引用</strong>，因此内部类不必通过实例外部类，就可以直接访问外部类的属性。但访问其私有属性是因为编译生成的<code>access</code>方法。</p>
<p>外部类可以通过实例化内部类，来访问其内部属性。可以访问内部类的私有属性，同样是编译时对方暴露了访问方法<code>access</code>。<strong>匿名内部类的私有成员就不可被外部类访问</strong>。</p>
</li>
</ol>
<pre><code class="language-java">public class Outer {
    private char outChar;
    public void fun1(){
        Inner inner = new Inner();
        inner.inChar='1';//通过实例方法内部类私有变量
    }
    public class Inner {
        private char inChar;
        public void fun2(){
            outChar='2';//直接访问外部类私有变量
        }
    }
}
</code></pre>
<pre><code class="language-java">//javap
public class com.data.linkedlist.Outer {
    static char access$102(com.data.linkedlist.Outer, char);//供内部类访问的方法
    Code:
       0: aload_0
       1: iload_1
       2: dup_x1
       3: putfield      #1                  // Field outChar:C
       6: ireturn
}
public class com.data.linkedlist.Outer$Inner {
  final com.data.linkedlist.Outer this$0;//内部类持有外部引用
  static char access$002(com.data.linkedlist.Outer$Inner, char);//供外部类访问的方法
	Code：
    //.....
  	3: putfield      #1                  // Field inChar:C
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM]]></title>
        <id>https://Joshua-Chang.github.io/post/jvm/</id>
        <link href="https://Joshua-Chang.github.io/post/jvm/">
        </link>
        <updated>2021-07-03T04:54:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jvm基本原理">JVM基本原理</h1>
<table>
<thead>
<tr>
<th><img src="https://i.imgur.com/FlYWN1d.png" alt="image-20210703132213706" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703131238763.png" alt="123" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png" style="zoom:70%;" /></th>
<th><img src="https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png" style="zoom:70%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。<br>
为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。它会解释执行 Java 字节码，然后会将其中反复执行的热点代码（一个方法内的代码)，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。<br>
HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/77dfb788a8ad5877e77fc28ed2d51745.png" alt="1" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/2019-01-24-01.png" style="zoom:100%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。</p>
<p>Java 基本类型有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。</p>
<p>在局部变量中除 long 和 double 外，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的在 32/64位的 HotSpot 中，这些类型在栈上将占用 4 /8个字节。</p>
<p>但在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，跟这些类型的值域相吻合。</p>
<p>在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作(一串二进制数字，通过与目标数字的<a href="https://segmentfault.com/a/1190000039239875">按位操作</a>，达到屏蔽指定位而实现需求)。在读取时，Java 虚拟机则会将其扩展为 int 类型。在算数运算时几乎全部依赖于操作数栈，即将堆中的 boolean、byte、char 以及 short <strong>加载到操作数栈上，而后将栈上的值当成 int 类型来运算</strong>。</p>
<blockquote>
<p>对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。</p>
<p>对于 byte、short 这两个类型来说，加载伴随着符号扩展。short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，则该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。</p>
</blockquote>
<p>基本类型（primitive types）8大，和引用类型（reference types）：类、接口、数组类和泛型参数。</p>
<blockquote>
<p>由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。字节流最常见的形式要属由 Java 编译器生成的 class 文件，不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。</p>
</blockquote>
<h2 id="分层编译模式">分层编译模式</h2>
<blockquote>
<p>class是.java编译成的二进制流文件，又叫字节码。</p>
<p>像C、C++ 是编译型的语言。传统的Java执行如下</p>
<ol>
<li>.class由编译器编译成.class字节码。</li>
<li>JVM解释器再把class字节码解释成机器码。</li>
<li>机器码在本地操作系统上执行。</li>
</ol>
<p>java代码相对于虚拟机是编译执行的，即：把.java编译成.class就可以在虚拟机上执行。</p>
<p>虚拟机上的class字节码相对于本地操作系统是解释执行的，即：把class解释翻译成操作系统的机器码</p>
</blockquote>
<p>现代的Java的执行过程整体可以分为两个部分：</p>
<p>第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。</p>
<p>第二步逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对运行信息进行收集，编译器会逐渐进行后端编译：把被JVM认定为的热点代码的字节码编译成机器码。</p>
<p>JVM中会设置一个阈值，当方法的调用次数和循环回边的执行次数超过这个阈值时就会被编译，存入codeCache中。当下次执行这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/ba83857ecf9f344e4972fd551c4973d653952.png@648w_454h_80q" alt="img" loading="lazy"></figure>
<p><strong>profile轮廓、profiling性能分析(profile+trace)、profiler性能分析工具</strong></p>
<blockquote>
<p>例如 JDK 附带的 hprof。这些 profiler 大多通过注入（instrumentation）或者 JVMTI 事件来实现的。</p>
</blockquote>
<p>profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile。</p>
<p>HotSpot 虚拟机包含多个即时编译器 C1、C2 和 Graal（实验性替代C2）。</p>
<p>C1编译效率较快：编译对于执行时间较短的，或者对启动性能有要求的程序，对应参数 -client。</p>
<p>C2生成代码执行效率较快 ：编译对于执行时间较长的，或者对峰值性能有要求的程序，对应参数 -server。</p>
<p>通常代码会先被 Java 虚拟机解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上。综合了 C1 的启动性能优势和 C2 的峰值性能优势，Java 7 引入了分层编译（对应参数 -XX:+TieredCompilation）：</p>
<ol>
<li>解释执行；</li>
<li>执行不带 profiling 的 C1 生成的机器码；</li>
<li>执行仅带方法调用次数以及循环回边执行次数 profiling 的 C1  生成的机器码；</li>
<li>执行带所有 profiling 的 C1  生成的机器码；</li>
<li>执行 C2  生成的机器码。</li>
</ol>
<p>profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile。</p>
<blockquote>
<p>profiling 越多，其额外的性能开销越大，因此2，3，4的C1执行效率逐渐降低，但C2执行效率比C1高。</p>
<p>循环回边是一个控制流图中的概念。在字节码中，我们可以简单理解为往回跳转的指令。如for、方法递归编译后的标签回跳</p>
</blockquote>
<p>方法的调用次数和循环回边的执行次数，决定一个方法是否为热点代码，并触发以方法为单位的即时编译JIT。</p>
<p>Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译，也由循环回边计数器。</p>
<blockquote>
<p>OSR 指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行，以及和编译后的代码之间的切换。</p>
</blockquote>
<p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p>
<p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，其中静态单赋值（Static Single Assignment，SSA）IR比较常用。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。借助了SSA IR，编译器进行识别冗余赋值及死代码删除等优化（Dead Code Elimination删除不会走的else）</p>
<p>C1编译器优化大部分都是在高级中间表达形式HIR上完成的，当优化完成之后将HIR转为低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</p>
<p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它去除了变量的概念，直接采用值来进行运算。（可以利用IR可视化工具Ideal Graph Visualizer（IGV）查看）</p>
<h1 id="类的加载">类的加载</h1>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703193948926.png" alt="image-20210703193948926" style="zoom:120%;" /></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703194854583.png" alt="83" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703195002837.png" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th>jdk9模块化</th>
<th>Jdk8没模块化</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703215452248.png" alt="image-20210703215452248" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703215551942.png" alt="image-20210703215551942" loading="lazy"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703222834382.png" alt="image-20210703222834382" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703224610137.png" alt="image-20210703224610137" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Java 虚拟机将字节流转化为 Java 类的过程分为加载、链接(验证、准备和解析)以及初始化三大步骤。然后才能使用，用完既可卸载。</p>
<p>加载是指查找字节流class，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。</p>
<blockquote>
<p>自定义的类加载器来实现特殊的加载方式。比如我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。<br>
除了加载功能之外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流class，经由不同的类加载器加载，也会得到两个不同的类。</p>
</blockquote>
<p>链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。</p>
<ol>
<li>验证：保被加载类能够满足 Java 虚拟机的约束条件</li>
<li>准备：为被加载类的静态字段分配内存(具体初始化在初始化阶段)。（分配内存后有缺省值如0）还会构造与该类相关联的方法表。</li>
<li>解析：将符号引用解析成为实际引用</li>
</ol>
<blockquote>
<p>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个<strong>符号引用</strong>。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。</p>
<p>举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。</p>
<p>Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p>
</blockquote>
<p>初始化时，为标记为常量值的字段赋值。并执行&lt; clinit &gt;方法的过程。</p>
<blockquote>
<p>常量值：初始化时基本类型或字符串类型的静态字段被 final 所修饰时，会被 Java 编译器标记成常量值（ConstantValue）由 Java 虚拟机常量池直接初始化。</p>
<p>&lt; clinit &gt;方法：初始化语句(除常量之外静态字段/方法/代码块)被 Java 编译器置于&lt; clinit &gt;方法中依次执行。</p>
<p>Java 虚拟机会通过加锁(初始化锁)来确保类的 &lt; clinit &gt; 方法仅被执行一次，这个特性被用来实现<strong>单例的延迟初始化</strong>。</p>
</blockquote>
<pre><code class="language-java">//单例延迟初始化
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
</code></pre>
<blockquote>
<p>只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（访问类的静态变量时触发类的初始化），继而新建一个 Singleton 的实例。</p>
<p>由于类初始化时有初始化锁是线程安全的，且(&lt; clinit&gt;)仅被执行一次，因此可以确保多线程环境下有且仅有一个 Singleton 实例。</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703235422140.png" alt="image-20210703235422140" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703235546550.png" alt="image-20210703235546550" loading="lazy"></th>
<th>类连结中的准备：为类的静态变量分配内存并赋缺省值如0，赋真正的初始值（=?）实在初始化阶段<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703235014519.png" alt="image-20210703235014519" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210703235942762.png" alt="image-20210703235942762" loading="lazy"><br/>初始化语句=静态属性/方法/代码块<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704000507286.png" alt="image-20210704000507286" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704000811687.png" alt="image-20210704000811687" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704101912989.png" alt="image-20210704101912989" loading="lazy"><br />8）初次调用 MethodHandle 时</td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704102210346.png" alt="image-20210704102210346" loading="lazy"><br />主类=main方法类</td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704115557956.png" alt="image-20210704115557956" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>不会触发类的初始化的特殊情况即<strong>被动引用</strong>：</p>
<ol>
<li>通过子类去引用父类的静态字段时，不会导致子类的初始化。<code>System.out.println(ChildClazz.parentStr);</code></li>
<li>数组引用类时，不会触发类的初始化 <code>MyClazz clz=new MyClazz[2]</code></li>
<li>引用类的常量(static final)不会导致类的初始化。</li>
</ol>
<pre><code class="language-java">public class MyClassIS {
    private static MyClassIS myClassIS = new MyClassIS();
    private static int a = 0;
    private static int b;//b=0时结果b也为0
//  private static MyClassIS myClassIS = new MyClassIS();顺序调换时，都为1
    private MyClassIS(){
        a++;
        b++;
    }
    public static MyClassIS getInstance() {
        return myClassIS;
    }
    public int getA() {
        return a;
    }
    public int getB() {
        return b;
    }
}
-------------------类的静态变量 初始化顺序问题--------------------
public class App {
    public static void main(String[] args) throws Exception {
        MyClassIS myClassIS=MyClassIS.getInstance();
        System.out.println(myClassIS.getA()+&quot; : &quot;+myClassIS.getB());
    }
}
</code></pre>
<ol>
<li>连结-准备阶段：对静态变量ab赋缺省值0</li>
<li>初始化阶段：初始化(静态)语句依次执行，第一行，构造方法时0++ ab=1</li>
<li>初始化阶段：初始化(静态)语句依次执行，二三行，a=0 b=1。即对静态变量赋初始值a=0，b没初始值还=1</li>
</ol>
<h1 id="堆内存">堆内存</h1>
<blockquote>
<p>栈内存线程私有，堆内存线程共享。但堆内存的分配是通常被很少讨论，但实际却很复杂的。</p>
<p>堆内存的分配通常用指针碰撞法、空闲列表法。但是堆是全局共享的，在同一时间可能会有多个线程并发地在堆上分配空间。解决并发问题用CAS、TLAB(hotspot用：给每个线程在堆里预分配一块区域，分配完成后便不再线程独享。因此hotspot中的TLAB可以在堆里”线程私有“)</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704141903971.png" alt="image-20210704141903971" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704141934898.png" alt="image-20210704141934898" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142122235.png" alt="image-20210704142122235" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142206299.png" alt="image-20210704142206299" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142318308.png" alt="image-20210704142318308" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/2c/e5/2cc29b8de676d3747416416a3523e4e5.png" alt="内存" loading="lazy"></figure>
<blockquote>
<p>堆内存分布如图：</p>
<p>Eden 区的空间耗尽则Minor GC，Eden 区和 from  区中的存活对象会被复制到 to， 然后交换 from 和 to 指针。保证to区永远是空的。</p>
<p>对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold）则晋升至老年代。</p>
<p>单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p>
</blockquote>
<p>当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此划分空间时有同步问题。</p>
<p>TLAB（Thread Local Allocation Buffer)技术：每个线程可以向 Java 虚拟机申请一段连续的线程私有内存，次操作需要加锁。线程需要维护两个指针，一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。</p>
<ol>
<li>new 指令时，直接通过指针加法（bump the pointer）(误译为指针碰撞，bump为提高)，即把指向空余内存位置的指针加上所请求的字节数。</li>
<li>加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。</li>
<li>否则TLAB空间不足，当前线程重新申请新的TLAB</li>
</ol>
<p>因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。</p>
<p>卡表（Card Table）技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。需要在编译器生成的机器码中，插入额外的逻辑，即写屏障（write barrier）。</p>
<p>引用类型(reference)访问对象实例的方式：</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142407666.png" alt="image-20210704142407666" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142429226.png" alt="image-20210704142429226" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142515397.png" alt="image-20210704142515397" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704142627592.png" alt="image-20210704142627592" loading="lazy"></td>
</tr>
<tr>
<td>对象实例发生变化只影响句柄指向不影响reference</td>
<td></td>
</tr>
<tr>
<td>间接引用，两次指针定位速度慢</td>
<td>速度快</td>
</tr>
</tbody>
</table>
<h2 id="对象的内存布局">对象的内存布局</h2>
<p>Java 新建对象的方式：</p>
<ol>
<li>new 语句和反射机制，则是通过调用构造器来初始化实例字段。invokespecial</li>
<li>Object.clone 方法和反序列化通过直接复制已有的数据，来初始化新建对象的实例字段</li>
<li>Unsafe.allocateInstance 方法则没有初始化实例字段</li>
</ol>
<p>如果一个类没有定义任何构造器的话， Java 编译器会自动添加一个无参数的构造器。如果任何构造器有则不添加。</p>
<p>每个类的构造器皆会直接或者间接调用父类的构造器，直至Object类。父类存在无参构造器则通过编译期自动隐式调用；父类没有无参构造器，则子类构造器要super显式调用父类构造器。</p>
<p>Java 对象都有一个对象头（object header），由标记字段和类型指针所构成。标记字段内有哈希码、GC 信息以及锁信息等运行数据；类型指针则指向该对象的类。</p>
<p>Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。</p>
<p>Trace跟踪参数</p>
<table>
<thead>
<tr>
<th>-Xlog:gc/-Xlog:gc*</th>
<th>打印GC简要/详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xlog:gc:filename</td>
<td>GC文件输出</td>
</tr>
<tr>
<td>-Xlog:gc+heap=debug</td>
<td>每次GC后都打印堆信息</td>
</tr>
</tbody>
</table>
<p>GC日志格式：GC发生时间(jvm启动以来的秒数)、日志级别/类型、GC识别号(第几次GC)、GC类型/原因、GC容量:GC前-&gt;GC后(该区总容量)、GC持续时间秒：user/sys/real 应用/系统内核/真正耗时</p>
<p>Java栈的参数</p>
<table>
<thead>
<tr>
<th>-Xss</th>
<th>通常几百k，决定了函数的调用深度</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Java堆的参数</p>
<table>
<thead>
<tr>
<th>-Xms</th>
<th>初始堆大小</th>
<th>默认：物理内存的1/64</th>
<th>XX:InitialHeapSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>默认：物理内存的1/4</td>
<td>XX:MaxHeapSize</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
<td>默认：物理内存的3/8</td>
<td></td>
</tr>
<tr>
<td>XX:MinHeapSize</td>
<td>最小堆大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td></td>
<td></td>
<td>CMS收集器</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td></td>
<td>不指定路径则运行路径</td>
<td>OOM时导出堆内存快照到文件</td>
</tr>
<tr>
<td>-XX:+HeapDumpPath</td>
<td></td>
<td></td>
<td>导出OOM的路经</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>老/新</td>
<td>默认2</td>
<td>老年代/新生代的比率</td>
</tr>
<tr>
<td>-XX:ServivorRatio</td>
<td>Eden/Survivor</td>
<td>Survivor:from/to</td>
<td>1个Eden/1个Survivor的比率</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Survivor分成两份，From区和To区（两个区不同时存在，只做拷贝算法时区分）。-XX:ServivorRatio=8时，1eden/1Survivor=8/1 实际Survivor存在两份因此eden/2Survivor=8/2。每个Survivor占新生代的1/10</p>
</blockquote>
<p>在JDK新版本默认G1收集器之前，默认使用的是CMS收集器。</p>
<h1 id="jvm如何执行方法">JVM如何执行方法</h1>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704124551809.png" alt="image-20210704124551809" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704124613379.png" alt="image-20210704124613379" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704124952132.png" alt="image-20210704124952132" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704125231430.png" alt="image-20210704125231430" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704130004781.png" alt="image-20210704130004781" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704130028605.png" alt="image-20210704130028605" loading="lazy"><br />jdk8以后永久区改为元空间</td>
</tr>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704130646995.png" alt="image-20210704130646995" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704131016908.png" alt="image-20210704131016908" loading="lazy"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704221125426.png" alt="image-20210704221125426" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704221153895.png" alt="image-20210704221153895" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704221248193.png" alt="image-20210704221248193" loading="lazy"><br />long/double静态方法就没有this<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210704221355962.png" alt="image-20210704221355962" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705012342931.png" alt="image-20210705012342931" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705012436995.png" alt="image-20210705012436995" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705012846529.png" alt="image-20210705012846529" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>实例方法：是区别与静态方法的叫法，即要初始化一个实例才能调用的方法。不同于静态方法[类名.方法名]的调用，多数都是实例方法。因此类外的才叫函数。因此实例方法在局部变量表里0位位this，可以供实例来调用。</p>
<p>java中父类的私有方法可以被子类继承，但无法访问。看起来就跟不能继承一样。</p>
<p>方法分派：</p>
<p>静态分派：根据方法名称、参数不同再编译期就决定的<strong>重载方法</strong>。</p>
<p>动态分派：多态下运行时才能决定到底是哪个实例调用的<strong>重写方法</strong>。</p>
<p>在 Java语言中，方法重载指的是方法同名不同参，重写指的是方法同名同参。Java 虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。</p>
<p>重载在编译期，Java 编译器会根据所传入参数的<strong>声明类型</strong>（注意与实际类型区分）来选取重载方法。**重载也可用于继承方法。**若子类和父类非私有方法同名不同参，同样构成重载。若子类和父类非私有方法同名同参同返回值类型(或派生类型)：</p>
<ul>
<li>若都是静态方法则子类隐藏父类方法</li>
<li>若都是非私有非静态方法，构成重写</li>
</ul>
<blockquote>
<p>重载也可以作用于继承方法：在子类直接重载父类方法，或在子类重载已被继承过来的方法都可以。</p>
</blockquote>
<p>方法重写，正是<strong>Java 面向对象的特性多态</strong>最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。</p>
<blockquote>
<ol>
<li>优先选择没有基本类型自动装拆箱的参数、没有可变参数的方法重载。</li>
<li>其次允许有基本类型自动拆装箱的参数的方法，但没有可变参数的方法重载。</li>
<li>最后才允许基本类型自动拆装箱参数和可变参数的方法重载。</li>
</ol>
<p>存在多个符合条件的重载时，再根据参数类型的集成关系决定贴切程度。</p>
<p>如比三个重载方法同名，参数类型分别为int、Integer、Object。传int类型(非包装)参数调用时，int类型的更贴切。</p>
</blockquote>
<p>Java 虚拟机通过<strong>类名、方法名以及方法描述符</strong>（method descriptor）识别一个方法。方法描述符，是由方法的参数类型以及返回类型所构成。</p>
<blockquote>
<p>JVM的方法重载识别和Java语言(编译器前端的文法语法解析)不同，并不限制同名同参仅返回值不同的两个方法在一个类里(在Java语言前端编译回报错)。因为方法调用者附带的方法描述符包含了返回值，足以识别出该方法。</p>
<p>JVM的方法重写也基于方法描述符，即子类和父类的非私有非静态方法同名且同参同返回值类型时，JVM才判定位重写。(java语法判定重写还支持返回值类型的派生类型。）</p>
<p>子类和父类 同名同参，但返回值是其父类方法返回值类型的派生类 的非私非静方法，编译器会通过生成桥接方法实现 Java语言中的重写语义。(jvm判定非重写--返回值类型不同，java语法判定为重写--返回值类型为派生类型，因此要桥接)</p>
<p>前端判定只根据文法，后端判定根据JVM规则。因此才有Java语言书写和Jvm判定对于重载/重写的不同。</p>
<p>由于 Java 编译器已经区分了重载的方法，因此对于JVM来说不存在重载这一概念。静态绑定（static binding）/动态绑定（dynamic binding）是重载/重写的说法并不准确。如某个类的重载方法可以被子类重写。因此 Java 编译器会将<strong>所有对非私有实例方法的调用</strong>编译为需要动态绑定。</p>
<p>Java 字节码中与调用相关的指令共有五种。</p>
<ol>
<li>invokestatic：用于调用静态方法。</li>
<li>invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li>
<li>invokevirtual：用于调用非私有实例方法。</li>
<li>invokeinterface：用于调用接口方法。</li>
<li>invokedynamic：用于调用动态方法。</li>
</ol>
</blockquote>
<h2 id="方法符号引用解析优先级">方法符号引用解析优先级</h2>
<p>在类的加载、链接(验证、准备和解析)、初始化。解析阶段把符号引用解析成实际引用。符号引用在常量池中，可以用<code>javap -v</code>查看。</p>
<p>装载方法所在的类时，并不知道目标方法(还有变量等)的具体内存地址。因此在编译时会暂时用符号引用来表示该目标方法。其中方法的符号引用内包括：目标方法名、方法描述符(参数、返回值)、和所在类/接口名，且有接口方法符号引用(InterfaceMethodref)和方法符号引用(Methodref)两种。在执行调用指令前(链接-解析)，把附带的符号引用解析成实际引用。流程如下：</p>
<ol>
<li>优先解析成：<strong>当前类/接口内的同名同描述符方法</strong></li>
<li>如果当前类/接口不存在符合的方法，则<strong>递归寻找父类中的符合方法</strong>(直至Object类，没非静态限制)</li>
<li>如果在父类里还不存在符合的方法，则寻找<strong>直接实现或间接实现的接口中的非私有、非静态方法。</strong></li>
</ol>
<blockquote>
<p>因此，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。</p>
</blockquote>
<p>经过上述的解析步骤之后，符号引用会被解析成实际引用。可以静态绑定的方法调用，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为<strong>方法表的索引值等</strong>辅助动态绑定的信息。</p>
<h2 id="虚方法与索引表">虚方法与索引表</h2>
<p>Java 里所有<strong>非私有实例方法</strong>调用都会被编译成 invokevirtual 指令，而<strong>接口方法</strong>调用都会被编译成 invokeinterface 指令。这两种指令，均属于 <strong>Java 虚拟机中的虚方法调用，虚拟机将根据调用者的动态类型采用动态绑定</strong></p>
<blockquote>
<p>Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。(如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。)</p>
<p>Java 虚拟机为每个类生成一张<strong>方法表</strong>，用以快速定位目标方法。方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可以是具体方法或抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。</p>
<p>invokevirtual 所使用的虚方法表（virtual method table，vtable）</p>
<p>invokeinterface 所使用的接口方法表（interface method table，itable）</p>
</blockquote>
<p>方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值。</p>
<p>链接-解析时，把常量池中「方法的符号引用」解析成实际引用。当虚方法被调用时，会根据调用者的实际类型，查找该实际类型的虚方法表，根据索引值确定目标方法。</p>
<p>Java 虚拟机中的即时编译器会使用<strong>内联缓存</strong>来加速动态绑定。新的调用时，有缓存则区，没有还退化使用方法表进行动态绑定。</p>
<pre><code class="language-java">//局部变量表5:只有把bs包裹住，再用方案覆盖slot槽位/置空bs，剩余的内存才会变多
public static void main(String[] args) {
    {//用方法块包裹住局部变量
        byte[] bs = new byte[2 * 1024 * 1024];//局部变量bs的作用域为其所在方法块
    //  bs=null;//方案二：bs指向堆的空间置空
    }//bs出了作用域就可以被回收
    //  int a = 5;//方案一：覆盖bs槽位
    System.gc();//并不一定保证GC
    //slot槽位情况
    //0--args
    //1--bs-----指向堆空间放着2M数据   gc时本地变量表还在用bs
    //1--a将槽位1给局部变量a复用
    System.out.println(&quot;free:&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024.0);
}
</code></pre>
<pre><code class="language-java">public class Test3 {
    public void m1(Object a) {
        System.out.println(&quot;Object &quot; + a);
    }
    public void m1(Integer a) {
        System.out.println(&quot;Integer &quot; + a);
    }
    public void m1(int a) {
        System.out.println(&quot;int &quot; + a);
    }
    public void m1(String a) {//静态分派：重载
        System.out.println(&quot;string &quot; + a);
    }
    public static class Child extends Test3 {
//        public void m1(int a) {
//            System.out.println(&quot;child int &quot;+a);
//        }
        public void m1(int a,int b) {
            System.out.println(&quot;child a+b int &quot;+a+b);
        }
    }

    public static void main(String[] args) {
//        Test3 t = new Test3();
        Test3 t = new Child();//动态分派：重写。看实例是child还是parent
//        t.m1(&quot;str&quot;);
        t.m1(5);//当前实例有这个方法就调，没有就调父类的。父类方法可以重载，重载方法存在范围覆盖时：int方法没有则调用Integer再没有则Obj。从小范围到大范围。
//        t.m1(Integer.valueOf(5));
//        t.m1(new Object());重载方法存在参数范围覆盖时，优先调用精准的小范围。object是最大的范围，因此只能调用object这一个方法。
        //第一个维度先看动态分派是子类还是父类实例的方法
        //第二个维度再看静态分派匹配同名不同参数的方法
    }
}
</code></pre>
<pre><code class="language-java">public int add(int a, int b) {//栈帧-操作数栈：操作的指令哪个在最顶部
    int c = a + b;
    return a + b + c;
}
 0: iload_1     导入int 参数1 对应局部变量表的a
 1: iload_2
 2: iadd
 3: istore_3    存入int 参数3 对应c
 4: iload_1
 5: iload_2
 6: iadd        int相加 a+b
 7: iload_3
 8: iadd        a+b+c
 9: ireturn     返回int
 LineNumberTable:
 line 5: 0
 line 6: 4
 LocalVariableTable:
 Start  Length  Slot  Name   Signature
 0      10     0  this   Lcom/data/execute/Test2;
 0      10     1     a   I
 0      10     2     b   I
 4       6     3     c   I
</code></pre>
<p>可做为GC Roots对象包括：</p>
<ol>
<li>栈帧中方法局部变量所引用到的对象（局部变量表引用的）</li>
<li>方法区中类的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中jni引用的对象</li>
<li>所有被synchronized同步锁持有的对象</li>
</ol>
<p>SoftReference：GC后内存还不够就回收，WeakReference：GC时回收掉，PhantomReference发生GC就会被回收掉。</p>
<p>判断是否为垃圾的步骤：</p>
<p>首先根搜索算法判断，若对象没有引用链，然后看是否要执行finalize方法自救一次。最后又没引用链又不需要自救即为垃圾。</p>
<p>MinorGC/YoungGC：发生在新生代的GC</p>
<p>Major/OldGC：发生在老年代的GC。目前只有CMS收集器存在单独收集老年代垃圾的行为。</p>
<p>MixedGC：收集整个新生代和部分老年代的GC。目前只有G1收集器有这种行为。</p>
<p>FullGC：收集整个Java堆和方法区的GC。</p>
<p><strong>STW</strong>：stop-the-world 多半由GC引起的全局暂停。</p>
<p><strong>safe-point</strong>：HotSpot使用OopMap（描述对象之间引用关系的数据结构）达到准确的GC，而不必从root查找。JVM并不是为所有的指令都生成一个OopMap，线程只有执行到记录OopMap的特定位置，才允许暂停下来进行GC。这些&quot;特定位置&quot;即Safe-Point。</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705132501413.png" alt="image-20210705132501413" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705132550761.png" alt="image-20210705132550761" loading="lazy"><br />4无法再任何地方通过反射访问这个类<br /><br />没有用的类JVM就可以把它从内存卸载</th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184127924.png" alt="image-20210705184127924" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184301530.png" alt="image-20210705184301530" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184228618.png" alt="image-20210705184228618" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184407694.png" alt="image-20210705184407694" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184344602.png" alt="image-20210705184344602" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705184445983.png" alt="image-20210705184445983" loading="lazy"></td>
</tr>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705190413920.png" alt="image-20210705190413920" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705190518042.png" alt="image-20210705190518042" loading="lazy"></td>
<td></td>
</tr>
</tbody>
</table>
<p>HotSpot默认Eden和Survivor是8：1，即新生代90%空间可用。若新生代垃圾回收后，存活区放不下了，要依赖老年代(元空间)进行<strong>分配担保</strong>，来把放不下的对象直接进入老年代，流程如下：</p>
<ul>
<li>在新生代GC(MinorGC)前，JVM检查老年代的最大可用连续空间，看其是否大于新生代所有对象的总空间，</li>
<li>若大于则取保新生代GC是安全的；</li>
<li>若小于则检查是否设置了[允许担保失败]，若设置了则检查老年代的最大可用空间，看其是否大于历次晋升到老年代对象的平均值：大于则进行新生代GC(MinorGC);不大于则该做一次Full GC。</li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705190637047.png" alt="image-20210705190637047" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705194007855.png" alt="image-20210705194007855" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>HotSpot中：新生代使用ParNew收集器时。老年代使用CMS收集器，同时把SerialOld作为备用。</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191207939.png" alt="image-20210705191207939" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191131988.png" alt="image-20210705191131988" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191420093.png" alt="image-20210705191420093" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191756628.png" alt="image-20210705191756628" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191844011.png" alt="image-20210705191844011" loading="lazy"><br />-XX:ParallelGCThreads指定线程数最好和cpu核数一致</td>
</tr>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191510815.png" alt="image-20210705191510815" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192110314.png" alt="image-20210705192110314" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192425140.png" alt="image-20210705192425140" loading="lazy"><br />-XX:+UseParallelGC/-XX:+UseParallelOldGC开启<br /></td>
</tr>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191602749.png" alt="image-20210705191602749" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192626044.png" alt="image-20210705192626044" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192803209.png" alt="image-20210705192803209" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192849309.png" alt="image-20210705192849309" loading="lazy"></td>
</tr>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191641957.png" alt="image-20210705191641957" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193041560.png" alt="image-20210705193041560" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193128793.png" alt="image-20210705193128793" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193225337.png" alt="image-20210705193225337" loading="lazy"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191602749.png" alt="image-20210705191602749" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192626044.png" alt="image-20210705192626044" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192803209.png" alt="image-20210705192803209" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705192849309.png" alt="image-20210705192849309" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705191641957.png" alt="image-20210705191641957" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193823497.png" alt="image-20210705193823497" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193041560.png" alt="image-20210705193041560" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193128793.png" alt="image-20210705193128793" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193225337.png" alt="image-20210705193225337" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193649657.png" alt="image-20210705193649657" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210705193717877.png" alt="image-20210705193717877" loading="lazy"><br /></td>
</tr>
</tbody>
</table>
<p>GC性能指标：</p>
<ul>
<li>吞吐量：非GC执行的时间/运行总时间</li>
<li>GC负荷，与吞吐量相反 ：GC时间/运行总时间</li>
<li>暂停时间：STW的总时间</li>
<li>GC频率：一个时间段发生GC的次数</li>
<li>反应速度：对象成为垃圾到被回收的时间</li>
</ul>
<p>编译器优化的指令重排序</p>
<p>happens-before 关系是用来描述两个操作的内存可见性的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。</p>
<p>除了线程内的 happens-before 关系之外，Java 内存模型还定义了下述线程间的 happens-before 关系。</p>
<ol>
<li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li>
<li>volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li>
<li>线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。</li>
<li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。</li>
<li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li>
<li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li>
</ol>
<blockquote>
<p>Java 内存模型的底层实现通过内存屏障（memory barrier），编译器针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障来禁止重排序。</p>
<p>编译器将内存屏障替换成具体的 CPU 指令(如x86读读、读写以及写写内存屏障是空操作（no-op）)。</p>
</blockquote>
<h2 id="锁volatile-字段final-字段与安全发布">锁，volatile 字段，final 字段与安全发布</h2>
<p>解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。</p>
<p>volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。</p>
<p>volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。</p>
<p>volatile  字段的每次访问均需要直接从内存中读写，不能缓存到寄存器里。</p>
<p>当一个对象包含 final 实例字段时，为了保证其他线程只能看到已初始化的 final 实例字段。编译器会在 final 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前。当发布一个已初始化的对象时，要保证所有已初始化的实例字段对其他线程可见。</p>
<p>synchronized 代码块，编译而成的字节码将包含一个 monitorenter 和 多个monitorexit 指令。(这是因为 Java 虚拟机需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。)这两种指令均会把操作数栈上的一个引用类型的元素（也就是 synchronized 关键字括号里的引用），作为所要加锁解锁的锁对象。</p>
<p>monitorenter 和 monitorexit 操作所对应的锁对象是隐式的。对于实例方法来说，这两个操作对应的锁对象是 this；对于静态方法来说，这两个操作对应的锁对象则是所在类的 Class 实例。</p>
<p>重量级锁: 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>
<blockquote>
<p>Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的。比如linux中是通过 pthread 的互斥锁（mutex）来实现的，此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，开销大。</p>
<p>为了尽量避免昂贵的线程阻塞、唤醒操作，线程进入阻塞前或被唤醒但竞争不到锁时进入自旋状态，在处理器上空跑并且轮询锁是否被释放，获取到则不必进入阻塞。自旋多久呢？自适应自旋：根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间。</p>
<p>阻塞相当于熄火，自旋状态相当于怠速。</p>
</blockquote>
<p>CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。</p>
<p>当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。<strong>CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false</strong>。</p>
<p>轻量级锁采用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址：将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。</p>
<p>偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。</p>
<blockquote>
<p>对象头中的标记字段（mark word）的最后两位表示对象的锁状态：00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706004744232.png" alt="image-20210706004744232" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005149482.png" alt="image-20210706005149482" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005641447.png" alt="image-20210706005641447" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005728965.png" alt="image-20210706005728965" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005819841.png" alt="image-20210706005819841" loading="lazy"></td>
<td><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706004821761-20210706135125579-20210706135208204.png" alt="image-20210706004821761" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706004920244.png" alt="image-20210706004920244" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005012823-20210706133540008-20210706133553863-20210706135125698-20210706135208448.png" alt="image-20210706005012823" loading="lazy"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706005935649.png" alt="image-20210706005935649" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010008067.png" alt="image-20210706010008067" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010111759.png" alt="image-20210706010111759" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010136210.png" alt="image-20210706010136210" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010212690.png" alt="image-20210706010212690" loading="lazy"><br /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010245048.png" alt="image-20210706010245048" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706004158281.png" alt="image-20210706004158281" loading="lazy"><br />上文的锁优化JVM内自动进行<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210706010319025.png" alt="image-20210706010319025" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-java">Integer a=1;//字节码指令是invokeStatic Integer.valueOf()即把基本类型封装成Integer对象
if (x==2){}//字节码指令是invokeStatic Integer.intValue()即从Integer解封出基本类型
</code></pre>
<ol>
<li><code>java -jar asmtools.jar jdis Foo.class &gt;Foo.jasm</code>	用JASM语法查看Foo.class，并将查看结果重定向到Foo.jasm</li>
<li>修改Foo.jasm中的指令</li>
<li><code>java -jar asmtools.jar jasm Foo.jasm</code>  用JASM语法的Foo.jasm生成相应的class文件，并执行。</li>
</ol>
<blockquote>
<p><code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p>
<ul>
<li>
<p>JASM</p>
<p>用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p>
</li>
<li>
<p>JCOD</p>
<p>整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p>
<p>查看：<code>java -jar asmtools.jar jdec Foo.class</code></p>
<p>生成class：<code>java -jar asmtools.jar jcoder Foo.jasm</code></p>
</li>
</ul>
</blockquote>
<h2 id="异常">异常</h2>
<p>Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为 RuntimeException 和其他类型。RuntimeException 和 Error 属于非检查异常。其他的 Exception 皆属于检查异常，在触发时需要显式捕获，或者在方法头用 throws 关键字声明。</p>
<ol>
<li>try 代码块：标记需要异常监控的代码。</li>
<li>catch 代码块：捕获异常的类型和异常处理器（可多个）</li>
<li>finally 代码块：不管是否能catch到，都会执行。</li>
</ol>
<p>Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。</p>
<p>javap中异常表（Exception table）用偏移量来定位每个异常处理器所监控的范围（由 from 到 to 的代码区域），以及异常处理器的起始位置（target）。除此之外，它还会声明所捕获的异常类型（type）</p>
<p>原始的finally就是把finally区指令拷贝几份，根据是否catch异常，放在try、catch前后执行</p>
<h2 id="反射">反射</h2>
<p>方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p>
<p>方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。</p>
<p>使用反射 API 的第一步便是获取 Class 对象。在 Java 中常见的有这么三种。</p>
<ol>
<li>使用静态方法 Class.forName 来获取。</li>
<li>调用对象的 getClass() 方法。</li>
<li>直接用类名 +“.class”访问。对于基本类型来说，它们的包装类型（wrapper classes）拥有一个名为“TYPE”的 final 静态字段，指向该基本类型对应的 Class 对象。</li>
</ol>
<blockquote>
<p>例如，Integer.TYPE 指向 int.class。对于数组类型来说，可以使用类名 +“[ ].class”来访问，如 int[ ].class。</p>
<p>除此之外，Class 类和 java.lang.reflect 包中还提供了许多返回 Class 对象的方法。例如，对于数组类的 Class 对象，调用 Class.getComponentType() 方法可以获得数组元素的类型。</p>
</blockquote>
<p>一旦得到了 Class 对象，我们便可以正式地使用反射功能了。下面我列举了较为常用的几项。</p>
<ol>
<li>使用 newInstance() 来生成一个该类的实例。它要求该类中拥有一个无参数的构造器。</li>
<li>使用 isInstance(Object) 来判断一个对象是否该类的实例，语法上等同于 instanceof 关键字（JIT 优化时会有差别，我会在本专栏的第二部分详细介绍）。</li>
<li>使用 Array.newInstance(Class,int) 来构造该类型的数组。</li>
<li>使用 getFields()/getConstructors()/getMethods() 来访问该类的成员。除了这三个之外，Class 类还提供了许多其他方法。方法名中带 Declared 的不会返回父类的成员，但是会返回私有成员；而不带 Declared 的则相反。</li>
</ol>
<p>当获得了类成员之后，我们可以进一步做如下操作。</p>
<ul>
<li>使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。</li>
<li>使用 Constructor.newInstance(Object[]) 来生成该类的实例。</li>
<li>使用 Field.get/set(Object) 来访问字段的值。</li>
<li>使用 Method.invoke(Object, Object[]) 来调用方法。</li>
</ul>
<h2 id="java语法糖与java编译器">Java语法糖与Java编译器</h2>
<p>Java语法糖-是一种帮助开发人员提高开发效率的小甜点，原理是将一些繁琐的事情交给编译器来处理，开发人员少做一些事情。包装类型自动拆装箱泛型擦除等</p>
<p>基本类型和其包装类型之间的自动转换，也就是自动装箱、自动拆箱，是通过加入 [Wrapper].valueOf（如 Integer.valueOf）以及 [Wrapper].[primitive]Value（如 Integer.intValue）方法调用来实现的。</p>
<p>Java 语法的泛型信息，在编译成字节码后丢失了（这么做主要是为了兼容引入泛型之前的代码）。并不是每一个泛型参数被擦除类型后都会变成 Object 类。对于限定了继承类的泛型参数，经过类型擦除后，所有的泛型参数都将变成所限定的继承类。即Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的类。</p>
<blockquote>
<p>泛型的类型擦除带来了不少问题。其中一个便是泛型方法重写：</p>
<pre><code class="language-java">class Merchant&lt;T extends Customer&gt; {
  public double actionPrice(T customer) {return 1;}
}
class VIPMerchant extends Merchant&lt;VIP&gt; {
  @Override
  public double actionPrice(VIP customer) {return 0.8;}
  // 字节码层面的桥接方法等同于
  public double actionPrice(Customer customer) {
   return actionPrice((VIP) customer);
  }
}
</code></pre>
<p>为保证编译后Java 字节码能够保留原来重写的语义，Java 编译器在字节码层面额外添加了一个<strong>桥接方法</strong>。即子类重写父类的方法，并在内部调用子类自己的方法。</p>
<p>javap 中，该桥接方法的访问标识为 ACC_BRIDGE或 ACC_SYNTHETIC。</p>
<p>隐藏的桥接方法能被反射机制调用。</p>
<p>除了泛型重写会生成桥接方法之外；子类定义了一个与父类参数类型相同的方法，其返回类型为父类方法返回类型的子类，那么 Java 编译器也会为其生成桥接方法。</p>
</blockquote>
<p>变长参数、try-with-resources （在try小括号内，保证操作完的资源自动关闭）以及在同一 catch 代码块中捕获多种异常等语法糖。</p>
<p>对数组或者 Iterable 对象的foreach 循环语法糖<code>for (int item : array) {}</code> ：根据下标访问数组元素，Iterable 对象hasNext 以及 next 方法来遍历该 Iterable 对象中的元素。</p>
<p>字符串 switch语法糖：是一个哈希桶。由于每个 case 所截获的字符串都是常量值，因此，Java 编译器会将原来的字符串 switch 转换为 int 值 switch，比较所输入的字符串的哈希值。</p>
<p>由于字符串哈希值很容易发生碰撞，因此，我们还需要用 String.equals 逐个比较相同哈希值的字符串</p>
<p><strong>方法内联</strong>：在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。方法内联不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化，是编译优化里最为重要的一环。</p>
<h2 id="jni">JNI</h2>
<p>在调用 native 方法前，Java 虚拟机需要将该 native 方法链接至对应的 C 函数上。</p>
<p>方式一：采用<code>javac -h</code>命令，根据 Java 程序中的 native 方法声明，自动生成包含符合命名规范的 C 函数的头文件。让 Java 虚拟机自动查找符合默认命名规范的 C 函数，并且链接起来。</p>
<p>方式二：是在 C 代码中主动链接。这种链接方式对 C 函数名没有要求，使用registerNatives 的 native 方法，并手动链接该类的其他 native 方法。使用这种方式进行链接时，要在其他 native 方法被调用之前完成链接工作。因此，通常会在类的初始化方法里调用该<code>registerNatives</code>方法，如静态代码块里。</p>
<blockquote>
<pre><code class="language-java">// 注：Object 类的 registerNatives 方法的实现位于 java.base 模块里的 C 代码中
static JNINativeMethod methods[] = {
    {&quot;hashCode&quot;,    &quot;()I&quot;,                    (void *)&amp;JVM_IHashCode},
    {&quot;wait&quot;,        &quot;(J)V&quot;,                   (void *)&amp;JVM_MonitorWait},
    {&quot;notify&quot;,      &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotify},
    {&quot;notifyAll&quot;,   &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotifyAll},
    {&quot;clone&quot;,       &quot;()Ljava/lang/Object;&quot;,   (void *)&amp;JVM_Clone},
};
 
JNIEXPORT void JNICALL
Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)
{
    (*env)-&gt;RegisterNatives(env, cls,
                            methods, sizeof(methods)/sizeof(methods[0]));
}
</code></pre>
</blockquote>
<p>动态链接库的名字须以<code>lib</code>为前缀，以<code>.dylib</code>(或 Linux 上的<code>.so</code>）为扩展名。在 Java 程序中，我们可以通过<code>System.loadLibrary(&quot;foo&quot;)</code>方法来加载<code>libfoo.dylib</code></p>
<p>如果<code>libfoo.dylib</code>不在当前路径下，我们可以在启动 Java 虚拟机时配置<code>java.library.path</code>参数，使其指向包含<code>libfoo.dylib</code>的文件夹。</p>
<pre><code class="language-bash">$ java -Djava.library.path=/PATH/TO/DIR/CONTAINING/libfoo.dylib org.example.Foo
</code></pre>
<p>Java 虚拟机会将所有 JNI 函数的函数指针聚合到一个名为<code>JNIEnv</code>线程私有的数据结构之中。Java 虚拟机会为每个线程创建一个<code>JNIEnv</code>，并规定 C 代码不能将当前线程的<code>JNIEnv</code>共享给其他线程，否则 JNI 函数的正确性将无法保证。</p>
<blockquote>
<p>这么设计的原因主要有两个。一是给 JNI 函数提供一个单独命名空间。二是允许 Java 虚拟机通过更改函数指针替换 JNI 函数的具体实现\</p>
</blockquote>
<p>静态native方法传入jclass，即定义该static native方法的java类</p>
<p>实例native方法传入jobject，代指该方法的调用者，即java类的实例</p>
<pre><code class="language-c">// foo.c
#include &lt;stdio.h&gt;
#include &quot;org_example_Foo.h&quot; 
JNIEXPORT void JNICALL Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2
  (JNIEnv *env, jobject thisObject, jstring str, jobject obj) {
  jclass cls = (*env)-&gt;GetObjectClass(env, thisObject);
  jfieldID fieldID = (*env)-&gt;GetFieldID(env, cls, &quot;i&quot;, &quot;I&quot;);
  jint value = (*env)-&gt;GetIntField(env, thisObject, fieldID);
  printf(&quot;Hello, World 0x%x\n&quot;, value);
  return;
}
</code></pre>
<p>在 JNI 中访问字段类似于反射 API：我们首先需要通过类实例获得<code>FieldID</code>，然后再通过<code>FieldID</code>获得某个实例中该字段的值。</p>
<p>JNI 函数的异常并不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。当从可能触发异常的 JNI 函数返回时，我们需要通过 JNI 函数<code>ExceptionOccurred</code>检查是否发生了异常，并且作出相应的处理。如果无须抛出该异常，那么我们需要通过 JNI 函数<code>ExceptionClear</code>显式地清空已缓存的异常。</p>
<p>。</p>
<p>JNI 的局部引用（Local Reference）和全局引用（Global Reference）。这些 C 代码中可能引用到的 Java 对象，垃圾回收算法会将被这两种引用指向的对象标记为不可回收。</p>
<p>无论是传入的引用类型参数，还是通过 JNI 函数（除<code>NewGlobalRef</code>及<code>NewWeakGlobalRef</code>之外）返回的引用类型对象，都属于局部引用。</p>
<p>一旦从 C 函数中返回至 Java 方法之中，那么局部引用将失效。垃圾回收器在标记垃圾时不再考虑这些局部引用。JNI 函数<code>NewGlobalRef</code>，将该局部引用转换为全局引用，以确保其指向的 Java 对象不会被垃圾回收。JNI 函数<code>DeleteGlobalRef</code>来消除全局引用，以便回收被全局引用指向的 Java 对象。</p>
<h2 id="注解处理器">注解处理器</h2>
<p>Java 的注解机制允许开发人员自定义注解。这些自定义注解同样可以为 Java 编译器添加编译规则。不过，这种功能需要由开发人员提供，并且以插件的形式接入 Java 编译器中，这些插件我们称之为注解处理器（annotation processor）。</p>
<p>注解处理器主要有三个用途。一是定义编译规则，并检查被编译的源文件。二是修改已有源代码。三是生成新的源代码。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/64/b8/64e93f67c3b422afd90966bfe9aaf5b8.png" alt="注解" loading="lazy"></figure>
<p>Java 源代码的编译过程可分为三个步骤：</p>
<ol>
<li>解析源文件生成抽象语法树</li>
<li>调用已注册的注解处理器</li>
<li>生成字节码</li>
</ol>
<p>如果在第 2 步中，注解处理器生成了新的源代码，那么 Java 编译器将重复第 1、2 步，直至不再生成新的源代码。解析并且处理新生成的源文件为一轮（Round），如果注解处理器生成了新的源文件则多轮直至不再生成新的源文件，并最终生成字节码。</p>
<p>所有的注解处理器类都需要实现接口<code>Processor</code>。该接口主要有四个重要方法。</p>
<ul>
<li><code>init</code>方法用来存放注解处理器的初始化代码。<br>
之所以不用构造器，是因为在 Java 编译器中，注解处理器的实例是通过反射 API 生成的。也正是因为使用反射 API，每个注解处理器类都需要定义一个无参数构造器。</li>
<li><code>getSupportedAnnotationTypes</code>方法将返回注解处理器所支持的注解类型，这些注解类型只需用字符串形式表示即可。</li>
<li><code>getSupportedSourceVersion</code>方法将返回该处理器所支持的 Java 版本，通常，这个版本需要与你的 Java 编译器版本保持一致；</li>
<li><code>process</code>方法则是最为关键的注解处理方法。</li>
</ul>
<p>JDK 提供了一个实现<code>Processor</code>接口的抽象类<code>AbstractProcessor</code>。该抽象类实现了<code>init</code>、<code>getSupportedAnnotationTypes</code>和<code>getSupportedSourceVersion</code>方法。</p>
<p>它的子类可以通过<code>@SupportedAnnotationTypes</code>和<code>@SupportedSourceVersion</code>注解来声明所支持的注解类型以及 Java 版本。</p>
<pre><code class="language-java"> public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {}
</code></pre>
<p><code>process</code>接收两个参数，分别代表该注解处理器所能处理的注解类型，以及囊括当前轮生成的抽象语法树的<code>RoundEnvironment</code>。<code>process</code>方法涉及各种不同类型的<code>Element</code>，分别指代 抽象语法树的各个结构。如<code>TypeElement</code>指代类或者接口，<code>VariableElement</code>指代字段、局部变量、enum 常量等，<code>ExecutableElement</code>指代方法或者构造器。这些结构之间也有从属关系，我们可以通过<code>TypeElement.getEnclosedElements</code>方法，获得上面这段代码中<code>Foo</code>类的字段、构造器以及方法。也可以通过<code>ExecutableElement.getParameters</code>方法，获得<code>setA</code>方法的参数。</p>
<pre><code class="language-java">package foo;     // PackageElement
class Foo {      // TypeElement
  int a;           // VariableElement
  static int b;    // VariableElement
  Foo () {}        // ExecutableElement
  void setA (      // ExecutableElement
    int newA         // VariableElement
  ) {}
}
</code></pre>
<p>将该注解处理器编译成 class 文件后，可以将其注册为 Java 编译器的插件，并用来处理其他源代码。注册的方法主要有两种。</p>
<p>第一种是直接使用 javac 命令的<code>-processor</code></p>
<pre><code class="language-bash">$ javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java
</code></pre>
<p>第二种则是将注解处理器编译生成的 class 文件压缩入 jar 包中，并在 jar 包的配置文件中记录该注解处理器的包名及类名，即<code>bar.CheckGetterProcessor</code>。当启动 Java 编译器时，它会寻找 classpath 路径上的 jar 包是否包含上述配置文件，并自动注册其中记录的注解处理器。</p>
<pre><code class="language-bash">（具体路径及配置文件名为`META-INF/services/javax.annotation.processing.Processor`）
$ javac -cp /PATH/TO/CheckGetterProcessor.jar Foo.java
</code></pre>
<p>注解处理器可以用来修改已有源代码或者生成源代码。确切地说，注解处理器并不能真正地修改已有源代码。这里指的是修改由 Java 源代码生成的抽象语法树，在其中修改已有树节点或者插入新的树节点，从而使生成的字节码发生变化。生成源代码的方式实际上非常容易理解。我们可以通过<code>Filer.createSourceFile</code>方法获得一个类似于文件的概念，并通过<code>PrintWriter</code>将具体的内容一一写入即可。</p>
<p>jar：Java Archive，java二进制归档文件，多个.class文件打包的文件</p>
<p>aar：Android Archive，Android二进制归档文件，由jar和Android资源文件</p>
<p>dex：将.class优化打包后的文件，dalvik虚拟机则是.dex可执行文件</p>
<p>smali：Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。</p>
<p>apk：Android application package，包含.dex、resource文件资源、assets原生文件资源、应用证书签名、AndroidManifest等组成</p>
<p>jar包内出了class还要包含MENIFEST.MF文件（包含Main-Class信息，必须尾空行 ），通常在META-INF文件夹下。</p>
<pre><code class="language-bash"> jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class 打包三个文件为hello.jar  
 jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com 打包两个文件和com目录 
 java -jar hello.jar 允许jar
</code></pre>
<p>c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名，m表示要定义MENIFEST文件。</p>
<p>javac编译class为jar时，-cp 引入所依赖的jar包，依赖其他类时也可以将其打成jar再依赖。:分割(win是/)；-cp即classpath即查找class的路径</p>
<p>打jar包时还要依赖其他jar时。manifest.mf中定义Class-Path:。manifest.mf要在末尾空一行。manifest.mf的键值对(key： value)值前空格。要添加多个cp时要换行，换行时在行尾要空格，在新行的行首也要空格。</p>
<h2 id="jvm是怎么和操作系统交互的">JVM是怎么和操作系统交互的</h2>
<h3 id="内存管理角度">内存管理角度</h3>
<p>为了提升 CPU 的指令处理速度，运算单元一直处于运算中（保证运算单元在执行前的准备工作都完成），而串行流程中取指、解码的时候运算单元是空闲的，而且取指和解码如果没有命中高速缓存还需要从主存取。CPU 有指令流水线(拆分成更多步骤)， 分支预测，乱序执行等优化速度的手段</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/format,png.jpeg" alt="img" loading="lazy"></figure>
<p>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈（面向 native 方法），PC寄存器（存放线程执行位置），当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p>
<h4 id="进程上下文"><strong>进程上下文</strong></h4>
<p>程序为一段可执行的指令集合，操作系统就会为程序分配 CPU ，内存等资源，而这个正在运行的程序就是进程，进程是操作系统对处理器中运行的程序的一种抽象。</p>
<p>而为进程分配的内存以及 CPU 资源就是这个进程的上下文，保存了当前执行的指令，以及变量值。进程的物理实体和支持进程运行的环境合称为上下文。而上下文切换就是将当前正在运行的进程换下，换一个新的进程到处理器运行，上下文切换可能来自操作系统调度，也有可能来自程序内部，例如读取IO的时候，会让用户代码和操作系统代码之间进行切换。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/format,png.png" alt="img" loading="lazy"></figure>
<h4 id="虚拟存储"><strong>虚拟存储</strong></h4>
<p>物理地址空间可以被多个进程共享，而这个映射关系将通过页表（ page table）进行维护。 标准页的尺寸一般为 4KB ，分页后，物理内存被分成若干个 4KB 的数据页，进程申请内存的时候，可以映射为多个 4KB 大小的物理内存，而应用程序读取数据的时候会以页为最小单位，当需要和硬盘发生交换swap的时候也是以页为单位。虚拟存储让每个进程以为自己独占整个内存空间，保护了各自进程不被其他进程破坏，另外，他把主存看成磁盘的一个缓存，主存中仅保存活动的程序段和数据段，当主存中不存在数据的时候发生缺页中断，然后从磁盘加载进来，当物理内存不足的时候会发生 swap 到磁盘。</p>
<blockquote>
<p>页表保存了虚拟地址和物理地址的映射，页表是一个数组，每个元素为一个页的映射关系，这个映射关系可能是和主存地址，也可能和磁盘，页表存储在主存，我们将存储在高速缓冲区 cache  中的页表称为快表 TLAB 。</p>
<p>页表用虚拟内存解决了物理内存不足，并构建了内存到磁盘的缓存。也用内存映射解决了读取磁盘文件上下文切换的开销。</p>
</blockquote>
<h4 id="内存映射"><strong>内存映射</strong></h4>
<p>传统的读取文件的流程为，先通过系统调用从磁盘读取数据，存入操作系统的内核缓冲区，然后在从内核缓冲区拷贝到用户空间。</p>
<p>而内存映射，是将磁盘文件直接映射到用户的虚拟存储空间中，通过页表维护虚拟地址到磁盘的映射。通过内存映射的方式读取文件的好处有，因为减少了从内核缓冲区到用户空间的拷贝，直接从磁盘读取数据到内存，减少了系统调用的开销，对用户而言，仿佛直接操作的磁盘上的文件，另外由于使用了虚拟存储，所以不需要连续的主存空间来存储数据。</p>
<p>在 Java 中，使用 MappedByteBuffer 来实现内存映射(unsafe)，这是一个堆外内存，在映射完之后，并没有立即占有物理内存，而是访问数据页的时候，先查页表，发现还没加载，发起缺页异常，然后在从磁盘将数据加载进内存。</p>
<h4 id="jvm-中对象的内存布局"><strong>JVM 中对象的内存布局</strong></h4>
<p>Java 中可以通过 Field.get(object) 的方式获取变量的值，即反射。原理是通过 UnSafe 类来实现，获取field在所在对象中的地址的偏移量 fieldoffset。通过属性相对对象起始地址的偏移量，来读取和写入属性的值。</p>
<p>Java 对象都有一个对象头（object header），由标记字段和类型指针所构成。标记字段内有哈希码、GC 信息以及锁信息等运行数据；类型指针则指向该对象的类。</p>
<p>Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。</p>
<blockquote>
<p>java对象哪怕没有任何字段也占16字节/12字节(头+指针 压缩前后)</p>
<p>内存对齐，会对字段进行重排序以避免内存浪费。字节码被加载之前难以精准分析出这个 Java 对象内存占用，只能通过递归父类的所有属性来预估对象大小，而真实占用的大小可以通过 Java agent 获取。</p>
<p>内存对齐的原因有二：对字段进行重排序以避免内存浪费；让字段只出现在同一个 CPU 的缓存行中</p>
</blockquote>
<h3 id="nptl和java的线程">NPTL和java的线程</h3>
<p>进程是资源管理的最小单位，而线程是 CPU 调度执行的最小单位，线程的出现是为了减少进程的上下文切换（线程的上下文切换比进程小很多），以及更好适配多核心 CPU 环境。在Linux中，线程是一个轻量级进程，只是优化了线程调度的开销。</p>
<p>目前 Linux上 的线程模型为 NPTL （ Native POSIX Thread Library），他使用一对一模式，兼容 POSIX 标准，没有使用管理线程，可以更好地在多核 CPU 上运行。</p>
<p>而在 JVM 中的线程和内核线程是一一对应的，线程的调度完全交给了内核，当调用Thread.run 的时候，就会通过系统调用 fork() 创建一个内核线程，这个方法会在用户态和内核态之间进行切换，性能没有在用户态实现线程高，当然由于直接使用内核线程，所以能够创建的最大线程数也受内核控制。</p>
<blockquote>
<p>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p>
</blockquote>
<h4 id="线程的状态"><strong>线程的状态</strong></h4>
<p>对进程而言，就三种状态，就绪，运行，阻塞，而在 JVM 中，阻塞有四种类型，我们可以通过 jstack 生成 dump 文件查看线程的状态。</p>
<ul>
<li>BLOCKED （on object monitor)  通过 synchronized(obj) 同步块获取锁的时候，等待其他线程释放对象锁，dump 文件会显示 waiting to lock &lt;0x00000000e1c9f108&gt;</li>
<li>TIMED WAITING (on object monitor) 和 WAITING (on object monitor) 在获取锁后，调用了 object.wait() 等待其他线程调用 object.notify()，两者区别是是否带超时时间</li>
<li>TIMED WAITING (sleeping) 程序调用了 thread.sleep()，这里如果 sleep(0) 不会进入阻塞状态，会直接从运行转换为就绪</li>
<li>TIMED WAITING (parking) 和 WAITING (parking) 程序调用了 Unsafe.park()，线程被挂起，等待某个条件发生，waiting on condition</li>
</ul>
<p>而在 POSIX 标准中，thread_block 接受一个参数 stat ，这个参数也有三种类型，TASK_BLOCKED， TASK_WAITING， TASK_HANGING，而调度器只会对线程状态为 READY 的线程执行调度，另外一点是线程的阻塞是线程自己操作的，相当于是线程主动让出 CPU 时间片，所以等线程被唤醒后，他的剩余时间片不会变，该线程只能在剩下的时间片运行，如果该时间片到期后线程还没结束，该线程状态会由 RUNNING 转换为 READY ，等待调度器的下一次调度。</p>
<p>而Java 并发包，核心都在 AQS 里，底层是通过 UnSafe类的 cas 方法，以及 park 方法实现。</p>
<h4 id="线程的同步"><strong>线程的同步</strong></h4>
<p>线程同步出现的根本原因是访问公共资源需要多个操作，而这多个操作的执行过程不具备原子性，被任务调度器分开了，而其他线程会破坏共享资源，所以需要在临界区做线程的同步。临界区，是指多个任务访问共享资源如内存或文件时候的指令，是指令并不是受访问的资源。</p>
<p>POSIX 定义了五种同步对象，互斥锁，条件变量，自旋锁，读写锁，信号量，这些对象在 JVM 中也都有对应的实现，并没有全部使用 POSIX 定义的 api，通过 Java 实现灵活性更高，也避免了调用native方法的性能开销，当然底层最终都依赖于 pthread 的 互斥锁 mutex 来实现，这是一个系统调用，开销很大，所以 JVM 对锁做了自动升降级 。</p>
<p>如当声明 synchronized 的代码块时，编译而成的字节码会包含一个 monitorenter 和 多个 monitorexit （多个退出路径，正常和异常情况），当执行 monitorenter 的时候会检查目标锁对象的计数器是否为0，如果为0则将锁对象的持有线程设置为自己，然后计数器加1，获取到锁，如果不为0则检查锁对象的持有线程是不是自己，如果是自己就将计数器加1获取锁，如果不是则阻塞等待，退出的时候计数器减1，当减为0的时候清楚锁对象的持有线程标记，可以看出 synchronized 是支持可重入的。</p>
<blockquote>
<p>可重入的定义</p>
<ul>
<li>简单定义:&quot;可以正确重复使用&quot;：1，可以重复使用；2，并能正确使用。意味着在多次执行的时候能得到正确的值，并不受其他调用的影响。</li>
<li>官方定义：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</li>
</ul>
<p>可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>
<p><strong>可重入锁</strong>也叫递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，同一线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock 和 synchronized 就是典型的可重入锁！</p>
</blockquote>
<p>线程的阻塞是一个系统调用，开销大，所以 JVM 设计了自适应自旋锁，就是当没有获取到锁的时候， CPU 回进入自旋状态等待其他线程释放锁，自旋的时间主要看上次等待多长时间获取的锁，自旋会导致 CPU 空跑，和不公平的锁机制，因为该线程自旋获取到锁，而其他正在阻塞的线程还在等待。</p>
<p>除了自旋锁， JVM 还通过 CAS 实现了轻量级锁和偏向锁来分别针对多个线程在不同时间访问锁和锁仅会被一个线程使用的情况。这两种锁相当于并没有调用底层的信号量实现，只是自己在用户空间维护了锁的持有关系，所以更高效。</p>
<blockquote>
<p>通过信号量来控制线程A释放了锁例如调用了 wait()，而线程B就可以获取锁，这个只有内核才能实现，后面两种由于场景里没有竞争所以也就不需要通过底层信号量控制</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/format,png-20210713144506877.png" alt="img" loading="lazy"></figure>
<ol>
<li>如果线程A进入 monitorenter 会将自己放入该 objectmonitor 的 entryset 队列，然后阻塞；</li>
<li>如果当前持有线程B调用了 wait 方法，将会释放锁，然后将自己封装成 objectwaiter 放入 objectmonitor 的 waitset 队列，这时候 entryset 队列里的某个X线程(A或其他)将会竞争到锁，并进入 active 状态；</li>
<li>如果这个线程X调用了 notify 方法，将会把 waitset 的第一个 objectwaiter  Y拿出来放入 entryset （这个时候根据策略可能会先自旋），当调用 notify 的那个线程X执行 moniterexit 释放锁的时候， entryset 里的线程(可能是Y)就开始竞争锁后进入 active 状态。</li>
</ol>
<blockquote>
<p>持有锁的线程wait会进入waitSet</p>
<p>从waitSet中转移到EntrySet有一下几种</p>
<p>有其他线程以notify方法唤醒该线程<br>
有其它线程以notifyAll方法唤醒该线程<br>
有其它线程以interrupt方法唤醒该线程<br>
wait方法时间到期(时间到了)</p>
</blockquote>
<p>为了让应用程序免于数据竞争的干扰， Java  内存模型中定义了 happen-before 来描述两个操作的内存可见性，也就是 X 操作 happen-before 操作 Y ， 那么 X 操作结果 对 Y 可见。JVM 中针对 volatile 以及 锁 的实现有 happen-before 规则， JVM 底层通过插入内存屏障来限制编译器的重排序。</p>
<p>以 volatile 为例，内存屏障将不允许 在 volatile 字段写操作之前的语句被重排序到写操作后面 ， 也不允许读取 volatile 字段之后的语句被重排序带读取语句之前。插入内存屏障的指令，会根据指令类型不同有不同的效果，例如在 monitorexit 释放锁后会强制刷新缓存，而 volatile 对应的内存屏障会在每次写入后强制刷新到主存，并且由于 volatile 字段的特性，编译器无法将其分配到寄存器，所以每次都是从主存读取，所以 volatile 适用于读多写少得场景，最好只有个线程写多个线程读，如果频繁写入导致不停刷新缓存会影响性能。</p>
<p><strong>Java 中如何实现定时任务</strong></p>
<p>Java 中实现定时任务，有两种方式，一种通过 <strong>timer</strong> 类， 另外一种是 JUC 中的 <strong>ScheduledExecutorService</strong> 。JVM 实现定时任务不能一直轮询时间，而是通过线程阻塞，等到时间到了在来唤醒线程。</p>
<ul>
<li>object.wait(long millisecond)  参数是毫秒，必须大于等于 0 ，如果等于 0 ，就一直阻塞直到其他线程来唤醒 ，timer 类就是通过 wait() 方法来实现。object.wait(long timeout,int nanos) 可以支持纳秒级的超时时间。</li>
<li>Thread.sleep(long millisecond) 若参数为 0 ，表示释放 CPU 给更高优先级的线程。也提供了一个可以支持纳秒级的方法实现sleep(long millis， int nanos)。</li>
<li>LockSupport.park(long nans) ： Condition.await()调用的该方法， ScheduledExecutorService 用的 condition.await() 来实现阻塞一定的超时时间，其他带超时参数的方法也都通过他来实现，目前大多定时器都是通过这个方法来实现的，该方法也提供了一个布尔值来确定时间的精度。</li>
<li>System.currentTimeMillis() 以及 System.nanoTime() 这两种方式都依赖于底层操作系统，前者是毫秒级，而后者是纳秒级别。</li>
</ul>
<p>定时器的底层在现代PC机中有三种硬件时钟的实现，他们都是通过晶体振动产生的方波信号输入来完成时钟信号同步的。</p>
<ul>
<li>实时时钟 RTC ，用于长时间存放系统时间的设备，即使关机也可以依靠主板中的电池继续计时。Linux 启动的时候会从 RTC 中读取时间和日期作为初始值，之后在运行期间通过其他计时器去维护系统时间。</li>
<li>可编程间隔定时器 PIT ，该计数器会有一个初始值，每过一个时钟周期，该初始值会减1，当该初始值被减到0时，就通过导线向 CPU 发送一个时钟中断， CPU 就可以执行对应的中断程序，也就是回调对应的任务</li>
<li>时间戳计数器 TSC ， 所有的 Intel8086 CPU 中都包含一个时间戳计数器对应的寄存器，该寄存器的值会在每次 CPU 收到一个时钟周期的中断信号后就会加 1 。他比 PIT 精度高，但是不能编程，只能读取。</li>
</ul>
<blockquote>
<p>时钟周期：硬件计时器在多长时间内产生时钟脉冲，而时钟周期频率为1秒内产生时钟脉冲的个数。</p>
<p>时钟滴答/中断：当PIT中的初始值减到0的时候，就会产生一次时钟中断，这个初始值由编程的时候指定。</p>
</blockquote>
<p>Linux启动的时候，先通过 RTC 获取初始时间，之后内核通过 PIT 中的定时器的时钟滴答来维护日期，并且会定时将该日期写入 RTC。而应用程序的定时器主要是通过设置 PIT 的初始值设置的，当初始值减到0的时候，就表示要执行回调函数了。</p>
<p>定时任务按照时间排序，越靠前待执行的任务放在前面，第一个任务到了再设置第二个任务相对当前的时间，而时间的精度问题，无法在软件层面做的完全精准，更大的依赖是硬件的时钟周期频率，目前 TSC 可以提高更高的精度。</p>
<p>Java 中的超时时间，是通过可编程间隔定时器PIT设置一个初始值然后等待中断信号实现的，精度上受硬件时钟周期的影响，一般为毫秒级别(毕竟1纳秒光速也只有3米)；而获取当前时间 System.currentTimeMillis() ，是毫秒级精度，读取的是 Linux 内核维护的日期RTC；而 System.nanoTime() 会优先使用 TSC ，性能稍微低一点，但他是纳秒级，Random 类为了防止冲突就用nanoTime生成种子。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编译原理]]></title>
        <id>https://Joshua-Chang.github.io/post/bian-yi-yuan-li/</id>
        <link href="https://Joshua-Chang.github.io/post/bian-yi-yuan-li/">
        </link>
        <updated>2021-07-02T04:31:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="编译器的前端技术">编译器的前端技术</h1>
<p>“前端”指的是编译器对程序代码的分析和理解过程。它通常只跟语言的语法有关，跟目标机器无关。而与之对应的“后端”则是生成目标代码的过程，跟目标机器有关。</p>
<img src="https://static001.geekbang.org/resource/image/06/93/06b80f8484f4d88c6510213eb27f2093.jpg" />
<p>编译器的“前端”技术分为<strong>词法分析、语法分析</strong>和<strong>语义分析</strong>三个部分。而它主要涉及自动机和形式语言方面的基础的计算理论。</p>
<h2 id="词法分析">词法分析</h2>
<p>编译器的第一项工作叫做词法分析。程序由一个个的“词法记号”( Token)组成的。</p>
<p>读一片段代码时，识别出 if、else、int 这样的关键字，main、printf、age 这样的标识符，+、-、= 这样的操作符号，还有花括号、圆括号、分号这样的符号，以及数字字面量、字符串字面量等。这些都是 Token。</p>
<p>不同的Token在代码里可以是连在一起的，可以通过制定一些规则来区分每个不同的 Token，即词法分析器。</p>
<blockquote>
<ul>
<li>**识别 age 这样的标识符。**它以字母开头，后面可以是字母或数字，直到遇到第一个既不是字母又不是数字的字符时结束。</li>
<li><strong>识别 &gt;= 这样的操作符。</strong> 当扫描到一个 &gt; 字符的时候，就要注意，它可能是一个 GT（Greater Than，大于）操作符。但由于 GE（Greater Equal，大于等于）也是以 &gt; 开头的，所以再往下再看一位，如果是 =，那么这个 Token 就是 GE，否则就是 GT。</li>
<li>**识别 45 这样的数字字面量。**当扫描到一个数字字符的时候，就开始把它看做数字，直到遇到非数字的字符。</li>
</ul>
</blockquote>
<p><strong>词法分析器</strong>有的是手写实现的（GNU 的 C 语言编译器），有的使用词法分析器的生成工具来生成（Lex或其 GNU 版本，Flex）。这些生成工具是基于一些规则来工作的，这些规则用“正则文法”表达，符合正则文法的表达式称为“正则表达式”。生成工具可以读入正则表达式，生成一种叫“有限自动机”的算法，来完成具体的词法分析工作。</p>
<p>有限自动机是有限个状态的自动机器。词法分析器也是一样，它分析整个程序的字符串，当遇到不同的字符时，会驱使它迁移到不同的状态。</p>
<blockquote>
<p>例如，词法分析程序在扫描 age 的时候，处于“标识符”状态，等它遇到一个 &gt; 符号，就切换到“比较操作符”的状态。词法分析过程，就是这样一个个状态迁移的过程。</p>
</blockquote>
<h2 id="语法分析">语法分析</h2>
<p>编译器下一个阶段的工作是语法分析。词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的。</p>
<p>自然语言为例有“主、谓、宾”，宾语又可以拆分成定语。</p>
<p>程序也有定义良好的语法结构，它的语法分析过程，就是构造这么一棵树。一个程序就是一棵树，这棵树叫做<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。计算机程序是层层嵌套的树状结构。</p>
<p>如果再把循环语句、判断语句、赋值语句等节点加到 AST 上，并解释执行它，那么你实际上就实现了一个脚本语言。而执行脚本语言的过程，就是遍历 AST 的过程。</p>
<img src="https://static001.geekbang.org/resource/image/cb/16/cbf2b953cb84ef30b154470804262c16.jpg" style="zoom:74%;" />
<p>构造AST的算法就是递归下降算法。</p>
<p>语法分析器有比如 Yacc（或 GNU 的版本，Bison）、Antlr、JavaCC 等工具，还能找到很多开源的语法规则文件改造。对日志文件每行日志的解析、解析XML、JSON 格式的各种配置文件、模型定义文件的过程，其实本质也是语法分析过程。</p>
<h2 id="语义分析">语义分析</h2>
<p>语义分析就是要让计算机理解我们的真实意图，把一些模棱两可的地方消除掉。</p>
<p>计算机语言的语义一般可以表达为一些规则，语义分析就是要检查是否符合这些规则</p>
<blockquote>
<p>比如：</p>
<ul>
<li>某个表达式的计算结果是什么数据类型？如果有数据类型不匹配的情况，是否要做自动转换？</li>
<li>如果在一个代码块的内部和外部有相同名称的变量，我在执行的时候到底用哪个？ 就像“我喜欢又聪明又勇敢的你”中的“你”，到底指的是谁，需要明确。</li>
<li>在同一个作用域内，不允许有两个名称相同的变量，这是唯一性检查。你不能刚声明一个变量 a，紧接着又声明同样名称的一个变量 a，这就不允许了。</li>
</ul>
</blockquote>
<p>语义分析工作的某些成果，会作为属性标注在抽象语法树上，比如在 age 这个标识符节点和 45 这个字面量节点上，都会标识它的数据类型是 int 型的。</p>
<blockquote>
<p>在这个树上还可以标记很多属性，有些属性是在之前的两个阶段就被标注上了，比如所处的源代码行号，这一行的第几个字符。这样，在编译程序报错的时候，就可以比较清楚地了解出错的位置。</p>
</blockquote>
<p>做完这些属性标注以后，编译器再依据这些信息生成目标代码。</p>
<h2 id="课程小结">课程小结</h2>
<ul>
<li>词法分析是把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现。</li>
<li>语法分析是把程序的结构识别出来，并形成一棵便于由计算机处理的抽象语法树AST。可以用递归下降的算法来实现。</li>
<li>语义分析是消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。</li>
</ul>
<h1 id="02-正则文法和有限自动机纯手工打造词法分析器">02 | 正则文法和有限自动机：纯手工打造词法分析器</h1>
<p>解析 age &gt;= 45有限自动机如图：</p>
<p>**1. 初始状态：**刚开始启动词法分析的时候，程序所处的状态。</p>
<p>**2. 标识符状态：**在初始状态时，当第一个字符是字母的时候，迁移到状态 2。当后续字符是字母和数字时，保留在状态 2。如果不是，就离开状态 2，写下该 Token，回到初始状态。</p>
<p>**3. 大于操作符（GT）：**在初始状态时，当第一个字符是 &gt; 时，进入这个状态。它是比较操作符的一种情况。</p>
<p>**4. 大于等于操作符（GE）：**如果状态 3 的下一个字符是 =，就进入状态 4，变成 &gt;=。它也是比较操作符的一种情况。</p>
<p>**5. 数字字面量：**在初始状态时，下一个字符是数字，进入这个状态。如果后续仍是数字，就保持在状态 5</p>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/15/35/15da400d09ede2ce6ac60fa6d5342835.jpg" style="zoom:67%;" /></th>
<th><img src="https://static001.geekbang.org/resource/image/f6/17/f6601b74204140836bd409137924be17.jpg" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>双线的意思是这个状态已经是一个合法的 Token 了，单线的意思是这个状态还是临时状态。</p>
</blockquote>
<p>这 4 种 Token 用正则表达式表达：</p>
<pre><code>Id :        [a-zA-Z_] ([a-zA-Z_] | [0-9])*
IntLiteral: [0-9]+
GT :        '&gt;'
GE :        '&gt;='
</code></pre>
<p>解析 int age = 40，处理标识符和关键字规则的冲突</p>
<p>int 这个字符串，既符合标识符的规则，又符合 int 这个关键字的规则。</p>
<ol>
<li>关键字是语言设计中作为语法要素的词汇，例如表示数据类型的 int、char，表示程序结构的 while、if，表述特殊数据取值的 null、NAN 等。关键字比标识符的规则优先级高，普通的标识符是不允许跟这些关键字重名的。</li>
<li>保留字在当前的语言设计中还没用到，但是保留下来，因为将来会用到。</li>
</ol>
<p>我们命名自己的变量、类名称，不可以用到跟关键字和保留字相同的字符串。<strong>那么我们在词法分析器中，如何把关键字和保留字跟标识符区分开呢？</strong></p>
<p>在识别普通的标识符之前，你先看看它是关键字还是保留字就可以了。具体做法是：</p>
<blockquote>
<p>当第一个字符是 i 的时候，我们让它进入一个特殊的状态。接下来，如果它遇到 n 和 t，就进入状态 4。但这还没有结束，如果后续的字符还有其他的字母和数字，它又变成了普通的标识符。比如，我们可以声明一个 intA（int 和 A 是连着的）这样的变量，而不会跟 int 关键字冲突。<img src="https://static001.geekbang.org/resource/image/52/b4/52afab1d7c30b04c91b2b0a018dcc9b4.jpg" alt="" loading="lazy"></p>
</blockquote>
<h1 id="编译器后端">编译器后端</h1>
<p>编译器后端的最终结果，就是<strong>生成目标代码</strong>。如果目标是在计算机上直接运行，就像 C 语言程序那样，那这个目标代码指的是汇编代码。而如果运行目标是 Java 虚拟机，那这个目标代码就是指 JVM 的字节码。</p>
<p>为了降低后端工作量，提高软件复用度，就需要引入<strong>中间代码（Intermediate Representation，IR）的机制</strong>，它是独立于具体硬件的一种代码格式。各个语言的前端可以先翻译成 IR，然后再从 IR 翻译成不同硬件架构的汇编代码。</p>
<p>生成正确的、能够执行的代码比较简单，可这样的代码执行效率很低，因为直接翻译生成的代码往往不够简洁，比如会生成大量的临时变量，指令数量也较多。优化工作又分为**“独立于机器的优化”和“依赖于机器的优化”**两种。</p>
<p>独立于机器的优化，是基于 IR 进行的。它可以通过对代码的分析，用更加高效的代码代替原来的代码。IR 的作用：基于 IR 对接不同语言的前端，也能对接不同的硬件架构，还能做很多的优化。</p>
<p>**依赖于机器的优化，则是依赖于硬件的特征。**现代的计算机硬件设计了很多特性，以便提供更高的处理能力，比如并行计算能力，多层次内存结构（使用多个级别的高速缓存）等等。</p>
<p><strong>编译期后端从前端生成中间代码，然后基于中间代码生成针对不同平台的目标代码；最后，需要对代码做各种优化工作，包括独立于机器的优化和依赖于机器的优化。</strong></p>
<h2 id="程序运行的环境">程序运行的环境</h2>
<p>程序运行的过程中，主要是跟两个硬件（CPU 和内存）以及一个软件（操作系统）打交道。</p>
<p>程序在使用内存的时候，操作系统会把程序使用的逻辑地址映射到真实的物理内存地址。有的物理内存区域会映射进多个进程的地址空间。对于不太常用的内存数据，操作系统会写到磁盘上，以便腾出更多可用的物理内存。</p>
<p>大多数语言还是会采用一些通用的内存管理模式。以 C 语言为例：</p>
<p><strong>代码区（也叫文本段）存放编译完成以后的机器码。</strong></p>
<p>**静态数据区保存程序中全局的变量和常量。**Data 段中的变量是在编译期就初始化好的，直接从程序装在进内存。BSS 段中是那些没有声明初始化值的变量，都会被初始化成缺省值 0。</p>
<p><strong>堆适合管理生存期较长的一些数据，这些数据在退出作用域以后也不会消失。</strong></p>
<p><strong>而栈适合保存生存期比较短的数据，比如函数和方法里的本地变量。<strong>在进入某个</strong>作用域</strong>的时候申请内存，退出这个作用域的时候就可以释放掉。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/45/6a/452137a61a7b051ffceb40ae45199f6a.jpg" alt="c" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/3b/f5/3bd535433e4aad9140bc0e114498def5.jpg" alt="调用" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>每次一次函数调用活动都产生活动记录，栈帧是活动记录的实现方式。</p>
<h2 id="汇编">汇编</h2>
<p>如 C / Go 这种静态编译型语言，编译器后端的任务就是生成汇编代码。然后再由汇编器生成机器码（即目标文件），最后再使用链接器就能生成可执行文件或库文件了。</p>
<p>像 JavaScript/Java 这样的解释执行的语言，也要在运行时利用类似的机制生成机器码，以便调高执行的速度。Java 的字节码，在运行时通常也会通过 JIT 机制编译成机器码。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/fe/76/feadbf7a473c420d0693c249b48e0e76.jpg" alt="汇编" loading="lazy"></figure>
<p>汇编器可以把每一个汇编文件都编译生成一个二进制的目标文件，或者叫做一个模块。而链接器则把这些模块组装成一个整体。</p>
<p>生成汇编代码以后，编译器的任务完成了。后面是由汇编器和链接器完成的工作。但我们也可以把整个过程都看做编译过程。</p>
<p>每个操作系统可执行程序的格式要求是不一样。在 Linux 下，目标文件、共享对象文件、二进制文件，都是采用 ELF 格式。在 ELF 格式中，同内存中的布局一样，代码和数据也是分开的。程序的代码部分，可以在多个进程中共享，不需要在内存里放多份。</p>
<h2 id="中间代码">中间代码</h2>
<p>IR 的意思是中间表达方式，它在高级语言和汇编语言的中间。与高级语言相比，IR 丢弃了大部分高级语言的语法特征和语义特征，比如循环语句、if 语句、作用域、面向对象等等，它更像高层次的汇编语言；而相比真正的汇编语言，它又不会有那么多琐碎的、与具体硬件相关的指令/寄存器操作细节。</p>
<p>IR 有很多种类（AST 也是一种 IR。字节码也是），每种 IR 都有不同的特点和用途，有的编译器，甚至要用到几种不同的 IR。IR并不局限与编译器前端或后端。</p>
<p>常见的 IR 的格式，它叫做<strong>三地址代码（Three Address Code, TAC）</strong>。每条三地址代码最多有三个地址，其中两个是源地址（比如第一行代码的 y 和 z），一个是目的地址（也就是 x），每条代码最多有一个操作（op）。</p>
<pre><code class="language-java">x := y op z   // 二元操作
x := op y     // 一元操作
</code></pre>
<blockquote>
<p>另外几种 IR 的格式:</p>
<ul>
<li>四元式。它是与三地址代码等价的另一种表达方式，格式是：（OP，arg1，arg2，result）所以，“a := b + c” 就等价于（+，b，c，a）。</li>
<li>逆波兰表达式。它把操作符放到后面，所以也叫做后缀表达式。“b + c”对应的逆波兰表达式是“b c +”；而“a = b + c”对应的逆波兰表达式是“a b c + =”。</li>
</ul>
</blockquote>
<p>**LLVM 汇编码（LLVM Assembly），是 LLVM 的 IR。**即 LLVM 语言，可以把用 LLVM 汇编码书写的一个程序文件叫做 LLVM 程序。</p>
<p><strong>LLVM 汇编码是采用静态单赋值代码形式的。</strong>（Static Single Assignment, <strong>SSA</strong>）即在三地址代码上基础上，一个变量只能被赋值一次。**LLVM IR 比起三地址代码，有更多的细节信息。**比如整型变量的字长、内存对齐方式等等，所以使用 LLVM IR 能够更准确地翻译成汇编码。</p>
<blockquote>
<p>每个变量很确定地只会被定义一次，然后可以多次使用。这种特点使得基于 SSA 更容易做数据流分析，而数据流分析又是很多代码优化技术的基础，所以，几乎所有语言的编译器、解释器或虚拟机中都使用了 SSA，因为有利于做代码优化。</p>
</blockquote>
<p>IR 是我们后续做代码优化、汇编代码生成的基础</p>
<ol>
<li>三地址代码是很常见的一种 IR，包含一个目的地址、一个操作符和至多两个源地址。它等价于四元式。</li>
<li>LLVM IR 的第一个特点是静态单赋值（SSA），也就是每个变量（地址）最多被赋值一次，它这种特性有利于运行代码优化算法；第二个特点是带有比较多的细节，方便我们做优化和生成高质量的汇编代码。</li>
</ol>
<h2 id="编译器后端框架">编译器后端框架</h2>
<p>相比前端的编译器工具，如 Lex（Flex）、Yacc（Bison）和 Antlr 等，对于后端工具有LLVM 和 GCC 。</p>
<blockquote>
<p>苹果系统上的 C 语言、C++、Objective-C 的编译器 Clang 就是基于 LLVM 的，最新的 Swift 编程语言也是基于 LLVM，支撑了无数的移动应用和桌面应用。Kotlin，也支持基于 LLVM 编译成本地代码。LLVM 有良好的模块化设计和接口。LLVM 同时支持 JIT（即时编译）和 AOT（提前编译）两种模式。</p>
<p>GCC（GNU Compiler Collection，GNU 编译器套件）。它支持了 GNU Linux 上的很多语言，例如 C、C++、Objective-C、Fortran、Go 语言和 Java 语言等。</p>
</blockquote>
<p>LLVM 能够支持多种语言的前端、多种后端 CPU 架构。在 LLVM 内部，使用类型化的和 SSA 特点的 IR 进行各种分析、优化和转换：</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/07/1c/079aa0c78325b3a4420d78523b5aa51c.png" alt="llvm" loading="lazy"></figure>
<p>LLVM 项目包含了很多组成部分：</p>
<ul>
<li>LLVM 核心（core）包括：优化和分析工具、还包括了为各种 CPU 生成目标代码的功能；这些库采用的是 LLVM IR，一个良好定义的中间语言。</li>
<li>Clang 前端（是基于 LLVM 的 C、C++、Objective-C 编译器）。</li>
<li>LLDB（一个调试工具）。</li>
<li>LLVM 版本的 C++ 标准类库。</li>
<li>其他一些子项目。</li>
</ul>
<p>LLVM 本身是用 C++ 开发的，所以最好采用 C++ 调用它的功能。</p>
<p>**LLVM 的 IR 有两种格式。**它的文本格式便于程序员阅读一般以.ll 结尾。字节码（bitcode）格式便于机器即时编译和执行以.bc 结尾。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/74/a7/74be02bbb36cf8d19e6b324b7d2373a7.png" alt="" loading="lazy"></figure>
<p>使用 LLVM 从源代码到生成可执行文件有两条可能的路径：</p>
<ul>
<li>第一条路径，是把每个源文件分别编译成字节码文件，然后再编译成目标文件，最后链接成可执行文件。</li>
<li>第二条路径，是先把编译好的字节码文件链接在一起，形成一个更大的字节码文件，然后对这个字节码文件进行进一步的优化，之后再生成目标文件和可执行文件。</li>
</ul>
<p>LLVM 用一套对象模型在内存中表示 IR，包括模块、函数、基本块和指令，你可以通过 API 来生成这些对象。这些对象一旦生成，就可以编译和执行。</p>
<p>对于 if 语句和循环语句，需要生成多个基本块，并通过跳转指令形成正确的控制流图（CFG）。当存在多个前序节点可能改变某个变量的值的时候，使用 phi 指令来确定正确的值。</p>
<p>存储在内存中的本地变量，可以多次赋值。</p>
<p>LLVM 能够把外部函数和 IR 模型中的函数等价对待。</p>
<h2 id="目标代码的生成和优化">目标代码的生成和优化</h2>
<p>指令选择、寄存器分配、指令重排序</p>
<ol>
<li>指令的选择。同样一个功能，可以用不同的指令或指令序列来完成，而我们需要选择比较优化的方案。</li>
<li>寄存器分配。每款 CPU 的寄存器都是有限的，我们要有效地利用它。</li>
<li>指令重排序。计算执行的次序会影响所生成的代码的效率。在不影响运行结果的情况下，我们要通过代码重排序获得更高的效率。</li>
</ol>
<p>llvm后端的处理步骤</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/79/fd/79bde8c10be1eaea92a70890dbea56fd.jpg" alt="优化" loading="lazy"></figure>
<p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理。</p>
<p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。</p>
<p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。</p>
<p>它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。</p>
<p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重学操作系统]]></title>
        <id>https://Joshua-Chang.github.io/post/chong-xue-cao-zuo-xi-tong/</id>
        <link href="https://Joshua-Chang.github.io/post/chong-xue-cao-zuo-xi-tong/">
        </link>
        <updated>2021-06-20T10:26:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机组成原理">计算机组成原理</h1>
<p><strong>希尔伯特问题</strong>中的<strong>公理化体系问题</strong>（这个世界可以建立一套完善的公理体系，由少数几个公理出发，推导出所有的定理和推论）和<strong>哥德尔不完备性定理</strong>（即便在完善的公理体系中仍然可以找到不能被证明也不能被证伪的命题。）哥德尔的不完备性定理，让大家看到了世界上还有大量不可计算的问题。哪些问题可以被计算，哪些不可以被计算，这就是图灵的可计算理论。比如不可计算的停机问题。</p>
<p>我们今天有能力解决的问题，统称为多项式时间（ Polynomial time）问题记作P问题，反之问题如果不能在多项式时间内找到答案，我们记为 NP 问题，有一部分 NP 问题可以被转化为 P 问题。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/Ciqc1F9YoMSAa9_WAADEZsnCSoU226.png" alt="4.png" style="zoom:50%;" /><img src="https://s0.lgstatic.com/i/image/M00/4E/A2/CgqCHl9e5VaANB2BAAEVncqxxwI213.png" alt="1.png" style="zoom:50%;" /></p>
<p><strong>内存</strong></p>
<p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位即bit。最小的存储单位字节为8 位即 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号然后自增排列。</p>
<p>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p>
<p><strong>CPU</strong></p>
<p>冯诺依曼模型中 CPU 负责控制和计算。</p>
<p>32和64位指的是CPU的位宽，即一次可运算的位(bit)数。32位(4 byte)/64位(8 byte)</p>
<p>线路位宽：一个 bit，低电压是 0，高电压是 1，1 条地址总线操作 2 个内存地址。32 位宽的 CPU最多只有 32 位的寄存器，对应32条总线，最多操作 23^2 个内存地址，也就是 4G 内存地址。</p>
<p>计算层面的话，64位CPU在计算大数据的时候比32位更高效，但是这种场景不多。</p>
<p>通信层面，64位可以操作更大的内存，以及和内存之间进行更高速的通信，因为支持的地址总线更大。</p>
<p><strong>控制单元和逻辑运算单元</strong></p>
<p>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。</p>
<p><strong>寄存器</strong></p>
<p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p>
<ol>
<li>
<p>寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是<strong>通用寄存器。</strong></p>
</li>
<li>
<p>还有一部分寄存器有特殊的用途，叫作<strong>特殊寄存器</strong>。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。</p>
</li>
<li>
<p>下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作<strong>指令寄存器</strong>。指令被执行完成之前，指令都存储在这里。</p>
</li>
</ol>
<p><strong>总线</strong></p>
<p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。</p>
<p><strong>地址总线</strong>，专门用来指定 CPU 将要操作的内存地址。</p>
<p>**数据总线，**用来读写内存中的数据。</p>
<p>当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</p>
<p><strong>控制总线</strong>，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。</p>
<p><strong>程序的执行过程</strong></p>
<p>所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。</p>
<img src="https://s0.lgstatic.com/i/image/M00/4E/C8/Ciqc1F9fGs2AEfeRAADnPPOm_gU294.png" alt="图片1 (1).png" style="zoom:50%;" />
<p>冯诺依曼模型中：</p>
<p><strong>处理器单元</strong>（Processing Unit）。用来完成各种算术和逻辑运算。由<strong>算术逻辑单元</strong>（Arithmetic Logic Unit，ALU）和<strong>处理器寄存器</strong>（Processor Register）组成。</p>
<p><strong>控制器单元</strong>（Control Unit/CU）用来控制程序的流程，通常就是不同条件下的分支和跳转。由<strong>指令寄存器（Instruction Reigster）<strong>和</strong>程序计数器</strong>（Program Counter PC）组成。</p>
<ol>
<li>
<p>CPU 读取 PC 指针指向的指令，将它从存储器导入指令寄存器。<br>
CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。</p>
<p>CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。</p>
<p>CPU 收到内存传来的数据后，将这个数据存入指令寄存器。</p>
</li>
<li>
<p>CPU 分析指令寄存器中的指令，确定指令的类型和参数。计算类型的指令，交给逻辑运算单元计算；存储类型的指令，由控制单元执行。</p>
</li>
<li>
<p>PC 指针自增，并准备获取下一条指令。比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。</p>
</li>
</ol>
<p>构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。 CPU 内部有一个循环也叫CPU 的指令周期</p>
<img src="https://s0.lgstatic.com/i/image/M00/4E/DF/Ciqc1F9fMKiAZhMVAABIVEePzcA916.png" alt="image (1).png" style="zoom:33%;" />
<ol>
<li>
<p>首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。</p>
</li>
<li>
<p>CPU 对指令进行解码，我们将这个部分叫作 Decode。</p>
</li>
<li>
<p>CPU 执行指令，我们将这个部分叫作 Execution。</p>
</li>
<li>
<p>CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 Store。</p>
</li>
</ol>
<p>不同 CPU 的指令和寄存器名称都不一样，但比如 PC 指针、指令寄存器等通用。指令的执行速度为时钟周期，在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。在2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。</p>
<p>不同的机器助记符也不一样，汇编语言的指令也不同</p>
<p>for循环是通过标记,判断和跳转完成指令操作。if-else 是通过判断和跳转完成，需要最多n-1次判断。相对于if-else的自上而下的判断，switch 则更多是数学计算。</p>
<p><strong>函数</strong>的执行过程，调用前先把返回值(占位)和返回地址(调用前 PC 指针位置)提前压栈，然后载压入参数。</p>
<blockquote>
<p>调用函数其实就是跳转到函数体对应的指令所在的位置，因此函数名可以用一个标签，调用时，就用 <code>jump</code> 指令跟这个标签。</p>
</blockquote>
<p><strong>class</strong>分为两个部分属性和函数。构造函数是为class内的属性和方法分配内存地址，构造函数执行时扫描类型定义中所有的属性和方法，是属性则分配内存地址;（ 遇到方法时根据不同语言基于虚函数表、基于闭包、基于哈希表等的实现可能并不像成员变量一样占用class堆或栈的内存空间，而是直接放在代码区。）</p>
<p>this是构造函数创建的一个指向 class 实例的地址，一旦调用构造函数初始化，this关键字则最先压入栈，这样任何函数都可以访问实例中的属性和函数。</p>
<p>联想到：</p>
<p>1：函数调用，需要分配栈空间，如果递归调用太深，不停的压栈，很可能出现栈内存溢出</p>
<p>2.java中，每个方法被执行的时候，Java虚拟机都会为方法调用所在线程同步创建一个栈帧用于存储局部变量表、操作数栈、方法出口信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><strong>存储器分级策略</strong></p>
<p>在时钟信号是 1GHz 的 CPU里，1G 代表 10 个亿，因此时钟信号的一个周期是 1/10 亿秒。而信号又是以光速传输的，光的速度是 3×10 的 8 次方米每秒，就是 3 亿米每秒。所以在一个周期内，光只能前进 30 厘米。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/51/2D/Ciqc1F9kgVGAD_IMAACXR1QKcDo779.png" alt="Lark20200918-174334.png"/></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/51/2C/Ciqc1F9kgMWAAU1JAABxd6qpCo0763.png" alt="Lark20200918-173926.png" style="zoom75%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>寄存器紧挨着 CPU 的控制单元和逻辑计算单元，每个寄存器存储4/8个byte（32/64位），一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。通常寄存机的访问速度一般要求在半个 CPU 时钟周期内完成读写。</p>
<ol>
<li>L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</li>
<li>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。也比 L1-Cache 更大，速度在 10~20 个 CPU 周期。</li>
<li>L3- 缓存也在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。也比 L2-Cache 更大，速度在 20~60 个 CPU 周期。（如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。）</li>
<li>内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。</li>
<li>SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。</li>
</ol>
<p>l1 cache，l2 cache, l3 cache ，内存，SSD/磁盘。从云到右，距离CPU逐渐变远，读取速度逐渐减低，空间逐渐增大。</p>
<p>缓存条目: 缓存可比内存小多了。 因此只能存内存中一小部分。 因此需要设计算法。缓存可以看作是双列结构，分别存储着内存地址和对应的值。想要快速的定位缓存条目可以通过取余(类似hash算法)快速定位缓存条目位置。</p>
<p>指令预读: 通过对于指令的预读，使得读取指令的速度跟的上指令的执行速度。减少指令从内存中的读取次数(更耗时)。</p>
<p>缓存的命中: l1的缓存命中率约为80%，l1 l2 l3缓存加在一块命中率高达95%。</p>
<p>缓存置换: 当缓存满了之后，再读取数据到缓存将置换掉之前的缓存。</p>
<h2 id="linux">Linux</h2>
<p>文件类型</p>
<ol>
<li>
<p>普通文件（比如一个文本文件）；</p>
</li>
<li>
<p>目录文件（目录也是一个特殊的文件，它用来存储文件清单，比如/也是一个文件）；/ 结尾</p>
</li>
<li>
<p>可执行文件；* 结尾</p>
</li>
<li>
<p>管道文件；| 结尾</p>
</li>
<li>
<p>Socket 文件（我们会在模块七网络部分讨论 Socket 文件）；= 结尾</p>
</li>
<li>
<p>软链接文件（相当于指向另一个文件所在路径的符号）；@ 结尾</p>
</li>
<li>
<p>硬链接文件（相当于指向另一个文件的指针）。</p>
</li>
</ol>
<p>echo是一个在命令行打印字符串的指令。</p>
<p>which指令查找一个执行文件所在的路径。</p>
<p>find指令全局查找文件。</p>
<p>touch修改一个文件的时间戳，如果文件不存在会触发创建文件。</p>
<p>cat查看完成的文件适合小型文件。more``less查看一个文件但是只读取用户看到的内容到内存，因此消耗资源较少，适合在服务器上看日志。</p>
<p>head``tail可以用来看文件的头和尾。tail -n 1000 最后的 1000 行日志。tail -f 文件名（follow）实时日志</p>
<p>grep指令搜索文件内容 g 就是 global，全局；re 就是 regular expression，正则表达式；p 就是 pattern，模式。</p>
<p>进程是应用的执行副本；而不要回答进程是操作系统分配资源的最小单位。前者是定义，后者是作用</p>
<p>ps指令。p 代表 processes，也就是进程；s 代表 snapshot，</p>
<p>ps -ef/ps aux（ BSD 风格）进程详情</p>
<p>top 进程实时</p>
<p><strong><code>bash</code>和终端的命令一般都是进程。</strong></p>
<p>每个进程拥有自己的标准输入流、标准输出流、标准错误流，这几个标准流其实都是文件。</p>
<p>标准输入流（用 0 表示）可以作为进程执行的上下文（进程执行可以从输入流中获取数据）。</p>
<p>标准输出流（用 1 表示）中写入的结果会被打印到屏幕上。</p>
<p>如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流（用 2 表示）中。</p>
<p>重定向：<code>ls -l &gt; out</code> 说&gt;符号叫作覆盖重定向，每次都会把目标文件覆盖；&gt;&gt;叫作追加重定向，会在目标文件中追加。<code>ls1 &gt; out</code> ls1指令是不存在，结果会输出到标准错误流中，即仍在屏幕上并不会存入out文件，<code>ls1 &amp;&gt; out</code>引用关系错误也到out中。&amp;符号用在命令结尾：也代表指令在后台执行，不会阻塞用户继续输入。</p>
<p>管道（Pipeline）在进程间传递数据，将一个进程的输出流定向到另一个进程的输入流。管道是一个连接一个进行计算，重定向是将一个文件的内容定向到另一个文件，这二者经常会结合使用。管道也是文件，有匿名管道（在文件系统中但没有路径）、命名管道（有自己的路径的文件），管道具有 FIFO（First In First Out）。</p>
<ol>
<li>排序<code>ls | sort -r</code>：把ls进程的输出给sort进程做输入。</li>
<li>去重<code>sort a.txt uniq</code>:uniq指令能够找到文件中相邻的重复行，然后去重。</li>
<li>筛选<code>find ./ | grep Spring|grep -v MyBatis</code>：递归列出当前目录下所有目录中的文件;匹配出包含Spring关键字的;在匹配出同时不包含MyBatis的（grep -v是匹配不包含）。</li>
<li>行数<code>wc -l</code>文件行数，<code>ls | wc -l</code>目录下文件数（ls输出的文件行数）</li>
<li>中间结果<code>find ./ -i &quot;*.java&quot; | tee JavaList | grep Spring</code> <code>tee</code> 本身不影响指令的执行，但是 tee 会把 find 指令的结果保存到 JavaList 文件中。</li>
<li><strong>xargs</strong>从标准数据流中构造并执行一行行的指令。xargs从输入流获取字符串，然后利用空白、换行符等切割字符串，在这些字符串的基础上构造指令，最后一行行执行这些指令。<code>ls | xargs -I GG echo &quot;mv GG to prefix_GG&quot;</code>先把最终命令echo输出检验一下，没问题然后执行<code>ls | xargs -I GG mv GG to prefix_GG</code>。<code>-I</code>为查找替换符用<code>GG</code>替代<code>ls</code>找到的结果。</li>
<li>以上都是匿名管道（拥有一个自己的inode，但不属于任何一个文件夹）。命名管道要用<code>mkfifo</code>指令创建。</li>
</ol>
<p><strong>编译安装/包管理器安装</strong></p>
<p>自动依赖管理器,解决了很多依赖,一次性的装好。</p>
<p>tar：t代表tape（磁带）；ar是 archive（档案）</p>
<p>-x代表 extract（提取）。-z代表gzip</p>
<p>-v代表 verbose（显示细节）</p>
<p>-f代表 file，这里指的是要操作文件，而不是磁带。 tar解压通常带有x和f，打包通常是c就是 create 的意思。</p>
<p>autoconf是bash（Bourne Shell）下的安装程序，支持对configure可执行文件的很多配置（<code>./configure --help</code>如prefix是安装目录），执行./configure进行安装。存在交叉编译因此要编译安装。</p>
<table>
<thead>
<tr>
<th></th>
<th>Debian (ubuntu)</th>
<th>Redhat(Redhat/Fedora/Centos)</th>
</tr>
</thead>
<tbody>
<tr>
<td>包管理器</td>
<td>dpkg（debian package）</td>
<td>rpm（redhatpackage manager）</td>
</tr>
<tr>
<td>自动依赖管理器</td>
<td>apt（Advanced Packaging Tools）</td>
<td>yum（Yellodog Updator，Modified）</td>
</tr>
</tbody>
</table>
<h2 id="操作系统">操作系统</h2>
<p><strong>内核</strong>是操作系统中应用连接硬件设备的桥梁，对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：</p>
<ol>
<li>
<p>管理进程、线程（决定哪个进程、线程使用 CPU）；</p>
</li>
<li>
<p>管理内存（决定内存用来做什么）；</p>
</li>
<li>
<p>连接硬件设备（为进程、和设备间提供通信能力）；</p>
</li>
<li>
<p>提供系统调用（接收进程发送来的系统调用）。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/61/89/CgqCHl-P5meAd3VdAAB1f7DWz-I273.png" alt="Lark20201021-153830.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/61/8A/CgqCHl-P5naAc5fsAABuTlhIQkw555.png" alt="Lark20201021-153825.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>内核权限非常高，它可以管理进程、可以直接访问所有的内存，因此确实需要和进程之间有一定的隔离。这个隔离用类似请求/响应的模型，非常符合常理。</p>
<h3 id="linux-的设计">Linux 的设计</h3>
<ol>
<li><strong>Multitask and SMP</strong>（Symmetric multiprocessing）<br>
MultiTask 指多任务，Linux 是一个多任务的操作系统。多任务就是多个任务可以同时执行，这里的“同时”并不是要求并发，而是在一段时间内可以执行多个任务。当然 Linux 支持并发。<br>
SMP 指对称多处理。其实是说 Linux 下每个处理器的地位是相等的，内存对多个处理器来说是共享的，每个处理器都可以访问完整的内存和硬件资源。 这个特点决定了在 Linux 上不会存在一个特定的处理器处理用户程序或者内核程序，它们可以被分配到任何一个处理器上执行。</li>
<li><strong>ELF</strong>（Executable and Linkable Format）可执行文件链接格式： ELF 可执行文件的存储格式把文件分成了一个个分段（Segment），每个段都有自己的作用。</li>
<li>Linux 是<strong>宏内核</strong>架构，即Linux 的内核是一个完整的可执行程序，且内核用最高权限来运行。宏内核的特点就是有很多程序会打包在内核中，比如，文件系统、驱动、内存管理等。（并不是每次安装驱动都需要重新编译内核，现在 Linux 也可以动态加载内核模块。）</li>
</ol>
<blockquote>
<p>Monolithic Kernel宏内核/Microkernel微内核</p>
<img src="https://s0.lgstatic.com/i/image/M00/61/AA/CgqCHl-QEKSAYD22AAFXRfj1rsA581.png" alt="Lark20201021-183457.png" style="zoom:50%;" />
<p>微内核，内核只保留最基本的能力。比如进程调度、虚拟内存、中断。多数应用，甚至包括驱动程序、文件系统，是在用户空间管理的。微内核体积更小、可移植性更强。</p>
<p>混合类型内核：架构像微内核，但是用宏内核的方式实现，就是在宏内核之内有抽象出了一个微内核。</p>
</blockquote>
<h3 id="window-设计">Window 设计</h3>
<p>目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，没有太大的结构化差异。Windows 同样支持 Multitask 和 SMP（对称多处理）。Windows 下可执行文件格式叫作 Portable Executable（PE），也就是可移植执行文件，扩展名通常是.exe、.dll、.sys等。Windows 的NT（New Technology）内核设计属于混合类型。 Windows 有很多独特的能力如Hyper-V 虚拟化技术。</p>
<p>比较：Linux 内核是一个开源的内核、它们支持的可执行文件格式不同、它们用到的虚拟化技术不同</p>
<p>Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：</p>
<p>内核空间（Kernal Space），这个空间只有内核程序可以访问；内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。</p>
<p>用户空间（User Space），这部分内存专门给应用程序使用。用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。</p>
<p>系统调用过程：</p>
<img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm3mAG_x-AAC5MxhOcCc621.png" alt="Lark20201023-165439.png" style="zoom:50%;" />
<p>内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。</p>
<ol>
<li>当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</li>
<li>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。</li>
<li>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</li>
</ol>
<p><strong>一个应用程序启动后会在内存中创建一个执行副本，这就是进程</strong>。Linux 的内核（是一个 Monolithic Kernel宏内核）可以看作一个进程。开机的时磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p>
<p>程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程</p>
<p>用户态线程：操作系统内核并不知道它的存在，它完全是在用户空间中创建。</p>
<p>优点：</p>
<ol>
<li>管理开销小：创建、销毁不需要系统调用。</li>
<li>切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，需要频繁进行用户态到内核态的切换。</p>
</li>
<li>
<p>线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</p>
</li>
<li>
<p>无法充分利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</p>
</li>
<li>
<p>操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</p>
</li>
</ol>
<p>内核态线程：执行在内核态，可以通过系统调用创造一个内核级线程。</p>
<p>优点：</p>
<ol>
<li>
<p>可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</p>
</li>
<li>
<p>操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>创建成本高：创建的时候需要系统调用，也就是切换到内核态。</p>
</li>
<li>
<p>扩展性差：由一个内核程序管理，不可能数量太多。</p>
</li>
<li>
<p>切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。</p>
</li>
</ol>
<p>**用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢。**因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。用户态线程和内核态线程之间的映射关系：</p>
<p>多对一（Many to One）：用户态进程中的多线程复用一个内核态线程。线程不可以并发。</p>
<p>一对一（One to One）：每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。允许所有线程并发执行，充分利用多核优势，（Windows NT 内核采取的就是这种模型）。但是因为线程较多，对内核调度的压力会明显增加。</p>
<p>多对多（Many To Many）：n 个用户态线程分配 m 个内核态线程，m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。</p>
<p>两层设计（Two Level）：多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。</p>
<p>内核线程是真正的线程，它会分配到 CPU 的执行资源。用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。</p>
<p>用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p>
<p>操作系统分成 3 层：应用层、内核层、硬件层。内核是连接应用和硬件的桥梁。内核需要公平的对待每个 CPU，于是有了用户态和内核态的切换；为了实现切换，需要中断；为了保护内存资源，需要划分用户态和内核态；为了更好地使用计算资源，需要划分线程——而线程需要操作系统内核调度。</p>
<p>分时（Time Sharing）</p>
<h2 id="进程和线程">进程和线程</h2>
<p>进程（Process）：正在进行执行的应用程序，是软件的执行副本。而线程是轻量级的进程。设计进程和线程，操作系统需要思考分配资源。最重要的 3 种资源是：计算资源（CPU）、内存资源和文件资源。进程下面，需要一种程序的执行单位，仅仅被分配计算资源（CPU），这就是线程。被分配的方式，就是由操作系统调度线程。操作系统创建一个进程后，进程的入口程序被分配到了一个主线程执行，这样看上去操作系统是在调度进程，其实是调度进程中的线程。这种被操作系统直接调度的线程，我们也成为内核级线程。</p>
<p>分时和调度</p>
<p>通常机器中 CPU 核心数量少（从几个到几十个）、进程&amp;线程数量很多（从几十到几百甚至更多），因此进程们在操作系统中只能排着队一个个执行，每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（内的线程）执行。</p>
<blockquote>
<p>分配时间片段：各个进程（线程）一次都只执行一个时间片段。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/CE/CgqCHl-iUNWARGseAACvXwFzOgM513.png" alt="Lark20201104-145535.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/C2/Ciqc1F-iUOOAH_pCAAAxJPD4vZk085.png" alt="Lark20201104-145538.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
</blockquote>
<p>进程和线程的状态：我这里一直用进程(线程）是因为旧的操作系统调度进程，没有线程；现代操作系统调度线程。</p>
<blockquote>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/CE/CgqCHl-iUO-AUnnuAACQlYvu6B4917.png" alt="Lark20201104-145543.png" style="zoom:33%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/C2/Ciqc1F-iUPuAcCoPAABsXQQRmUA149.png" alt="Lark20201104-145546.png" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/C3/Ciqc1F-iURaABVqnAADDuMgPbV8806.png" alt="Lark20201104-145541.png" style="zoom:33%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/CE/CgqCHl-iUSGAcoiLAAC6OKgt1vo694.png" alt="Lark20201104-145548.png" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>一旦一个进程（线程）进入阻塞状态，这个进程（线程）此时就没有事情做了，但又不能让它重新排队（因为需要等待中断），所以进程（线程）中需要增加一个“阻塞”（Block）状态。</p>
<p>处于“就绪”（Ready）的进程（线程）还在排队，所以进程（线程）内的程序无法执行，也就是不会触发读取磁盘数据的操作，“就绪”（Ready）状态无法直接变成阻塞的状态；处于“阻塞”（Block）状态的进程（线程）如果收到磁盘读取完的数据，它又需要重新排队，所以它也不能直接回到“运行”（Running）状态。</p>
</blockquote>
<p>进程（线程）创建后，开始排队即**“就绪”（Ready）**状态；</p>
<p>当轮到该进程（线程）执行时，变成**“运行”（Running）**状态；进程（线程）将操作系统分配的时间片段用完后，再回到“就绪”（Ready）状态。</p>
<p>当一个进程（线程）会等待磁盘读取数据/等待打印机响应，此时进程自己会进入**“阻塞”（Block）**状态。等待磁盘、打印机处理完成后，通过中断通知 CPU，然后 CPU 再执行一小段中断控制程序，将控制权转给操作系统，操作系统再将原来阻塞的进程（线程）置为“就绪”（Ready）状态重新排队。</p>
<p>1、进程和线程在内存中如何表示？需要哪些字段？</p>
<p>内存中设计两张表，一张是进程表、一张是线程表。</p>
<p>进程表需要这几类信息：</p>
<p>描述信息：这部分是描述进程的唯一识别号PID、进程的名称、所属的用户等。</p>
<p>资源信息：这部分用于记录进程拥有的资源，比如进程和虚拟内存如何映射、拥有哪些文件、在使用哪些 I/O 设备等，当然 I/O 设备也是文件。</p>
<p>内存布局：操作系统也约定了进程如何使用内存。通常一个进程大致内存分成堆、栈、数据段(全局变量/常数)、正文段(程序指令)等几个段。</p>
<p>线程表：ThreadID、执行状态（阻塞、运行、就绪）、优先级、程序计数器以及所有寄存器的值等等。（线程需要记录程序计数器和寄存器的值，是因为多个线程需要共用一个 CPU，线程经常会来回切换，因此需要在内存中保存寄存器和 PC 指针的值。)</p>
<p>用户级线程和内核级线程存在映射关系，因此可以考虑在内核中维护一张内核级线程的表，如果考虑到这种映射关系，比如 n-m 的多对多映射，可以将线程信息还是存在进程中，每次执行的时候才使用内核级线程。相当于内核中有个线程池，等待用户空间去使用。每次用户级线程把程序计数器等传递过去，执行结束后，内核线程不销毁，等待下一个任务。这里其实有很多灵活的实现，总体来说，创建进程开销大、成本高；创建线程开销小，成本低。</p>
<p>2、进程代表的是一个个应用，需要彼此隔离，这个隔离方案如何设计？</p>
<p>操作系统中运行了大量进程，为了不让它们互相干扰，可以考虑为它们分配彼此完全隔离的内存区域，即便进程内部程序读取了相同地址，而实际的物理地址也不会相同。对于一个进程的多个线程来说，可以考虑共享进程分配到的内存资源，这样线程就只需要被分配执行资源。</p>
<p>3、操作系统调度线程，线程间不断切换，这种情况如何实现？</p>
<p>进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。</p>
<img src="https://s0.lgstatic.com/i/image/M00/67/CE/CgqCHl-iUY-AEqrUAAKnDhPzBcQ340.png" alt="Lark20201104-145523.png" style="zoom:25%;" />
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/C3/Ciqc1F-iUZ-Af-t9AAC3WjDjEM4772.png" alt="Lark20201104-145556.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/67/C3/Ciqc1F-iUa-AdqG9AACMOQKJe2Q431.png" alt="Lark20201104-145530.png" style="zoom:100%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。</p>
</li>
<li>
<p>当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。</p>
</li>
<li>
<p>操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。</p>
</li>
<li>
<p>操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。</p>
</li>
<li>
<p>最后，操作系统执行下一个进程（线程）。</p>
</li>
</ol>
<p>一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。通过类似栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。</p>
<p>4、需要支持多 CPU 核心的环境，针对这种情况如何设计？</p>
<p>通常情况下，CPU 有几个核，就可以并行执行几个进程（线程）。并发(concurrent)指的在一段时间内几个任务看上去在同时执行（不要求多核）；并行(parallel)任务必须绝对的同时执行（要求多核）。操作系统提供了保存、恢复进程状态的能力，使得进程（线程）也可以在多个核心之间切换。</p>
<p>5、创建进程（线程）的 API？</p>
<img src="https://s0.lgstatic.com/i/image/M00/67/C3/Ciqc1F-iUcyAKsUkAADXFCtukIY084.png" alt="Lark20201104-145559.png" style="zoom:25%;" />
<p>每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。如果要创造 2 个克隆进程，就要 fork 两次。</p>
<p>6、进程的开销比线程大在了哪里？</p>
<p>Linux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。因此，创建进程比创建线程慢，而且进程的内存开销更大。</p>
<p>线程也被称作轻量级进程，由操作系统直接调度的，是内核级线程。我们还学习了线程切换保存、恢复状态的过程。进程和线程是操作系统为了分配资源设计的两个概念，进程承接存储资源，线程承接计算资源。而进程包含线程，这样就可以做到进程间内存隔离。</p>
<p><strong>原子操作</strong>就是操作不可分，多线程环境，一个原子操作的执行过程无法被中断。</p>
<p><strong>竞争条件</strong>即多个线程对一个资源（内存地址）的读写存在竞争。这种条件下资源的值不可预测，取决于竞争时具体的执行顺序。</p>
<blockquote>
<p>i++就不是一个原子操作，由 3 个原子操作组合成的：读取 i 的值；计算 i+1；写入新的值。</p>
<p>假如两个线程并发执行i++，程序片访问共享资源时会造成竞争条件，共享资源的值最终取决于<strong>程序执行的时序</strong>，结果不确定。这种<strong>访问共享资源的程序片段称为临界区</strong>。</p>
</blockquote>
<p>解决竞争条件的方案：</p>
<ul>
<li>不要让程序同时进入临界区即<strong>互斥</strong></li>
<li>避免竞争条件</li>
</ul>
<p>1.利用 ThreadLocal，每个线程独有变量，线程间就不存在竞争关系。</p>
<p>2.利用 CPU 提供的 Compare And Swap 原子操作，让非原子操作(i++)成为一个原子操作。cas是更新一个内存地址的值，但前提必须明确知道该内存地址当前的值。</p>
<blockquote>
<p><code>cas(&amp;i, i,i+1)</code>在这个过程中，若有其他线程把i更新为i+1，这次调用会返回 false，否则返回 true。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/68/E8/CgqCHl-lBrSAKBmrAADNiS8bkAY490.png" alt="Lark20201106-161714.png" style="zoom:33%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/68/DD/Ciqc1F-lBr2ATIabAADce4zrAOw887.png" alt="Lark20201106-161708.png" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td>普通：读取 i 的值；计算 i+1；写入新的值</td>
<td>cas：读取i ；计算i+1；cas操作</td>
</tr>
</tbody>
</table>
<p>少数CPU 没有提供 cas，提供一种 类似的Test-And-Set 指令（tas）。</p>
</blockquote>
<p>3.锁（lock）的目标是实现抢占（preempt）。即只让给定数量的线程进入临界区。锁可以用tas或者cas来实现。</p>
<pre><code class="language-c">enter();
i++;
leave();

//-----------用cas实现enter和leave函数----

int lock = 0;
enter(){//自旋锁:代码不断在 CPU 中执行指令，直到锁被其他线程释放
  while( !cas(&amp;lock, 0, 1) ) {
    // 什么也不做
  }
}
leave(){
  lock = 0;
}
</code></pre>
<p>多个线程竞争一个整数的 lock 变量，0 代表目前没有线程进入临界区，1 代表目前有线程进入临界区。利用cas原子指令我们可以对临界区进行管理。如果一个线程利用 cas 将 lock 设置为 1，那么另一个线程就会一直执行cas操作，直到锁被释放。</p>
<p>自旋锁优点不会主动 Context Switch（线程切换），因为线程切换比较消耗时。自旋锁缺点比较消耗 CPU 资源，如果自旋锁一直拿不到锁，会一直执行，比较消耗 CPU 资源。</p>
<pre><code class="language-java">enter(){
  while( !cas(&amp;lock, 0, 1) ) {
    // sleep(1000ms);休眠的时间不好控制
    wait();
  }
}
</code></pre>
<p>可以实现一个 wait 操作，主动触发线程切换，减轻cpu消耗问题。但线程切换也是消耗cpu资源的。wait方法，等待一个信号，直到另一个线程调用notify方法，通知这个线程结束休眠。</p>
<p>解决竞争条件时使用锁，进入临界区之前 lock，出去就 unlock定义锁，需要一个整型，语言级锁的实现如下：</p>
<pre><code class="language-java">enter(&amp;lock);
//临界区代码
leave(&amp;lock);
</code></pre>
<p>wait 和 notify 生产者消费者模型： wait 是一个生产者，将当前线程挂到一个等待队列上，并休眠。notify 是一个消费者，从等待队列中取出一个线程，并重新排队。</p>
<p>把<code>enter</code> <code>leave</code> <code>wait</code> <code>notify</code>的逻辑都封装起来，不让用户感知到它们的存在。Java 中每个对象增加了一个 Object Header 区域，里面一个锁的位（bit），锁并不需要一个 32 位整数，一个 bit 足够。</p>
<pre><code class="language-java">synchronized(obj){// enter
  // 临界区代码
} // leave
</code></pre>
<p>synchronized 关键字的内部实现，使用封装好的底层代码Monitor 对象。每个 Java 对象都关联了一个 Monitor 对象。Monitor 封装了对锁的操作，比如 enter、leave 的调用，这样简化了 Java 程序员的心智负担，你只需要调用 synchronized 关键字。</p>
<p>另外，Monitor 实现了生产者、消费者模型。</p>
<p>如果一个线程拿到锁，那么这个线程继续执行；</p>
<p>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</p>
<p>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</p>
<p>这样，Monitor 除了提供了互斥，还提供了线程间的通信，避免了使用自旋锁，还简化了程序设计。</p>
<p>互斥的广义版为<strong>信号量</strong>，同时允许 N 个线程进入临界区。当lock初始值为 1 的时候，这个模型就是实现互斥（mutex）。如果 lock 大于 1，那么就是同时允许多个线程进入临界区。这种方法，我们称为信号量（semaphore）。</p>
<p>信号量实现生产者消费者模型： wait 是生产者，notify 是消费者。 每次wait操作减少一个空位置数量，empty-1；增加一个等待的线程，full+1。每次notify操作增加一个空位置，empty+1，减少一个等待线程，full-1。</p>
<p>insert和remove方法是互斥的操作，需要用另一个 mutex 锁来保证。insert方法将当前线程加入等待队列，并且调用 yield 方法，交出当前线程的控制权，当前线程休眠。remove方法从等待队列中取出一个线程，并且调用resume进行恢复。以上， 就构成了一个简单的生产者消费者模型。</p>
<p>如果两个线程互相等待对方获得的锁，就会发生死锁。可以把死锁理解成一个环状的依赖关系。</p>
<p>分布式环境的锁：当用户并发的访问接口，是会发生竞争条件的。 因为程序已经不是在同一台机器上执行了，解决方案就是分布式锁。实现锁，我们需要原子操作。单机多线程并发的场景下，原子操作由 CPU 指令提供，比如 cas 和 tas 指令。分布式环境下很多工具都可以提供分布式的原子操作，比如 Redis 的 setnx 指令，Zookeeper 的节点操作等等。</p>
<p>并发场景，设计系统的目的往往是达到同步（Synchronized）的状态，同步就是大家最终对数据的理解达成了一致。同步的一种方式，就是让<strong>临界区互斥</strong>（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为<strong>悲观锁</strong>（Pressimistic Lock）。像git同时写，先更新的人被采纳，后更新的人负责解决冲突。是一种典型的**乐观锁（Optimistic Lock）**的场景。</p>
<p>除了上锁还有哪些并发控制方法？</p>
<p>之所以害怕并发，是因为中心化。用分级缓存的策略（dns）、分布式处理（分布式锁）优化，不如更彻底的用去中心化的方案，双方不用通过中心系统，直接达到同步（Synchronized）的状态。处理并发还可以考虑 Lock-Free 数据结构。比如 Lock-Free 队列，是基于 cas 指令实现的，允许多个线程使用这个队列。再比如 ThreadLocal，让每个线程访问不同的资源，旨在用空间换时间，也是避免锁的一种方案。</p>
<p>双方签订<strong>电子合同</strong>，解决最基本的信用问题。</p>
<p>区块链构成了一个基于历史版本的事实链，前一个版本是后一个版本的历史，把双方的货币和库存记录在Block中，解决<strong>货币和库存</strong>的问题。</p>
<p><strong>发生购买转账的交易</strong>，在末端节点上再增加一个区块。（若有很多人同时在这个末端节点上写新的 Block。可以由一个可信任的中心服务帮助合并新增的区块数据）</p>
<p><strong>解决欺诈问题</strong>，正常情况下自己的余额/库存交易按顺序记录在区块中无法超额。擅自修改自己的余额/库存等欺诈问题：要新增一个假的末端的block，就和之前 Block 中记录的冲突了；想要修改之前的某个block的数据，这个节点的摘要签名就会发生变化了， 那么后面所有的节点就失效了。相当于修改了完整的一个链条，且修改了所有的签名，就会被其他参与者知道并抵制。区块链一旦写入就不能修改，这样可以防止很多欺诈行为。</p>
<img src="https://s0.lgstatic.com/i/image/M00/6C/E0/Ciqc1F-ryUiAQ5JUAAEC6zaXAKM772.png" alt="4.png" style="zoom:50%;" />
<p>区块链：每个 Block 下面可以存一些数据，每个 Block 知道上一个节点是谁。且每个 Block 有上一个节点的摘要签名，可以证明上一个block的数据 的数据没有被篡改过。（如果 Block 10 是 Block 11 的上一个节点，那么 Block 11 会知道 Block 10 的存在，且用 Block 11 中 Block 10 的摘要签名，可以证明 Block 10 的数据没有被篡改过。）</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/6C/E0/Ciqc1F-ryVaAO-KFAADCyXfna24816.png" alt="2.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/6C/E0/Ciqc1F-ryV-ATtpAAACJ4ZgkVtU059.png" alt="1.png" style="zoom:43%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>同时下单时，会导致最后面的 Block，开很多分支。</p>
<p><strong>解决并发问题</strong>：不用集中式的锁解决。维护自己的 Block-Chain，等待合适的时机，再去合并到主分支上，而不是每次都创建block。</p>
<p>线程调度都有哪些方法？</p>
<p>非抢占的<strong>先到先服务（First Come First Service，FCFS）<strong>模型(使用队列FIFO)是最朴素的，公平性和吞吐量可以保证。但是因为希望减少用户的</strong>平均等待时间（总等待时间/任务数）</strong>，操作系统往往需要实现<strong>抢占（Preemption）<strong>和</strong>优先级队列（PriorityQueue）</strong>，同时还要<strong>短作业优先（Shortest Job First，SJF）。<strong>操作系统无法预判每个任务的预估执行时间，还需要采用</strong>分级队列</strong>。最高优先级的任务可以考虑非抢占的优先级队列（每个任务执行完才执行下一个）。 其他任务放到分级队列模型中执行，从最高优先级时间片段最小向最低优先级时间片段最大逐渐沉淀。这样就同时保证了小任务先行和高优任务最先执行。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/6D/A7/CgqCHl-uUx2AZFakAACjU3Bi2eE649.png" alt="Lark20201113-173328.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/6D/9C/Ciqc1F-uUyaAUVSDAAB3mZmSb3A937.png" alt="Lark20201113-173330.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>抢占（Preemption）<strong>就是把</strong>执行能力分时</strong>，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。</p>
<ol>
<li>线程相对于操作系统是排队到来的，操作系统为每个到来的线程分配一个优先级，然后把它们放入一个优先级队列中，优先级最高的线程下一个执行。</li>
<li>每个线程执行一个时间片段，每次线程执行满一个时间片，就执行一段调度程序(红色)。调度程序可以考虑实现为一个单线程模型，这样不需要考虑竞争条件。</li>
</ol>
<p><strong>多级队列模型</strong>:上层队列调度紧急任务，下层队列调度普通任务。只要上层队列有任务，下层队列就会让出执行权限。</p>
<ol>
<li>
<p>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</p>
</li>
<li>
<p>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分。如果遇到十万火急的情况，就可以优先处理这个任务。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/6D/A7/CgqCHl-uUzCAVhhzAAFSttJfDs4355.png" alt="Lark20201113-173333.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/6D/9C/Ciqc1F-uUzqAMYY-AADMHX-2Dso456.png" alt="Lark20201113-173318.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ol>
<p>优化：高优先级队列、普通优先级队列（实际操作中，可以有 n 层，一层层把大任务筛选出来。 最长的任务，放到最闲的时间去执行。）短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>
<ol>
<li>紧急任务仍然走高优队列，非抢占执行。</li>
<li>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</li>
<li>最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</li>
</ol>
<p>什么情况下会触发饥饿和死锁？</p>
<p>线程需要资源没有拿到，无法进行下一步，就是饥饿。死锁（Deadlock）和活锁（Livelock）都是饥饿的一种形式。 非抢占的系统中，互斥的资源获取，线程间互相等待资源，形成循环依赖就会产生死锁。死锁发生后，如果利用抢占解决，导致资源频繁被转让，有一定概率触发活锁。死锁、活锁，都可以通过设计并发控制算法解决，比如哲学家就餐问题。</p>
<p>（要解决死锁的问题，可以考虑哲学家拿起 1 个叉子后，如果迟迟没有等到下一个叉子，就放弃这次操作。比如 Java 的 Lock Interface 中，提供的tryLock方法，就可以实现定时获取，拿不到锁，就报异常，并释放已获得资源。</p>
<p>按以上方案解决死锁：可能在某个时刻，所有哲学及都拿起了左手的叉子，然后发现右手的叉子拿不到，就放下了左手的叉子。如此周而复始，这就是一种活锁。所有线程都在工作，但是没有线程能够进一步解决问题）</p>
<p>我的服务应该开多少个进程、多少个线程？</p>
<p>【解析】 计算密集型一般接近核数，如果负载很高，建议留一个内核专门给操作系统。I/O 密集型一般都会开大于核数的线程和进程。 但是无论哪种模型，都需要实地压测，以压测结果分析为准；另一方面，还需要做好监控，观察服务在不同并发场景的情况，避免资源耗尽。</p>
<h2 id="内存管理">内存管理</h2>
<p>内存一致性：在同一时刻，多线程之间，对内存中某个地址的数据认知是否一致（简单理解，就是多个线程读取同一个内存地址能不能读到一致的值）。</p>
<p>对某个地址，和任意时刻，如果所有线程读取值，得到的结果都一样，就是强一致性，或称为线性一致性（Sequencial Consistency）。 如果只有部分时刻所有线程的理解是一致的，那么称为弱一致性（Weak Consistency）。为什么会有内存不一致问题呢? 这就是因为 CPU 缓存的存在。</p>
<img src="https://s0.lgstatic.com/i/image/M00/72/28/CgqCHl_A0uOACUBUAACRcLSCqUw476.png" alt="Lark20201127-181946.png" style="zoom:25%;" />
<p>假如在 CPU 架构中，Thread1,Thread2 在不同核心，因此它们的 L1\L2 缓存不共用， L3 缓存共享。</p>
<p>如果 Thread1 发生了写入 A=1，这个时候会按照 L1,L2,L3 的顺序写入缓存，最后写内存。结果会导致 print 出来的 A 和 B 结果不确定，取决于具体线程执行的时机。Java 提供了一个 volatile 关键字，避免从读取不到lock的写入内存的问题（还在 Thread 所在 CPU 的 L1、L2 中）。</p>
<p>虚拟化技术是为了解决内存不够用的问题。</p>
<p>**内存交换（Swap）**技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。（此处的数据是指完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等）轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。</p>
<img src="https://s0.lgstatic.com/i/image/M00/75/44/Ciqc1F_Hb-GAermKAACje6hFwj4571.png" alt="Lark20201202-184240.png" style="zoom:50%;" />
<p>内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。每个进程独立得到一个空间即地址空间（Address Space）。地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，这种原始的虚拟化技术存在：碎片问题、频繁切换问题。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/75/44/Ciqc1F_Hb_aALLF_AABvGKciFvQ002.png" alt="Lark20201202-184243.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/75/4F/CgqCHl_HcAOAERr3AACsFab3D0g908.png" alt="Lark20201202-184247.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/75/44/Ciqc1F_HcBGANfB6AABfKTW4B2g866.png" alt="Lark20201202-184250.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>操作系统设计了虚拟内存，操作系统管理<strong>虚拟内存和真实内存之间的映射</strong>。操作系统将<strong>虚拟内存分成整齐的页（Page）</strong>。减轻内存碎片问题，而且操作系统不必关系哪些进程被高频/低频使用，只关心哪些页被高/低频使用，将高频实用的页保留在真实内存，低频使用的页保留在硬盘上。</p>
<p><strong>真实内存也需要分块为一个个Frame</strong>。Page 到 Frame 通过<strong>页表</strong>的结构映射。页表维护了虚拟地址到真实地址的映射。</p>
<p>上面的过程发生在 CPU 中一个小型的设备：内存管理单元（Memory Management Unit， MMU）中。当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后MMU 连接了地址总线，帮助 CPU 操作真实地址。</p>
<p>表中的每一项（页表条目）如下图所示</p>
<blockquote>
<img src="https://s0.lgstatic.com/i/image/M00/75/4F/CgqCHl_HcCiAXdDRAACAza-oxwo742.png" alt="Lark20201202-184252.png" style="zoom:50%;" />
<p>页表条目本身的编号page number可以不存在页表中，而是通过偏移量计算。 比如地址 100,000 的编号，可以用 100,000 除以页大小确定。</p>
<p>Absent（“在”）位，是一个 bit。0 表示页的数据在磁盘中（不再内存中），1 表示在内存中。如果读取页表发现 Absent = 0，那么会触发缺页中断，去磁盘读取数据。</p>
<p>Protection（保护）字段可以实现成 3 个 bit，它决定页表用于读、写、执行。比如 000 代表什么都不能做，100 代表只读等。</p>
<p>Reference（访问）位，代表这个页被读写过，这个记录对回收内存有帮助。</p>
<p>Dirty（“脏”）位，代表页的内容被修改过，如果 Dirty =1，那么意味着页面必须回写到磁盘上才能置换（Swap)。如果 Dirty = 0，如果需要回收这个页，可以考虑直接丢弃它（什么也不做，其他程序可以直接覆盖）。</p>
<p>Caching（缓存位），描述页可不可以被 CPU 缓存。CPU 缓存会造成内存不一致问题，在上个模块的加餐中我们讨论了内存一致性问题，具体你可以参考“模块四”的加餐内容。</p>
<p>Frame Number（Frame 编号），这个是真实内存的位置。用 Frame 编号乘以页大小，就可以得到 Frame 的基地址。</p>
</blockquote>
<img src="https://s0.lgstatic.com/i/image/M00/8C/20/CgqCHl_lnEqAGPEZAAC-Dsux5E8250.png" alt="1.png" style="zoom:50%;" />
<img src="https://s0.lgstatic.com/i/image/M00/75/50/CgqCHl_HcK2AGh63AABHzfHvTfg888.png" alt="Lark20201202-184238.png" style="zoom:50%;" />
<p>占据大空间的应用，大页面时页表时，为了减少条目的创建，可以考虑进程内部用一个更大的页表，操作系统继续用原来小的页表。按照这样的思想还有多级页表（40m、4m、4k）</p>
<p>MMU 根据 1 级编号找到 1 级页表条目，1 级页表条目中记录了对应 2 级页表的位置。依次递归查到末尾级别的页表，然后 MMU 再查询该页表找到 Frame。最后通过地址偏移量和 Frame 编号计算最终的物理地址。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image/M00/78/84/Ciqc1F_KEYiAGIk6AABN2sQtqqo988.png" alt="Lark20201204-183520.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/78/90/CgqCHl_KEZGAB4tfAAA_7O1Ajlg766.png" alt="Lark20201204-183533.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>虚拟地址由页号和偏移量组成，物理地址由 Frame Number 和偏移量组成。在 CPU 中有一个虚拟地址到物理地址转换的小型设备，叫作内存管理单元（Memory Management Unit(MMU）。</p>
<p>程序执行时，指令中的地址都是虚拟地址，虚拟地址会通过 MMU，MMU 会查询页表，计算出对应的 Frame Number，然后偏移量不变，组装成真实地址。然后 MMU 通过地址总线直接去访问内存。所以 MMU 承担了<strong>虚拟地址到物理地址的转换</strong>以及 <strong>CPU 对内存的操作</strong>这两件事情。MMU 在 CPU 内部，并且直接和地址总线连接。因此 MMU 承担了 CPU 和内存之间的代理。</p>
<p>CPU 的指令周期中，fetch、execute 和 store 这 3 个环节中都有可能发生内存操作，地址换算增加le指令的 CPU 周期。因此在 MMU 中往往还有一个微型的设备，叫作**转置检测缓冲区（Translation Lookaside Buffer，TLB）**来提高转换速度。TLB 是一个二维表格，每一行是一个 Page Number 对应一个 Frame Number。我们把这样的每一行称为一个缓存行（Cache Line），或者缓存条目（Entry）。<strong>TLB 的作用就是根据输入的 Page Number，找到 Frame Number</strong>。TLB 是硬件实现的速度快。现代多核 CPU，每个核心有单独的 TLB，且采用类似 CPU 缓存的分级策略。通过这样的设计，绝大多数的页表查询就可以用 TLB 实现了。</p>
<p>TLB 失效（Miss）： Page Number 在 TLB 总没有找到。</p>
<ol>
<li>软失效（Soft Miss）：Frame 还在内存中，只不过 TLB 缓存中没有。刷新 TLB 缓存，如果 TLB 缓存已经满了，就需要选择一个已经存在的缓存条目进行覆盖。具体选择哪个条目进行覆盖，我们称为<strong>缓存置换</strong>（缓存不够用了，需要置换）。缓存置换时，通常希望高频使用的数据保留，低频使用的数据被替换。</li>
<li>硬失效（Hard Miss)：对应的 Frame 没有在内存中，需要从磁盘加载。首先操作系统要触发一个缺页中断（原有需要读取内存的线程被休眠），然后中断响应程序开始从磁盘读取对应的 Frame 到内存中，读取完成后，再次触发中断通知更新 TLB，并且唤醒被休眠的线程去排队。线程不可能从休眠态不排队就进入执行态，因此 Hard Miss 是相对耗时的。</li>
</ol>
<p>基于缓存行（Cache Line）的缓存有 3 种映射方案：</p>
<p>相联（Associative）即缓存条目和缓存数据之间的映射范围。如果是全相联，则数据可能在任何条目。如果是组相联（Set-Associative），则数据只能在一部分缓存条目中出现（比如前 4 个条目为一组）。</p>
<ol>
<li>
<p>全相联映射（Fully Associative Mapping）：条目过多，硬件查询速度下降。</p>
</li>
<li>
<p>直接映射（Direct Mapping）：通过类似哈希函数的计算映射</p>
</li>
<li>
<p>n 路组相联映射（n-way Set-Associative Mapping）：允许一个虚拟页号（Page Number）映射到固定数量的 n 个位置，每次新地址需要置换进来的时候，可以从 n 个位置中选择更新时间最早的条目置换出去。</p>
</li>
</ol>
<p>前两种方案被缓存的值都在固定位置，而n 路组相联映射可以被缓存于多个位置，才能在后续实现根据时间或频率而淘汰的置换算法。</p>
<p>大内存分页时采用多级页表也会给MMU 带来一定的负担。可以采用大内存分页（Large Page 或 Huge Page），让系统能够提供大小为 4M 的页而非4k，以减少页数，也提高了 TLB 的查询性能。</p>
<p><strong>缓存设计中有一个重要的环节：当缓存满了，新的缓存条目要写入时，哪个旧条目被置换出去呢？</strong></p>
<p>这就需要用到缓存置换算法（Cache Replacement Algorithm）。设计缓存置换算法的期望是：每次将未来使用<strong>频率最低</strong>的数据置换出去。但实际中不可能预知哪些内存地址在未来指令中使用频率高低。在缓存中找到数据叫作一次命中（Hit），没有找到叫作穿透（Miss）。</p>
<blockquote>
<p>缓存置换应用场景非常广如：发生缺页中断后，操作系统需要将磁盘的页导入内存，那么已经在内存中的页就需要置换出去。CDN 服务器为了提高访问速度，需要决定哪些 Web 资源在内存中，哪些在磁盘上。CPU 缓存每次写入一个条目，也就相当于一个旧的条目被覆盖。数据库要决定哪些数据在内存中，应用开发要决定哪些数据在 Redis 中，而空间是有限的，这些都关联着缓存的置换。</p>
</blockquote>
<p>缓存置换算法：</p>
<p>随机/FIFO(链表)/FILO(栈)具有非常朴素的公平，但穿透概率高。</p>
<p>最近未使用（NRU Not Recently Used)：一条页表条目中的访问位Reference，代表页表有被读取过。脏位Dirty，代表页表被写入过。每次置换的时候，操作系统尽量最近未使用的即选择读、写位都是 0 的页面置换。</p>
<p>（NRU与FIFO结合成第二次机会算法：每次 把FIFO 队列尾部条目置换出去前，检查条目的都位若为1，则设为0同时不置换出去而移到队首[循环链表改变头指针即可]）</p>
<p>最近使用最少（LRU Least Recently Used）：比 NRU 多出最少使用即频率这个条件。最近一段时间最少使用到的数据应该被淘汰，把空间让给最近频繁使用的数据。这样的设计，即便数据都被使用过，还是会根据使用频次多少进行淘汰。</p>
<p>LRU 的一种常见实现是双向链表维护缓存条目。如果链表中某个缓存条目被使用到，那么就将这个条目重新移动到表头。如果要置换缓存条目出去，就直接从双线链表尾部删除一个条目。</p>
<p>通常 LRU 缓存还要提供查询能力，这里我们可以考虑用类似 Java 中 LinkedHashMap 的数据结构，同时具备双向链表和根据 Key 查找值的能力。</p>
<p>设计 LRU 缓存第一个困难是描述<strong>最近使用次数</strong> “最近”是一个模糊概念，没有具体指出是多长时间？按照 CPU 周期计算还是按照时间计算？</p>
<p>页面置换算法中，<strong>累加计数页表的读位（访问位Reference）</strong>。这种单纯基于使用次数最少判断置换，我们称为<strong>最少使用（Least Frequently Used,，LFU）算法</strong>。</p>
<blockquote>
<p>例如：现在某个页表条目的累计值是 0， 接下来在多次计数中看到的读位是：1,0,0,1,1，那么累计值就会变成 3。这代表在某段时间内（5 个计数器 Tick 中）有 3 次访问操作。</p>
<p>LFU 的劣势在于它不会忘记数据，累计值不会减少。如果有内存数据过去常常被用到，但是现在已经有很长一段时间没有被用到了，在这种情况下它并不会置换出去。</p>
</blockquote>
<p>**”老化”（Aging）**的算法：解决累加计数只增不减的问题。</p>
<blockquote>
<p>比如用 8 位来描述累计数（A），那么每次当读位的值（R）到来的时候，我们都考虑将 A 的值右移，然后将 R 放到 A 的最高位。</p>
<p>例如 A 目前的值是00000000，在接下来的 5 个 Tick 中 R 来临的序列是11100，那么 A 的值变更顺序为：</p>
<p>10000000</p>
<p>11000000</p>
<p>11100000</p>
<p>01110000</p>
<p>00111000</p>
<p>随着 Aging 算法的执行，有访问操作的时候 A 的值上升，没有访问操作的时候，A的值逐渐减少。如果一直没有访问操作，A 的值会回到 0。</p>
</blockquote>
<p>巧妙地用数学描述了“最近”。操作系统每次页面置换的时候，都从 A 值最小的集合中取出一个页面放入磁盘。这个算法是对 LRU 的一种模拟，也被称作 LFUDA（动态老化最少使用，其中 D 是 Dynamic,，A 是 Aging）。</p>
<p>LRU 用什么数据结构实现更合理？</p>
<p>【解析】 最原始的方式是用数组，数组的每一项中有数据最近的使用频次。数据的使用频次可以用计时器计算。每次置换的时候查询整个数组实现。</p>
<p>另一种更好的做法是利用双向链表实现。将使用到的数据移动到链表头部，每次置换时从链表尾部拿走数据。链表头部是最近使用的，链表尾部是最近没有被使用到的数据。</p>
<p>但是在应对实际的场景的时候，有时候不允许我们建立专门用于维护缓存的数据结构（内存大小限制、CPU 使用限制等），往往需要模拟 LRU。比如在内存置换场景有用“老化”技术模拟 LRU 计算的方式。</p>
<p>通常意义上我们说的垃圾回收器（Garbage Collector，GC），不只是内存回收用的模块，而事实上程序语言提供的 GC 往往是应用的实际内存管理者。</p>
<p>GC 的“工作”有 4 种：</p>
<ol>
<li>
<p>GC 要和操作系统进行交互，负责申请内存；并把不用的内存还给操作系统（释放内存）。</p>
</li>
<li>
<p>应用会向 GC 申请内存。</p>
</li>
<li>
<p>GC 要承担我们通常意义上说的垃圾回收能力，标记不用的对象，并回收他们。</p>
</li>
<li>
<p>GC 还需要针对应用特性进行动态的优化。</p>
</li>
</ol>
<p>在程序语言实现 GC 内存管理的时候，会关注下面这几个指标：</p>
<p>吞吐量（Throughput）：执行程序（不包括 GC 执行的时间）和总是间的占比。只要不在 GC，就认为是吞吐量的一部分。</p>
<p>足迹（FootPrint）： 一个程序使用了多少硬件的资源，也称作程序在硬件上的足迹。GC 里面说的足迹，通常就是应用对内存的占用情况。比如说应用运行需要 2G 内存，但是好的 GC 算法能够帮助我们减少 500MB 的内存使用，满足足迹这个指标。</p>
<p>暂停时间（Pause Time）： GC 执行的时候，通常需要停下应用（避免同步问题），这称为 Stop The World，或者暂停。（不同应用对某次内存回收可以暂停的时间需求是不同的，比如说一个游戏应用，暂停了几毫秒用户都可能有很大意见；而看网页的用户，稍微慢了几毫秒是没有感觉的。GC 往往不能拥有太长的暂停时间（Pause Time），因为 <strong>GC 和应用是并发的执行</strong>。如果 GC 导致应用暂停（Stop The World，STL）太久，那么对有的应用来说是灾难性的。但如果暂停时间只允许很短，那么 GC 和应用的交替就需要非常频繁。）</p>
<p>吞吐量高，不代表暂停时间少，也不代表空间使用（FootPrint）小。 同样的，使用空间小的 GC 算法，吞吐量反而也会下降。三者之间存在类似相同成本代价下不可兼得的关系，往往编程语言会提供参数让你选择根据自己的应用特性决定 GC 行为。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image2/M01/03/6E/CgpVE1_cGkiAQg5eAACZco3DsVw877.png" alt="图片1.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image/M00/84/6B/Ciqc1F_TUQ6AGct7AACd_pMg8rA373.png" alt="图片3.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>实现 GC 最简单的方案叫作<strong>引用计数</strong>：如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。</p>
<p>缺点：</p>
<p>循环引用：如图三者互相引用，虽然引用计数是 1。但即使这 3 个对象不会再使用了，GC 不会回收它们。</p>
<p>引用计数法容错能力差，多线程环境下引用计数的算法一旦算错 1 次，就会导致内存永久无法被回收。</p>
<img src="https://s0.lgstatic.com/i/image/M00/8B/9A/CgqCHl_cGjOAErigAAE9Hos_mIo707.png" alt="图片2.png" style="zoom:50%;" />
<p>Root Tracing 类算法：标记-清除算法和 3 色标记-清除算法都属于这一类。</p>
<p>从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。如果一个对象从根对象不可达，那么这个对象就应该被回收(即便这个对象存在循环引用。)</p>
<p>（根对象是所有引用关系的源头，比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。)</p>
<p>标记-清除（Mark Sweep）算法:用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。</p>
<p>假设有两个全局变量是已知的：</p>
<ul>
<li>
<p>heapSet 中拥有所有对象</p>
</li>
<li>
<p>rootSet 中拥有所有 Root Object</p>
</li>
<li>
<p>标记函数mark：它会递归地将一个对象的所有子对象染成黑色(DFS深度优先搜索)</p>
</li>
</ul>
<ol>
<li>将所有的对象染成白色</li>
<li>mark：从所有Root Object开始执行标记函数mark</li>
<li>Sweep：上一步程序执行结束后，所有和 Root Object 连通的对象都已经被染成了黑色。然后我们遍历整个 heapSet 找到白色的对象进行回收清除（Sweep）</li>
</ol>
<p>如果上面的 GC 程序在某个时刻暂停了下来，然后开始执行用户程序。如果用户程序删除了对某个已经标记为黑色对象的所有引用，用户程序没办法通知 GC 程序。这个节点就会变成<strong>浮动垃圾（Floating Garbage）</strong>，需要等待下一个 GC 程序执行。假设用户程序和 GC 交替执行，用户程序不断进行<strong>修改（Mutation）</strong>，而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/27/Cip5yF_Z2CCAZ4MFAABZx6AzarA983.png" alt="Drawing 0.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/27/Cip5yF_Z2CiASF0QAACL55G2CDE848.png" alt="Drawing 1.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>GC 的过程是标记、清除及程序不断对内存进行修改的过程。标记（Mark）就是找到不用的内存，清除（Sweep）就是回收不用的资源，而修改（Muation）则是指用户程序对内存进行了修改。</p>
<blockquote>
<p>对于 Mark、Sweep、Mutation 来说内存是共享的。如果并行执行相当于需要同时处理大量竞争条件的手段，这会增加非常多的开销。因此在 GC 的设计中，上述 3 种程序不允许并行执行（Simultaneously）。当然你可以开多个线程去 Mark、Mutation 或者 Sweep，但前提是每个过程都是独立的。</p>
</blockquote>
<p>对于双色标记-清除算法，如果 Mark 和 Sweep 之间存在 Mutation，那么 Mutation 的伤害是比较大的。</p>
<p>三色标记-清除算法（Tri-Color Mark Sweep）：</p>
<ul>
<li>
<p>白色代表需要 GC 的对象；</p>
</li>
<li>
<p>黑色代表确定不需要 GC 的对象；</p>
</li>
<li>
<p>灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。</p>
</li>
</ul>
<p>一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/2C/Cip5yF_Z4eWAc6oqAAFWo21QkuY797.png" alt="图片36.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/2D/CgpVE1_Z4h2AKNQnAAFJ-m6TgJw012.png" alt="图片33.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>类似双色标记-清除算法的<strong>全量 GC 程序</strong>，我们从 Root 集合开始遍历，完成了对所有元素的标记（将它们放入对应的集合）。</p>
<p>执行之初，所有对象都放入白色集合。</p>
<p>第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合。</p>
<p>不断从灰色集合中取出元素进行标记：这是DFS的过程，保证 3 个集合都是线程安全的，可以考虑利用 ConcurrentSet（这样性能更好）</p>
<ol>
<li>
<p>如果对象在白色集合中，那么先将对象放入灰色集合；</p>
</li>
<li>
<p>然后遍历节点的所有的引用对象，并递归所有引用对象；</p>
</li>
<li>
<p>当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。</p>
</li>
</ol>
<p>标记算法完成后，白色集合内就是需要回收的对象。</p>
<p>**增量 GC（Incremental GC）**的实现。</p>
<p>首先对用户的修改（Mutation）分 3 类：创建新对象、删除已有对象、调整已有引用</p>
<p>如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。（虽然也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务）</p>
<p>如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理。但实际中暂时不处理。</p>
<p>在调整已有的引用关系时，调整过的都加入灰色集合</p>
<p>内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。<strong>三色算法通过对用户修改（Mutation）（创建新对象、删除已有对象、调整已有引用）的增量灰色标记，提高“垃圾”被并发回收的概率。</strong></p>
<p>目前的 <strong>GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。</strong></p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/28/CgpVE1_Z2OuAXxFjAABfInodsKw867.png" alt="Drawing 15.png" style="zoom:50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image2/M01/02/28/Cip5yF_Z2POASXuMAACh7n5TBi8380.png" alt="Drawing 17.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>三色标记-清除算法，还没有解决内存回收产生碎片的问题。通常，我们会在三色标记-清除算法之上，再构建一个<strong>整理内存（Compact）的算法。</strong></p>
<p>根据新创建出来的对象，死亡（被回收）概率会更高，而那些已经存在了一段时间的对象，往往更不容易死亡：</p>
<p>把新创建的对象，都先放到一个统一的区域，在 Java 中称为伊甸园（Eden）。这个区域因为频繁有新对象死亡，因此需要经常 GC。将存活下来的对象拷贝到另一个区域，Java 中称为存活区（Survior）。存活区生存下来的对象再进入下一个区域，Java 中称为老生代。Eden、Survior 及老生代之间的关系是对象的死亡概率逐级递减，对象的存活周期逐级增加。三个区域都采用三色标记-清除算法。</p>
<p>Eden 可以考虑和 Survivor 用 1:1 的空间，老生代则可以用更大的空间。Eden 中全量 GC 可以频繁执行，也可以增量 GC 混合全量 GC 执行。老生代中的 GC 频率可以更低，偶尔执行一次全量的 GC。</p>
<p>通常选择 GC 会有实时性要求（最大容忍的暂停时间），需要从是否为高并发场景、内存实际需求等维度去思考。在选择 GC 的时候，复杂的算法并不一定更有效。<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210702114136599.png" alt="image-20210702114136599" style="zoom:50%;" /></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网路]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-wang-lu/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-wang-lu/">
        </link>
        <updated>2021-06-07T05:40:09.000Z</updated>
        <content type="html"><![CDATA[<p>公司内网中每个路由器、交换机构成一级子网。最高级的路由器在公司网络的边缘，它可以将网络内部节点连接到其他的网络（网络外部）。本地网络提供商（ISP）提供的互联网先到达边缘的路由器，然后再渗透到内部的网络节点。公司内部的若干服务器可以通过交换机形成一个局域网络；公司内部的办公设备，比如电脑和笔记本，也可以通过无线路由器或者交换机形成局域网络。局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M01/38/64/Cgp9HWB5O5KAFGFAAAD-82hpYWc483.png" alt="Drawing 2.png" style="zoom: 50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image6/M00/38/6D/CioPOWB5O7uAUZ7qAAB_rmbTigw120.png" alt="Drawing 4.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>通信<strong>链路</strong>（Communication Link），用于传输网络信号。公司<strong>内网</strong>从<strong>本地网络服务提供商</strong> （Internet Service Provider） 接入，然后内部再分成一个个<strong>子网</strong>。路径分叉时需要进行<strong>交换</strong>（Switch），数据从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径，常见的交换设备是链路层交换机（Link-Layer Switch）和路由器（Router），交换机连接多台设备，路由器连接两个网络，但是路由器通常也具有交换机的功能。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/38/6D/Cgp9HWB5RAmAZRwzAACtAP-CPWs242.png" alt="Drawing 1.png" style="zoom: 25%;" />
<p>TCP（Transport Control Protocol）是一个传输层协议：提供主机到主机的（Host-To-Host）数据的可靠传输，支持全双工，是一个连接导向的协议。</p>
<p>TCP 上层应用层：不同应用要使用TCP的能力，通过端口号区分应用。</p>
<p>TCP 下层网络层：提供地址到地址的通信（Address-To-Address），IP 协议解决地址到地址的通信。</p>
<p>网络层只负责ip地址到地址的通讯，再往下层通过路由/交换的链路传输网络信号，再通过下层物理层的具体传输介质作为载体。</p>
<table>
<thead>
<tr>
<th>应用层http/ssh</th>
<th>传输层tcp/udp</th>
<th>网络层ip</th>
</tr>
</thead>
<tbody>
<tr>
<td>Port-To-Port</td>
<td>Host-To-Host</td>
<td>Address-To-Address</td>
</tr>
<tr>
<td>Session</td>
<td>Connection</td>
<td></td>
</tr>
</tbody>
</table>
<p>TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是一个应用的行为。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3A/20/CioPOWB-RYSASfPkAAEen4ZR3gw297.png" alt="619.png" style="zoom:25%;" />
<p>如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；</p>
<p>如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；</p>
<p>如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。</p>
<p>以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M00/38/6D/Cgp9HWB5RCqAVfhiAADJmfGn2O0616.png" alt="Drawing 4.png" style="zoom:33%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image6/M00/3D/55/CioPOWCTwu-AD9PgAABp1yJqsPI439.png" alt="图片2.png" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）</p>
<p>握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复。</p>
<p>到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），等所有工作结束，再发送请求中断连接（FIN）。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3A/3C/Cgp9HWB-mz2ALAO6AAFJNuQ9-SU088.png" alt="Drawing 5.png" style="zoom:50%;" />
<p>TCP 拆包的作用是将任务拆分处理，减小底层网络处理的压力，降低整体任务出错的概率。</p>
<p>在内存中开辟的一块缓冲区供TCP 段排队，将数据拆分成不超过缓冲区大小的部分，即 TCP 段（<strong>TCP Segment</strong>）进行发送。</p>
<p>拆包：一个数据太大，经过拆分多个 TCP 段发送，然后在目的地重组。</p>
<p>粘包：多个数据太小，合并成一个 TCP 段发送，在目的地再还原成多个数据。</p>
<p>TCP 利用Seq、ACK（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。</p>
<p>MSS（Maximun Segment Size）是 TCP Header 中的可选项，双方协商控制TCP 段的大小。</p>
<p>MSS 太小，每一份数据都要增加一个头部，那头部的数据占比会上升，吞吐量下降。</p>
<p>MSS 太大，会降低性能，比如缓冲区变大造成的内存性能/服务器资源的占用等硬件和计算资源、支持 TCP 协议工作的 IP 协议（TCP 协议不肯拆包，IP 协议就需要拆出大量的包），工作效率会下降。</p>
<blockquote>
<p>TCP Header</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/tcpsegment.png" alt="" loading="lazy"></figure>
</blockquote>
<p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p>
<p>但是每一个请求收到响应之后，再发送下一个请求，吞吐量会很低，浪费带宽。改进方式，就是让发送方有请求就发送出去，而不是等待响应。发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。</p>
<p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是我们不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p>
<p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可。（其他用途：求一个数组中最大的连续 k 项和）。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>滑动窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://s0.lgstatic.com/i/image6/M00/3A/FA/CioPOWCCKwuAfBn5AABKdgtX54w997.png" alt="image (3).png" style="zoom:33%;" /></td>
<td><img src="https://s0.lgstatic.com/i/image6/M00/3A/F2/Cgp9HWCCKxSAROSpAAA_zThgiBA669.png" alt="image (4).png" style="zoom:33%;" /></td>
</tr>
</tbody>
</table>
<p>实现这样的模型，用队列要用多个队列。用滑动窗口才是最合适的数据结构，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。假设我们最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK（浅绿色）。如果一个封包 ACK 到达，我们就将它标记为已接收（深绿色）。</p>
<p>RTT 表示 Round Trip Time，就是消息一去一回的时间。</p>
<p><strong>确认与重发的机制</strong></p>
<p>自适应重传算法**（<strong>Adaptive Retransmission Algorithm</strong>）**</p>
<p>快速重传：接收方可以发送多次某段的 ACK，如果发送方收到多个该段ACK，就会重发该段。</p>
<p><strong>Selective Acknowledgment</strong> （<strong>SACK</strong>）</p>
<p>发送方将数据拆包，变成多个段。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的段会一次性发送。窗口中序号最小的段如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。</p>
<p>UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。UDP 协议不会拆分数据，Datagram 就是数据传输的最小单位。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3B/0F/Cgp9HWCCfQeAGOF3AACK2Gf5t6I606.png" alt="图片1.png" style="zoom:50%;" />
<p>Length 是Datagram长度。</p>
<p>Data octets 就是一个字节一个字节的数据，Octet 是 8 位。</p>
<p>IP（Internet Protocol）协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行分片Fragmentation。然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个IP 封包（Datagram）之后，通过寻址和路由目的地和路径确认，最后调用底层的数据链路层传送数据。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3C/0B/CioPOWCH4u-AWVEAAAH_xR5D6lU716.png" alt="Drawing 1.png" style="zoom: 33%;" />
<blockquote>
<p>主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv4/v6 封包（Datagram or Packet），寻址路由，再调用数据链路层传输数据。</p>
</blockquote>
<p>可靠性保证数据无损地到达目的地。可靠性是 IP 协议上方的 Host-To-Host 协议保证的，比如 TCP 协议通过应答机制、窗口等保证数据的可靠性。 IP 协议自身不能保证可靠性。IP 协议可能会有如下问题：</p>
<ol>
<li>
<p>封包损坏（数据传输过程中被损坏）；</p>
</li>
<li>
<p>丢包（数据发送过程中丢失）；</p>
</li>
<li>
<p>重发（数据被重发，比如中间设备通过 2 个路径传递数据）；</p>
</li>
<li>
<p>乱序（到达目的地时数据和发送数据不一致）。</p>
</li>
</ol>
<p>网络层主要有 3 个问题要解决：</p>
<ol>
<li>
<p>延迟</p>
</li>
<li>
<p>吞吐量</p>
</li>
<li>
<p>丢包率</p>
</li>
</ol>
<p>IP Header</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3C/7D/Cgp9HWCKhJaAKKEhAABhmC7udP0409.png" alt="image (1).png" style="zoom:50%;" />
<p>IHL（Internet Header Length）用来描述 IP 协议头的大小。所以 IP 协议头的大小是可变的。IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）。</p>
<p>Type Of Service 服务的类型，三个波段（band）的优先级也不相同。被分配到三个波段（band）里面的，band 0 的优先级最高，band 2 的最低，用来平衡延迟、吞吐量和丢包率之间的关系。</p>
<p>Total Length 定义报文（封包 Datagram）的长度。</p>
<p>Identification（报文的 ID），发送方分配，代表顺序。</p>
<p>Fragment offset 描述要不要分包（拆分），以及如何拆分。</p>
<p>Time To Live 描述封包存活的时间。因此每个 IP 封包发送出去后，就开始销毁倒计时。</p>
<p>Protocol 是描述上层的协议，比如 TCP = 6，UDP = 17。</p>
<p>Header Checksum 用来检验封包的正确性，如果 Checksum 对不上，就需要选择丢弃这个封包。</p>
<p>原地址和目标地址。IPv4 的地址是 4 组 8 位的数字，共是 32 位。</p>
<p>Options 代表可选项。</p>
<p>延迟（latency）</p>
<p>延迟指的是 1 bit 的数据从网络的一个终端传送到另一个终端需要的时间。这个时间包括在发送端准备发送的时间、排队发送的时间、发送数据的时间、数据传输的时间等。</p>
<p>吞吐量（Throughput）</p>
<p>吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps。</p>
<p>丢包率（Packet loss）</p>
<p>丢表率指发送出去的封包没有到达目的地的比例。 在最大流速确定的网络中，丢包率会直接影响吞吐量。</p>
<p>寻址Addressing：地址高位到低位和255.0.0.0（子网掩码）做位与运算依次得到子网地址。子网掩码的作用就是帮助根据 IP 地址找到对应子网。</p>
<p>路由Routing：由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关Gateway。</p>
<p>IPv4 的地址是 4 个 8 位（octet），总共 32 位。 IPv6 的地址是 8 个 16 位（hextet），总共 128 位。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/0B/CioPOWCH4wGAT3bUAALH_YQ0Q-U502.png" alt="Drawing 3.png" style="zoom:33%;" />
<p>省略表示</p>
<pre><code class="language-jade">0123:4567:0000:0000:0123:4567:0000:cdef
0123:4567::0123:4567:0000:cdef //::省略了若干组0000
123:4567::123:4567:0:cdef //省略开头的0
3c4d::/16 //只有前16位有数据
</code></pre>
<p><strong>IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可</strong>。</p>
<p>IPv6 的寻址分成了几种类型：</p>
<ul>
<li>全局单播寻址（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）；</li>
<li>本地单播（类似 IPv4 里的一个内部网络，要求地址必须以<code>fe80</code>开头，类似我们 IPv4 中<code>127</code>开头的地址）；</li>
<li>分组多播（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；</li>
<li>任意播（Anycast），这个方式比较特殊，接下来我们会详细讲解。</li>
</ul>
<blockquote>
<p>全局单播时，IPv6 地址通常分成 3 个部分</p>
<ul>
<li>站点前缀（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；</li>
<li>子网号（Subnet ID），16bit，用于站点内部区分子网；</li>
<li>接口号（Interface ID）， 64bit，用于站点内部区分设备。</li>
</ul>
<p>IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（即设备的网卡）。</p>
</blockquote>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4w-AEinAAAHIfeF4_II848.png" alt="Drawing 5.png" style="zoom:25%;" />
<blockquote>
<p>本地单播 虽然理论上 IPv6 可以将所有的设备都连入一个网络。但实际中还是需要一个内部网络。在局域网络中，实现设备到设备的通信，就是本地单播。本地单播地址必须以<code>fe80</code>开头，后面 64 位的 0，然后接上 54 位的设备编号。类似于127.0.0.。上图中的 Interface 可以理解成网络接口，其实就是网卡。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4x6AJJxNAAEMhuOKNmY768.png" alt="Drawing 7.png" style="zoom:25%;" />
</blockquote>
<blockquote>
<p>IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是<code>ff00</code>开头，后面会跟上一个分组的编号时，就是在进行分组多播。</p>
</blockquote>
<blockquote>
<p>任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。客户端想要获取时间，就将请求发送到这个任播地址。会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。</p>
</blockquote>
<p>IPv6 和 IPv4 的兼容</p>
<p><strong>IPv4 网络和 IPv6 网络通信</strong>时通过DNS64 查询服务把 IPv4 地址和 IPv6 地址同时返回。再通过NAT64 路由器将 IPv6 地址转换为 IPv4 地址。</p>
<p><strong>两个 IPv6 网络被 IPv4 隔离</strong>时通过Tunnel，<strong>隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序</strong>。</p>
<p><strong>IPv6 解决的是地址耗尽的问题</strong>。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。</p>
<p>链路层发送数据靠的是 MAC 地址，不同于IP地址（住址），MAC 地址就好像人的身份证一样。</p>
<p>数据的发送方，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个分组（Packet），也称作 <strong>Frame</strong> 或者封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。</p>
<blockquote>
<p>TCP 协议滑动窗口中的MSS（Maximun Segment Size）是 TCP 段最大值，是传输层概念。</p>
<p>IP层 封包（Datagram）</p>
<p>如果 IP 协议要传输数据，就要将数据转换成为链路层的Frame，然后才可以在链路层传输。IP 协议要根据 MTU 拆分封包。</p>
<p><strong>MTU</strong>（Maximun Transmission Unit）链路层网络允许的最大传输数据分组的大小，是链路层概念。<strong>IP 协议要根据 MTU 拆分封包</strong></p>
<p>交换机的作用更侧重局域网内各主机交换，路由器的作用更侧重从局域网内主机到另一个局域网内主机路经的路由。</p>
<p>数据从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径叫做Switch，链路层交换机（Link-Layer Switch）和路由器（Router）都是能起这一作用设备。局域网边界与另一局域网边界即为网关，因为路由器也起到连结两个局域网的作用，因此网关一般理解为就是路由器的IP。</p>
</blockquote>
<p>已知 IP 地址，找到 MAC 地址的协议，叫作地址解析协议（ARP Address Resolution Protoco）。<strong>ARP</strong>和 <strong>DNS 非常相似，采用的是逐级缓存的设计减少 ARP 请求</strong>。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。</p>
<p>局域网内主机数据交换根据MAC 地址，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个 Frame 封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。当然13/26交叉网线连结两主机的特殊局域网另算。</p>
<p>发到外网要先发到网关这一特殊主机Mac地址，在由网关往外发。</p>
<p>网络地址解析协议（<strong>NAT</strong> Network Address Translation）解决的是内外网通信的问题。NAT 通常发生在内网和外网衔接的路由器中，NAT将内网中某个 IP 地址映射到外网 IP，然后再把数据发送给外网的服务器。</p>
<p><strong>127.0.0.1, localhost, 0.0.0.0 有什么不同</strong></p>
<p><code>127.0.0.1</code>是本地回环<strong>地址</strong>（loopback），发送到 loopback 的数据会被转发到本地应用。</p>
<p>localhost 是<strong>主机</strong>名，指代的本地计算机，用于访问绑定在 loopback 上的服务。</p>
<p><code>0.0.0.0</code>是不可路由 IP 地址，当把一个服务绑定到<code>0.0.0.0</code>，相当于把服务绑定到任意的 IP 地址。</p>
<p>客户端将数据发送给在客户端侧的Socket 对象，然后客户端侧的 Socket 对象将数据发送给服务端侧的 Socket 对象。Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。</p>
<p>对于一个服务端 Socket 文件，我们要设置它监听的端口。比如 Nginx 监听 80 端口、Node 监听 3000 端口、SSH 监听 22 端口、Tomcat 监听 8080 端口。端口监听不能冲突，不然客户端连接进来创建客户端 Socket 文件，文件描述符就不知道写入哪个服务端 Socket 文件了。</p>
<p>服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3E/7B/Cgp9HWCZ8deAY_UqAAFeGtcsKIg099.png" style="zoom:25%;" />
<p>从另一个角度去分析，Socket 还是一种双向管道文件，也是文件描述符。</p>
<p>在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用。</p>
<p>主动式的 I/O 多路复用（select poll），对负责 I/O 的线程压力过大，因此通常会设计一个高效的中间数据结构作为 I/O 事件的观察者，线程通过订阅 I/O 事件被动响应，这就是响应式模型。在 Socket 编程中，最适合提供这种中间数据结构的就是操作系统的内核，事实上 epoll 模型也是在操作系统的内核中提供了红黑树结构。</p>
<p>扫描和监听：对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。</p>
<p>之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。</p>
<p>上述的过程，我们通过一个线程就可以响应多个客户端的连接，也被称作I/O 多路复用技术</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M01/3E/83/CioPOWCZ8fOAaVwEAAJ4CITeHSs003.png" alt="" loading="lazy"></th>
<th><img src="https://s0.lgstatic.com/i/image6/M01/3E/7B/Cgp9HWCZ8fyAJIK7AAFzaGqyFsw603.png" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>如果接入的客户端 Socket 较多，每次轮询的开销都会很大。从程序设计的角度来看，像这样主动遍历，比如遍历一个 Socket 集合看看有没有发生写入（有数据从网卡传过来），称为命令式的程序。</p>
<p>响应式（Reactive）epoll：响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。 Socket 文件的读写都要经过操作系统，所以最合适的观察者其实是操作系统本身。</p>
<ol>
<li>线程需要告诉中间的观察者自己要观察什么：即注册</li>
<li>中间的观察者服务于很多的线程，需要实现一个高效的数据结构：通常是基于红黑树的二叉搜索树</li>
</ol>
<blockquote>
<p>响应式为什么用红黑树？</p>
<p>中间观察者核心诉求：第一是让线程可以注册自己关心的消息类型。第二能够快速地判断是哪个线程需要知道这个消息。因此需要一个快速能插入（注册过程）、查询（通知过程）一个整数的数据结构，这个整数就是 Socket 的文件描述符。能够解决这个问题的数据结构中，跳表和二叉搜索树都是不错的选择。</p>
<p>epoll 为什么用红黑树？</p>
<p>【解析】在 Linux 的设计中有三种典型的 I/O 多路复用模型 select、poll、epoll。</p>
<p>select 是一个主动模型，需要线程自己通过一个fdset集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。</p>
<p>poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，你可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。</p>
<p>epoll 模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。</p>
</blockquote>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210610220052461.png" alt="image-20210610220052461" style="zoom:67%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210610215833870.png" alt="image-20210610215833870" style="zoom:67%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210610220128299.png" alt="image-20210610220128299" style="zoom:67%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611113050387.png" alt="image-20210611113050387" style="zoom:50%;" />
<p><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611113309558.png" alt="image-20210611113309558" style="zoom:50%;" /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611113510282.png" alt="image-20210611113510282" style="zoom:50%;" /></p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611103433126.png" alt="image-20210611103433126" style="zoom:67%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611115050524.png" alt="image-20210611115050524" style="zoom:50%;" />
<p>幂等方法：提交一次和多次效果一样。</p>
<p>服务端相应码</p>
<p>1XX 请求已接收到，还需进一步处理。</p>
<p>2XX OK成功返回响应</p>
<p>3xx 重定向 301永久 302临时</p>
<p>4xx 客户端错误 401认证错误 407认证代理错误 403权限错误 404临时没找到资源 406语言/编码资源不存在</p>
<p>408请求超时</p>
<p>5XX服务器错误 501功能尚未实现 502代理服务器错误 504代理服务器超时</p>
<p>Connection 头部 Keep-Alive:长连接</p>
<p>客户端请求长连接Connection: Keep-Alive</p>
<p>服务器表示支持长连接Connection: Keep-Alive</p>
<p>客户端复用连接</p>
<blockquote>
<p>HTTP/1.1 默认支持长连接Connection: Keep-Alive 无意义， Connection：Close关闭</p>
<p>Connection只对当前连接有效，层层代理服务器，每层单独处理。</p>
</blockquote>
<p>典型的REST（Representational state transfer表现状态转换） 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。按照HTTP 协议中方法的约定就是最好的使用。</p>
<p>Restful 中的 State是服务端状态，可以理解为业务的状态。</p>
<p>前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation。</p>
<p>用户通过前端向服务端做状态的变化请求即为转换。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611145334304.png" alt="image-20210611145334304" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611145251103.png" alt="image-20210611145251103" style="zoom:50%;" />
<blockquote>
<p>X-Real-Ip非RFC官方规定的头，nignix里的。</p>
<p>Max-Forwards 代理服务器最大转发次数，Via指名经过的代理服务器名称及版本，Cache-Control：no-transform禁止代理服务器修改响应包体</p>
</blockquote>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611151227487.png" alt="image-20210611151227487" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611152015637.png" alt="image-20210611152015637" style="zoom:50%;" />
<p>请求的上下文</p>
<p>User-Agent ：指名客户端类型</p>
<p>Referer:来自某一页面的请求自动添加的头部，服务器端常用于统计分析、缓存优化、防盗链等功能</p>
<p>From：告诉服务器如何通过邮件联系到爬虫的负责人</p>
<p>响应上下文</p>
<p>Server：指明服务器上所用软件的信息,用于帮助客户端定位问题或者统计数</p>
<p>Allow:告诉客户端,服务器上该 URI 对应的资源允许哪些方法的执行 Allow: GET, HEAD, PUT</p>
<p>Accept-Ranges:告诉客户端服务器上该资源是否允许 range 请求 Accept-Ranges = bytes接收range请求  none相反</p>
<p>内容协商</p>
<p>每个 URI 指向的资源可以是任何事物,可以有多种不同的表述,例如一份文档可以有不同语言的翻译、不同的媒体格式、可以针对不同的浏览器提供不同的压缩编码等。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611153755910.png" alt="image-20210611153755910" style="zoom:50%;" />
<p>协商要素</p>
<p>质量因子 q:内容的质量、可接受类型的优先级</p>
<p>媒体资源的 MIME 类型及质量因子（Accept: text/html,application/xhtml+xml）</p>
<p>字符编码:由于 UTF-8 格式广为使用, Accept-Charset 已被废弃 （Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7）</p>
<p>内容编码:主要指压缩算法（Accept-Encoding: gzip, deflate）</p>
<p>表述语言（Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7）</p>
<p>internationalization(i18n,i  和  n  间有  18  个字符) 指设计软件时,在不同的国家、地区可以不做逻辑实现层面的修改便能够以不同的语言显示</p>
<p>localization(l10n,l  和  n  间有  10  个字符) 指内容协商时,根据请求中的语言及区域信息,选择特定的语言作为资源表述</p>
<p>资源表述的元数据头部</p>
<p>媒体类型、编码content-type: text/html; charset=utf-8</p>
<p>内容编码• content-encoding: gzip</p>
<p>语言Content-Language: de-DE, en-CA</p>
<p>HTTP 包体:承载的消息内容• 请求或者响应都可以携带包体• HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ] • message-body = *OCTET:二进制字节流• 以下消息不能含有包体• HEAD 方法请求对应的响应• 1xx、204、304 对应的响应• CONNECT 方法对应的 2xx 响应</p>
<p>发送 HTTP 消息时两种传输 HTTP 包体的方式</p>
<p>已确定包体的全部长度，使用 Content-Length 头部明确指明包体长度（10进制），不能写错</p>
<p>不能确定包体的全部长度，使用 Transfer-Encoding 头部指明使用 Chunk 传输方式。Content-Length 头部应被忽略</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611160524934.png" alt="image-20210611160524934" style="zoom:50%;" />
<p>multipart(RFC1521):一个包体中多个资源表述</p>
<p>Content-type 头部指明这是一个多表述包体，Content-type: multipart/form-data; boundary=----WebKitFormBoundaryRRJKeWfHPGrS4LKe</p>
<p>Boundary 分隔符的格式boundary := 0*69<bchars> bcharsnospace • bchars := bcharsnospace / &quot; &quot; • bcharsnospace := DIGIT / ALPHA / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;+&quot; / &quot;_&quot; / &quot;,&quot; / &quot;-&quot; / &quot;.&quot; / &quot;/&quot; / &quot;:&quot; / &quot;=&quot; / &quot;?&quot;</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611205116993.png" alt="image-20210611205116993" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611211036459.png" alt="image-20210611211036459" style="zoom:50%;" />
<p>拿之前的Etag做指纹去请求，未失效/修改则继续返回数据，否则返回412错误（服务端的数据发生变化）。</p>
<p>服务器响应range请求：</p>
<p>服务器不支持range请求时返回200 ok，支持时返回状态码 206 Partial Content   Content-Range：bytes 300-500/1000  Content-Range: bytes 500-600/* （a-b/完整大小 未知用*）</p>
<p>范围错误时返回416 Range Not Satisfiable</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210611212825096.png" alt="image-20210611212825096" style="zoom:50%;" />
<p>boundary 分隔符和表单提交一样，分割时 前-- ，结尾时 --前后--</p>
<p>Cookie 是保存在客户端、由浏览器维护、表示应用状态的  HTTP 头部</p>
<p>存放在内存或者磁盘中，服务器端生成 Cookie 在响应中通过Set-Cookie 头部告知客户端(允许多个 Set-Cookie 头部传递多个值) ，客户端得到 Cookie 后,后续请求都会自动将 Cookie 头部携带至请求中</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619183506361.png" alt="image-20210619183506361" style="zoom:50%;" />
<p>Cookie 头部中可以存放多个 name/value 名值对，Set-Cookie  头部一次只能传递  1  个  name/value  名值对,响应中可以含多个头部</p>
<p>Cookie 在协议设计上的问题？</p>
<ol>
<li>Cookie 会被附加在每个 HTTP 请求中,所以无形中增加了流量</li>
<li>由于在 HTTP 请求中的 Cookie 是明文传递的,所以安全性成问题(除非用 HTTPS)</li>
<li>Cookie 的大小不应超过 4KB,故对于复杂的存储需求来说是不够用的</li>
</ol>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619184311413.png" alt="image-20210619184311413" style="zoom:50%;" />
<p>支持双向通讯的 WebSocket</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619184642156.png" alt="image-20210619184642156" style="zoom:50%;" />
<p>长连接的心跳保持</p>
<p>HTTP 长连接只能基于简单的超时(常见为 65 秒)</p>
<p>WebSocket 连接基于 ping/pong 心跳机制维持</p>
<p>兼容 HTTP 协议，默认使用 80 或者 443 端口，协议升级，代理服务器可以简单支持。基于帧:不是基于流(HTTP、TCP)  每一帧要么承载字符数据,要么承载二进制数据。</p>
<p>URI格式：</p>
<p>默认 port 端口 80 ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</p>
<p>默认 port 端口 443 wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</p>
<p>客户端提供信息：host 与 port:主机名与端口• shema:是否基于 SSL • 访问资源:URI • 握手随机数:Sec-WebSocket-Key • 选择子协议: Sec-WebSocket-Protocol • 扩展协议: Sec-WebSocket-Extensions • CORS 跨域:Origin</p>
<p>1 条消息由 1 个或者多个帧组成,frame头有opcode =8关闭帧</p>
<p>心跳帧：可以插在数据帧中传输：ping 帧 opcode=9  可以含有数据； pong 帧 opcode=A  必须与 ping 帧数据相同</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619185513649.png" alt="image-20210619185513649" style="zoom:50%;" />
<figure data-type="image" tabindex="2"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210610221234379.png" alt="image-20210610221234379" loading="lazy"></figure>
<p>每一层都可以添加头部，物理层是比特流，link链路层是frame，网络层packet加ip头，连接层sequence/datagram加tcp头，应用层http加头部</p>
<p>隐藏data urls：隐藏（ css/base64图片等小文件嵌入到html中以减少http请求数的）data urls。</p>
<p>domain: (*)按域名，is:running websocket资源 is:from-cache缓存的资源 larger-than:大于bit的资源</p>
<p>method:http方法的资源 mine-type:mime类型的资源 多过滤条件加空格并列</p>
<p>连接的上下游：按住shift红色下游，绿色上游</p>
<p>DNS：把可读的域名与IP地址进行映射的数据库，递归查询先根域名服务器com 后权威域名服务器baidu</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613144056200.png" alt="image-20210613144056200" style="zoom:50%;" />
<p>DNS报文：查寻与响应 query查寻域名 response返回IP地址 DNS请求与响应用的是UDP</p>
<p>HTTP1.1重复传输的体积巨大的 HTTP 头部</p>
<p>HTTP/2 (借鉴了SPDY)主要特性</p>
<ol>
<li>传输数据量的大幅减少：以二进制方式传输、HPACK 头部压缩压缩算法:Huffman 编码</li>
<li>多路复用：消息优先级</li>
<li>服务器消息推送：并行推送</li>
<li>应用层下的TLS层</li>
</ol>
<p>HTTP2.0的TCP+TLS 建链握手过多、多路复用与 TCP 的队头阻塞问题</p>
<p>HTTP3/QUIC协议，UDP 报文:先天没有队列概念，解决了握手过多、队头阻塞问题</p>
<p>HTTP3在1RTT 完全握手，在0RTT 恢复会话握手。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619191802310.png" alt="image-20210619191802310" style="zoom:50%;" />
<p><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619190739776.png" alt="image-20210619190739776" style="zoom:50%;" /><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619190829293.png" alt="image-20210619190829293" style="zoom:50%;" /></p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210619190914482.png" alt="image-20210619190914482" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613204537171.png" alt="image-20210613204537171" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613222750330.png" alt="image-20210613222750330" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613222840024.png" alt="image-20210613222840024" style="zoom:50%;" />
<p>TLS设计目的：身份验证、保密性、完整性</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613222623395.png" alt="image-20210613222623395" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613225106463.png" alt="image-20210613225106463" style="zoom:50%;" />
<p>拿到公钥有两种方式：通过PKI（Public Key Infrastrucure公钥基础设施）第三方、建立连结后先进行一次握手，把公钥给过来</p>
<p>RSA算法早期用在tsl握手中传递对称密钥，先在常用做生成ca证书</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210613231139689.png" alt="image-20210613231139689" style="zoom:50%;" />
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/image-20210615153258583.png" alt="image-20210615153258583" style="zoom:50%;" />
<p>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。被点分隔为四个部分，每个部分 8 个 bit，共 32 位。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/IP%E5%88%86%E7%B1%BB.jpg" alt="IP分类" style="zoom:75%;" />
<p><strong>无类型域间选路</strong>，简称<strong>CIDR</strong>将 32 位的 IP 地址一分为二，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。如10.100.122.2/24，这种地址表示形式，就是 CIDR。斜杠后面数字 24指：32 位中，前 24 位是网络号，后 8 位是主机号。</p>
<p>伴随着 CIDR 存在的，一个是<strong>广播地址</strong>，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是<strong>子网掩码</strong>，255.255.255.0。</p>
<p><strong>子网掩码</strong></p>
<p>IP地址与子网掩码通过二进制的与运算（AND：非同时为1皆为0）</p>
<p>1.用来判断出IP地址的网络号和主机号位数</p>
<p>2.用来判断两台机器是否在同一子网，不在同一个子网的两个机器需要通信必须借助路由器。</p>
<ul>
<li>A类IP的子网掩码默认为：255.0.0.0</li>
<li>B类IP的子网掩码默认为：255.255.0.0</li>
<li>C类IP的子网掩码默认为：255.255.255.0</li>
</ul>
<p>人为指定子网掩码为：225.225.255.240（11111111.11111111.11111111.11110000）时，00000000-00001111间的主机才在同一子网如200.67.83.3(0011)和200.67.83.14(1110) 分别与上225.225.255.240（11111111.11111111.11111111.11110000）在同一子网，200.67.83.13(00001101)和200.67.83.77(00101101)不在同一子网。</p>
<p><strong>广播地址</strong></p>
<p>广播的覆盖范围就是其所在网络号下的所有主机号，把主机号所在的二进制位全部变为1即可得到广播地址，如192.168.211.32/24的广播地址为：192.168.211.255</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80.jpg" alt="私有地址" loading="lazy"></figure>
<p>IP 分公有的 IP 和私有的 IP。公有 IP 地址通过组织统一分配。 192.168.0.x 是最常用的私有 IP 地址，一般你家里地上网设备不会超过 256 个，所以 /24 的CIDR基本就够了，明显看出 192.168.0 是网络号，后面是主机号。而整个网络里面的第一个地址 192.168.0.1就是你这个私有网络的出口地址，私有网络路由器的地址就是 192.168.0.1，而 192.168.0.255 就是广播地址。</p>
<p>当CIDR斜杠后不是 8 的整数倍时，如16.158.165.91/22</p>
<p>变成二进制来看，22位网络号，16.158不变占16位，165转换二进制为&lt;10100101&gt;，取前6位和之前的16位凑齐22位网络号即16.158.&lt;101001&gt;，后边的&lt;01&gt;和 .91组成10位机器号。</p>
<p>第一个地址是 16.158.&lt;101001&gt;&lt;00&gt;.1，即 16.158.164.1（网络号.1）</p>
<p>子网掩码是 255.255.&lt;111111&gt;&lt;00&gt;.0，即 255.255.252.0。</p>
<p>广播地址为 16.158.&lt;101001&gt;&lt;11&gt;.255，即 16.158.167.255。</p>
<p>lo 全称是<strong>loopback</strong>，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p>
<p>**一个网络包要从一个地方传到另一个地方，要有确定的地址（ip），还需要有定位功能。**MAC 地址更像是身份证，是一个唯一的标识，MAC 地址的通信范围比较小，局限在一个子网里面。如从 192.168.0.2/24 访问 192.168.0.3/24 是可以用 MAC 地址的。一旦跨子网，即从 192.168.0.2/24 到 192.168.1.2/24，MAC 地址就不行了，需要 IP 地址起作用。CIDR 可以用来判断是不是本地人。</p>
<p>MTU  最大传输单元MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p>
<p><strong>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。要去的这个地址和我是一个网段的，它才会发送 ARP 请求</strong>如果配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。网关要和当前的网络至少一个网卡是同一个网段。</p>
<p><strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。**如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。**DHCP 协议主要是用来给客户租用 IP 地址，要通过广播商谈、签约、续租。</p>
<p><strong>Hub集线器</strong>采取的是广播的模式连结主机，临如下问题</p>
<ol>
<li>这个包是发给谁的？谁应该接收？Mac地址</li>
<li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？Mac媒体访问控制</li>
<li>如果发送的时候出现了错误，怎么办？crc</li>
</ol>
<p><strong>MAC</strong>的全称是<strong>Medium Access Control</strong>，即**媒体访问控制，<strong>其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。即多路访问</strong></p>
<ul>
<li>分多个车道。作<strong>信道划分；</strong></li>
<li>今天单号出行，明天双号出行，作<strong>轮流协议；</strong></li>
<li>有事就出门，发现特堵，就回去。错过高峰再出。我们叫作**随机接入协议。**以太网，用的就是这个方式</li>
</ul>
<p><strong>链路层地址</strong>主要解决媒体接入控制的问题，所以称为<strong>MAC 地址</strong></p>
<p>IP 数据包，开始就是目标的 MAC 地址和源的 MAC 地址。接下来是<strong>类型</strong>。然后IP 里面层层封装 TCP/UDP、HTTP 等。发送时IP数据包在链路上广播，然后目标 MAC 地址发现<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/IP%20%E6%95%B0%E6%8D%AE%E5%8C%85.jpg" alt="IP 数据包" loading="lazy"></p>
<p>当不知道目标 MAC 地址时目标 MAC 地时，通过<strong>ARP 协议</strong>，即已知目标 IP 地址，求目标MAC 地址的协议，当知道了 目标IP 地址，不知道 MAC 地址，发出广播，谁是这个 IP 谁来应答。为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。</p>
<p><strong>交换机switch</strong>是局域网内主机交换数据的设备，有 MAC 地址学习能力的，维持一个记录目的地址Mac地址的 <strong>转发表</strong> ，新的ARP 请求后，转发表有了记录，下次再去目标Mac地址，便不需APR广播。</p>
<p><strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p>
<p>当交换机数目肯定越来越多，整个拓扑结构复杂，出现<strong>环路问题</strong> 。数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为<strong>图</strong>。将图中的环破了，就生成了<strong>树</strong>。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。</p>
<ul>
<li>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</li>
<li>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li>
</ul>
<p>ping 是基于 ICMP 协议工作的。<strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>,ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。<strong>类型字段</strong>，请求为8响应为0；<strong>顺序号</strong>，区分连续 ping 的时候发出的多个数据包；为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/ping.jpg" alt="ping" style="zoom:50%;" />
<p>ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；ping 使用查询报文，Traceroute 使用差错报文。</p>
<p><strong>Traceroute 的第一个作用就是故意设置特殊的 TTL（time to live），来追踪去往目的地时沿途经过的路由器</strong>，<strong>还有一个作用是故意设置不分片，从而确定路径的 MTU</strong></p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/MAC%20%E5%A4%B4%E5%92%8C%20IP%20%E5%A4%B4.jpg" alt="MAC 头和 IP 头" style="zoom:50%;" />
<p>当要访问另一个 IP 地址的时候，先判断目标 IP 地址和当前机器的 IP 地址，是否在同一个网段（需要 CIDR 和子网掩码)。</p>
<p><strong>如果是同一个网段</strong> ，那就没网关什么事情，直接将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。</p>
<p><strong>如果不是同一网段</strong>，就需要发往默认网关 Gateway(<strong>将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC 头中，发送出去</strong>)。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个(如 192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24 或者 192.168.1.2/24)。</p>
<p><strong>网关往往是一个路由器</strong> <strong>是一个转发的设备</strong>把 MAC 头和 IP 头都取下来，根据里面的内容，看看接下来把包往哪里转发。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。网关也是一个处在跨局域网处的特殊主机（路由嵌入式系统软路由），也有IP和Mac地址。</p>
<p>**路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。**任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p>
<p>**静态路由，其实就是在路由器上，配置一条一条规则。**每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳 IPX。</p>
<p><strong>MAC 地址是一个局域网内才有效的地址。<strong>MAC 地址只要过网关，就必定会改变，因为已经换了局域网。同时不改变 IP 地址的网关，我们称为</strong>转发网关；<strong>改变 IP 地址的网关，我们称为</strong>NAT 网关（Network Address Translation）</strong>。</p>
<p>转发网关，嵌套header里的IP和目标IP不变，只有Mac和目标Mac随每次从一个网关ip到另一个网关IP而变化（目标Mac依次为下一个网关的Mac地址）</p>
<p>每家都有家用路由器都是 192.168.1.x，当我们家里的包发出去的时候，都被家用路由器 NAT 成为了运营商的地址。一般就是整个办公室共用一个到两个出口 IP 地址。</p>
<ul>
<li>
<p>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</p>
</li>
<li>
<p>路由器是一个三层设备，里面有如何寻找下一跳的规则；</p>
</li>
<li>
<p>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</p>
</li>
<li>
<p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p>
</li>
</ul>
<p>动态路由根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。</p>
<ul>
<li>动态路由主流算法有两种，<strong>距离矢量路由</strong>（<strong>distance vector routing</strong>）算法基于 Bellman-Ford 算法产生外网路由协议**（<strong>Border Gateway Protocol</strong>，简称<strong>BGP</strong>）和链<strong>链路状态路由</strong>（<strong>link state routing</strong>）基于 Dijkstra 算法，产生OSPF （<strong>Open Shortest Path First</strong>，<strong>开放式最短路径优先</strong>）动态路由协议   即内部网关协议**（<strong>Interior Gateway Protocol</strong>，简称<strong>IGP</strong>）。</li>
</ul>
<p><strong>TCP 是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而<strong>UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</strong>不保证不丢失，不保证按顺序到达**</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/udp.jpg" alt="udp" style="zoom:50%;" />
<p>无论是 TCP 还是 UDP 包头里面应该有源端口号和目标端口号，根据端口号，将数据交给相应的应用程序。</p>
<ul>
<li>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</li>
</ul>
<p>链路层Mac叫帧，网络层IP叫包，传输层tcp叫段。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/tcp.jpg" alt="tcp" style="zoom:50%;" />
<p>TCP 双方都要维护各自的状态机。</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/tcp%E8%BF%9E%E7%BB%93.jpg" alt="tcp连结" style="zoom:50%;" /></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/tcp%E6%96%AD%E5%BC%80.jpg" alt="tcp断开" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/tcp%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt="tcp状态机" style="zoom:50%;" />
<p>TCP为了保证顺序性,按照 ID 一个个发送,采用<strong>累计确认</strong>或者<strong>累计应答</strong>（<strong>cumulative acknowledgment</strong>）。</p>
<p>TCP 里，接收端会给发送端报一个窗口的大小，叫<strong>Advertised window</strong>，超过这个窗口的，接收端做不过来，发送端就不能发送了。</p>
<p>Socket 编程进行的是端到端的通信</p>
<p>在网络层，Socket函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。<br>
在传输层，还要指定到底是 TCP 还是 UDP。TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p>
<p>TCP 的 Socket 就是一个文件流，在 Linux 中就是以文件的形式存在的，写读通过文件描述符。在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p>
<p>两端创建了 Socket 之后，接下来的过程中，TCP 和 UDP 稍有不同。</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/sockettcp.jpg" alt="sockettcp" style="zoom:50%;" /></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/socketudp.jpg" alt="socketudp" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。</p>
</li>
<li>
<p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听，这个时候客户端就可以发起连接了。</p>
<p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p>
</li>
<li>
<p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p>
</li>
<li>
<p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p>
<p>监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听 Socket</strong>，一个叫作<strong>已连接 Socket</strong>。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据。</p>
</li>
</ol>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p>
<p><strong>socket最大连接数</strong>:系统会用一个四元组来标识一个 TCP 连接<code>{本机 IP, 本机端口, 对端 IP, 对端端口}</code>只有客户端的 IP 和客户端的端口是可变的。</p>
<p>1.多进程方式：在 Linux 下，创建子进程使用 fork 函数。这是在父进程的基础上完全拷贝一个子进程（在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程，根据 fork 的返回值来区分到底是父进程（其他整数即子进程id），还是子进程（0））</p>
<p>2.多线程方式：在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。比多进程更轻量，但一直创建很多进程或者线程操作系统是无法承受的。</p>
<p>3.IO 多路复用，一个线程维护多个 Socket：<strong>一个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，调用 select 函数来监听文件描述符集合是否有变化</strong>。数量由 FD_SETSIZE 限制,一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。每次 Socket 所在的fd_set中有 Socket 发生变化的时候，都需要通过轮询的方式。</p>
<p>4.IO 多路复用,事件通知:epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p>
<p>当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。</p>
<p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题(（即单机1万个并发连接问题）)的利器</strong>。</p>
<p>目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。</p>
<p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头。HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</p>
<p>对称加密：加密和解密使用的是同一个密钥。</p>
<p>非对称加密：客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p>
<p>数字证书：如何将非对称加密的公钥给对方？由<strong>CA</strong>（ <strong>Certificate Authority</strong>）颁发的称为<strong>证书</strong>（<strong>Certificate</strong>）：里面有<strong>公钥</strong>，证书的**所有者、发布机构、证书有效期、签名算法，CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。**root CA层层授信背书，CA 证书的作用，是保证服务器的公钥的来历。</p>
<p>你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。不是伪装钓鱼的公钥。</p>
<p>无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p>
<img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/https.jpg" alt="https" style="zoom:50%;" />
<ul>
<li>
<p>加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。</p>
</li>
<li>
<p>非对称加密需要通过证书和权威机构来验证公钥的合法性。</p>
</li>
<li>
<p>HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。</p>
</li>
<li>
<p>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</p>
</li>
<li>
<p>压缩好的数据，为了传输组成一系列 NALU<strong>网络提取层单元</strong>（<strong>NALU</strong>，<strong>Network Abstraction Layer Unit</strong>），按照帧和片依次排列；</p>
</li>
<li>
<p>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输；</p>
</li>
<li>
<p>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。</p>
</li>
</ul>
<p><code>www.example.com. IN A 139.18.28.5;</code>DNS记录：</p>
<p>IN 代表记录用于互联网，是 Intenet 的缩写</p>
<p>A 代表IPv4地址 AAAA IPv6地址</p>
<p>CNAME用于定义域名的别名：将一个域名映射到另一个域名。</p>
<ul>
<li>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</li>
<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>
<li><strong>HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。</strong></li>
<li>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</li>
<li>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</li>
</ul>
<p>内容分发网络（Content Dilivery Network，CDN）是一个专门用来分发内容的分布式应用，CDN 构建在现有的互联网之上，通过在各地部署数据中心，让不同地域的用户可以就近获取内容。内容通常指的是文件、图片、视频、声音、应用程序安装包等静态资源。很多大型的应用，会把 DNS 解析作为一种负载均衡的手段。</p>
<p>能集中提供这些静态资源呢？这和域名系统的 DNS 记录不能集中提供是一个道理，需要考虑到流量、单点故障、延迟等因素。在离用户更近的地理位置提供资源，可以减少延迟。按照地理位置分散地提供资源，也可以降低中心化带来的服务压力。</p>
<p>当用户请求一个静态资源的时候，首先会触发域名系统的解析。域名系统会将解析的责任交由 CDN 提供商来处理，CDN 的智能 DNS 服务会帮助用户选择离自己距离最近的节点，返回这个节点的 A（或 AAAA）记录。然后客户端会向 CDN 的资源节点发起请求，最终获得资源。</p>
<ul>
<li><strong>有了 CDN 之后，情况发生了变化</strong>。在 web.com 这个权威 DNS 服务器上，会设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.web.cdn.com">www.web.cdn.com</a>，返回给本地 DNS 服务器。</li>
</ul>
<p>CDN 回源就是 CDN 节点到源站请求资源，重新设置缓存。通常服务提供方在使用 CDN 的时候，会在自己的某个域名发布静态资源，然后将这个域名交给 CDN。</p>
<blockquote>
<p>比如源站在 s.example.com 中发布静态资源，然后在 CDN 管理后台配置了这个源站。在使用 CDN 时，服务提供方会使用另一个域名，比如说 b.example.com。然后配置将 b.example.com 用 CNAME 记录指向 CDN 的智能 DNS。这个时候，如果用户下载b.example.com/a.jpg，CDN 的智能 DNS 会帮用户选择一个最优的 IP 地址（最优的 CDN 节点）响应这次资源的请求。如果这个 CDN 节点没有 a.jpg，CDN 就会到 s.example.com 源站去下载，缓存到 CDN 节点，然后再返回给用户。</p>
<p>CDN 回源有 3 种情况，一种是 CDN 节点没有对应资源时主动到源站获取资源；另一种是缓存失效后，CDN 节点到源站获取资源；还有一种情况是在 CDN 管理后台或者使用开放接口主动刷新触发回源。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity启动模式]]></title>
        <id>https://Joshua-Chang.github.io/post/activity-qi-dong-mo-shi/</id>
        <link href="https://Joshua-Chang.github.io/post/activity-qi-dong-mo-shi/">
        </link>
        <updated>2021-06-06T09:51:42.000Z</updated>
        <content type="html"><![CDATA[<p>按下RecentTask键时，显示出一个个的Task。我们可以在最近的Task间切换。<br>
当我们在某个app内，不停按返回键，直到Task里最后一个Activity被关闭，Task的生命结束。但作为最近的Task，他在RecentTask里并不会消失，仍保留一个残影等待重新打开app。（RecentTask里看到的task未必是存活的）</p>
<p>不仅activity在Task内可以叠成栈，不同task也可以叠成栈。但task的叠加只在前台；一旦进入后台task就不再叠加，并拆开成不同Task。进入后台的场景有按home回到桌面、按recentTask查看最近Task。</p>
<ol>
<li>
<p>standard：Activity与启动它的Task相关。在不同Task中打开同一个Activity，Activity会被创建多个实例，分别放进每一个Task顶，互不干扰。<br>
从A app中打开B app里的Activity时，该Activity会直接放到A的task顶。对于B的task没影响。</p>
<p>短信app里点击号码添加联系人，通讯录app的添加联系人Activity被打开，放到短信app所在栈的栈顶，对通讯录app没影响。</p>
</li>
<li>
<p>singleTop：和standard一样，只有会复用Task顶的Activity并<code>onNewIntent</code>，而不必创建新的实例。<br>
从A app中打开B app里的Activity时，只有当A Task顶的Activity的刚好是准备要打开的activity时，才不在栈顶创建该Activity，而是复用之前打开的并<code>onNewIntent</code></p>
</li>
</ol>
<blockquote>
<p>假设主界面为 MainActivity，显示新闻的界面是 DetailActivity，显然显示任何一条新闻都会使用 DetailActivity，即把新闻内容通过 Intent 传给 DetailActivity 就可以了。 假设你正在看新闻1(即在 DetailActivity)，此时手机收到服务器的推送：收到一条通知(新闻2)，点击通知就会跳转到 DetailActivity 并显示新闻2，当你点击通知时，因为目前栈顶的 Activity 就是 DetailActivity，因此这里就是使用 SingleTop 的地方，即点击通知后以 SingleTop 加载模式打开 DetailActivity 并显示新闻2，因此新闻1的 DetailActivity 就被覆盖掉了。 此后你点击返回键会回到主界面。</p>
<p>OnNewIntent</p>
<p>针对网易新闻这个案例来看，DetailActivity一般是一个webView,然后 根据上一个页面（新闻列表）传过来的url展示对应的网页，“通知“也是一样的。都是通过intent把url传到DetailActivity。以下一段代码简单的模拟DetailActivity 接收数据的过程。</p>
</blockquote>
<p>standard、singleTop都是直接在原Task上新建或复用，而singleTask、singleInstance是跨Task打开Activity(过渡时原生有应用间切换动画)。</p>
<ol start="3">
<li>
<p>singleTask：Activity被其他的Task启动的时候：不会直接放到启动他的Task栈顶，而是在自己的Task的栈顶；同时把自己的Task叠加到启动它的Task上(不同task过渡时原生有应用间切换动画)。连按返回键时，退出完自己的task，再退(过渡动画)启动它的task。</p>
<p>第一步：<strong>将被启动Activity放到被启动Task顶部</strong>：没有原Task(外部app未启动)则新开一个；有task但其内没有要启动的Activity(要启动的外部Activity所在的app已启动，但该Activity不在栈内，即没被启动过)则将被启动的Activity放到所在Task栈顶；有task且task内有要启动的Activity时推到栈顶，上边的被推出。</p>
<table>
<thead>
<tr>
<th>没有将被启动的Task(所在app未启动)</th>
<th>有将被启动的Task</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>被启动的activity放入新的task？</td>
<td>将被启动的Activity不在task内(activity未被启动)</td>
<td>在task内</td>
</tr>
<tr>
<td>被启动的activity再启动其他Activity</td>
<td>将被启动的Activity放到Task栈顶 (其他Activity在下)</td>
<td>把顶部推出</td>
</tr>
<tr>
<td>要看被启动者具体的启动模式</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>第二步：<strong>将被启动的task移动到当前task顶</strong>。</p>
<p>被启动的Activity原本的Task里，把Activity推到栈顶并<code>onNewIntent</code>刷新数据，<strong>Activity原来上边的会被推出</strong>。原来还没有task，新开一个Task。<br>
特殊情况：Activity被其他的Task启动后，Activity原task叠加在启动它的task上，此时按下home/recentTask从前台切后台，两个task不再叠加，都出现在recentTask里，在Activity原本的Task栈顶回退不会退到启动他的Task。</p>
<p>短信app里点击邮箱发送邮件，邮箱app的编写邮件Activity被打开。此时回退：会先回退邮箱app打开的页面，再回退短信app的页面。若先按recentTask则发现两个app都出现在最近Task里，再在邮箱里回退不会到短信里。</p>
<p>设置<code>android:allowTaskReparenting=&quot;true&quot;</code> 能回到其原来的父Task，的Activity也有类似效果。Activity被其他的Task启动的时候，会把Activity从原来的Task，移到当前Task栈顶（但不像standard到处创建）。直接回退时不会有切换task动画，切后台再回退也不会。若不回退而是打开原来Task，Activity又回移动回原来Task的额栈顶，再切回启动他的Task时Activity不在里边。</p>
<p>singleTask：只有一个Task里有这个Activity（不同于standard）<strong>唯一性</strong>。</p>
</li>
<li>
<p>singleInstance：比singleTask更严厉，Task里只有一个Activity，要求<strong>独占性</strong>。当Activity被其他的Task启动的时候，把Activity单独放进一个Task（没Task新建后可复用触发<code>onNewIntent</code>），并叠加到启动它的Task上（切换动画）。连续退出也是task切换，若切后台也拆成俩Task。<br>
Home切后台后。若从桌面进入Activity所在的app，原来task的Activity消失（在同TaskAffinity被隐藏的单Activity的task里。此时在recentTask看不见的Task未必被杀死，可能同TaskAffinity被隐藏）。<br>
recentTask切后台后。若进入只有一个Activity的task退一次就回到桌面。</p>
<p>若Activity被其他的Task启动，（没切后台）成为一个单Activity的Task叠加到启动他的Task上，（没切后台）再从单Activity的Task启动另一个Activity，新启动的Activity所在的Task（可以是最初Activity的原Task也无所谓，真是这样原task成了俩task叠在一起），会在单Activity的Task上继续叠加。</p>
</li>
<li>
<p>TaskAffinity：Task相关性。默认情况下一个app只有一个Task在recentTask显示。recentTask根据不同的TaskAffinity列出不同的任务，当多个task有相同TaskAffinity时recentTask显示最近前台展示的一个recent的。</p>
<p>每个Activity有TaskAffinity<code>&lt;activity&gt;默认取&lt;application&gt;的，默认取包名</code>所以默认一个task在recentTask里；<br>
每个Task也有TaskAffinity取自栈底的Activity的TaskAffinity（第一个启动的Activity的TaskAffinity）。</p>
<p>若新打开的Activity设置了singleTask，则系统要比较Activity和当前Task的TaskAffinity是否相同，相同则在当前task入栈；不同则去寻找TaskAffinity相同的task入栈，没有则新建一个Task。</p>
<p>所以在打开一个配置了singleTask的Activity时。若是外部app的，TaskAffinity不同，发送task切换；若是app自己的，TaskAffinity相同，则进入栈顶，前面被推出。若给这个Activity设置一个独立的TaskAffinity，哪怕是在同一个app内也会被拆到另一个task里，若这个独立的TaskAffinity恰好与其他app的一样，这个Activity甚至会被放到别人的app的task里。</p>
</li>
</ol>
<p><code>adb shell dumpsys activity</code>可查看task与activity关系。<code>getRunningTasks</code>等方法早被屏蔽</p>
<pre><code class="language-kotlin">val ams = getSystemService(ActivityManager::class.java)
for (task in ams.appTasks) {
    Log.e(TAG, &quot;${task.taskInfo.numActivities}:[${task.taskInfo.baseActivity?.className}-&gt;${task.taskInfo.topActivity?.className}]&quot;)
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1622973147070.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从MessageQueue视角理解Handler]]></title>
        <id>https://Joshua-Chang.github.io/post/cong-messagequeue-shi-jiao-li-jie-handler/</id>
        <link href="https://Joshua-Chang.github.io/post/cong-messagequeue-shi-jiao-li-jie-handler/">
        </link>
        <updated>2021-04-23T12:09:57.000Z</updated>
        <content type="html"><![CDATA[<p><em>本文适合对Handler有过了解，~~即使又忘了。~~但对网上的&lt;&lt;loop轮询转圈图&gt;&gt;有点印象的玩家。</em></p>
<p><strong>前置概念</strong></p>
<hr>
<p><strong>同步屏障消息</strong></p>
<ol>
<li>作用：系统使用的特殊的消息，可以看作优先处理异步消息的标识，当MessageQueue的队首是<strong>同步屏障消息时</strong>，忽略同步消息，一直执行最近的异步消息。通过<code>postSyncBarrier</code>/<code>removeSyncBarrier</code>增删同步屏障消息，非手动移除不会自动移除。</li>
<li>特点：<code>target</code>属性为空的<code>Message</code>就是同步屏障消息</li>
<li>事例：<code>ViewRootImpl.scheduleTraversals</code> 优先处理异步消息</li>
</ol>
<p><strong>IdleHandler</strong></p>
<ol>
<li>作用：闲时<code>Handler</code>，在没有消息或消息未到触发时机这样的闲时，执行的操作。</li>
<li>特点：是<code>MessageQueue</code>的静态接口，使用时复写<code>boolean queueIdle()</code>的方法执行闲时操作，返回值表示执行后是否保持存活状态。<br>
<strong>epoll</strong></li>
</ol>
<p><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></p>
<p><strong>正文</strong></p>
<hr>
<p><em>废话一下基本原理先</em></p>
<p>使用者通过<code>Handler</code>外部暴露的方法，向处于目标线程<code>TLS</code>的<code>Looper</code>内的消息队列输入消息；</p>
<p>消息队列及时/延时地取出消息，并分发处理。以达到调度或延时地操作。</p>
<p><code>Handler</code>通过<code>MessageQueue.enqueueMessage(msg,when)</code>入队消息</p>
<p><code>Looper.loop</code>通过<code>MessageQueue.next()</code>出队消息</p>
<h2 id="messagequeue">MessageQueue</h2>
<p>MessageQueue的关键变量<code>mMessages</code>：</p>
<p>消息队列实例，把消息根据触发时机早晚排列。具体代码表现为单链表的节点，代指队首（链表头）消息。</p>
<pre><code class="language-mermaid">graph LR
1[A 延迟:1s]--next--&gt;2[B 延迟:2s]--next--&gt;3[C 延迟:3s]--next--&gt;5[D 延迟:5s]
</code></pre>
<p><strong>入队出对</strong></p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9898b6b674c646eb9b9fa60b69be3714~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.10.15.png" style="zoom:50%;" />
<ol>
<li>入队方法<code>enqueueMessage()</code>，往队列存延迟触发的消息，并根据触发时间排好队。</li>
<li>出队方法<code>next()</code>一直死循环遍历队列，有到达触发时机的消息就取出消息。</li>
</ol>
<p><strong>阻塞/休眠</strong>：</p>
<p>怎么能让入队消息的延迟触发呢？</p>
<pre><code>先阻塞住next()方法，让其无法取消息。时间到了，在把阻塞恢复，取出消息即可。
</code></pre>
<p>队列内根本没消息，出队方法还一直死循环取消息，怎么办？</p>
<pre><code>没消息也阻塞住next()方法，让其无法取消息。有新消息插入时，再通知他去取。
</code></pre>
<table>
<thead>
<tr>
<th>队内的下条消息还有很久才到触发时机：先阻塞。</th>
<th>队内的根本没有消息：一直休眠到有消息。</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a84eb0ae8f54979815597c85ec0db50~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.21.31.png" style="zoom: 33%;" /></td>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426a3ab271e54dcaa5c8a6df04dcdab5~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.22.27.png" style="zoom: 33%;" /></td>
</tr>
</tbody>
</table>
<p><strong>具体做法</strong></p>
<p><code>next()</code>的取消息死循环中用<code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>阻塞/休眠。</p>
<ul>
<li>消息的触发时机未到时，阻塞到触发时机到为止；</li>
<li>队列内一直没消息时，休眠直到有新消息入队，再用<code>enqueueMessage()</code>内的<code>nativeWake(mPtr)</code>唤醒。</li>
</ul>
<blockquote>
<p>本文中分别用<strong>阻塞</strong>和<strong>休眠</strong>只是做语义区分：是自己超时返回，还是被动触发唤醒。</p>
<p><code>nativePollOnce</code>传入的参数<code>timeout</code>通过JNI到Native层<code>Looper::pollOnce</code>-&gt;<code>Looper::pollInner</code> -&gt;<code>epoll_wait</code>方法。</p>
<p><code>epoll_wait</code>用 <code>epoll_create</code>创建的文件描述符A，去监听管道读取端文件描述符B的事件(使用<code>epoll_ctl</code>添加)。</p>
<ul>
<li>timeout&gt;0时，监听时长超过这个<code>timeout</code>仍没有事件就返回，中断阻塞。</li>
<li>timeout=-1，<code>epoll_wait</code>一直等待，直到新消息入队<code>enqueueMessage()</code>内<code>nativeWake(mPtr)</code>在Native层向管道写入端写入“W”，触发监听中断阻塞。同时清空管道数据。</li>
</ul>
<p>上边两种情形，都会给返回一种result，而<code>pollOnce</code>收到任何一种result都会退出。</p>
<p>epoll I/O复用机制是用一个文件描述符监听多个文件描述符的事件。</p>
<p>Looper.prepare -&gt; new Looper -&gt; new MessageQueue-&gt;nativeInit-&gt;native层NativeMessageQueue构造方法中实例化Looper的构造方法中初始化管道和<code>epoll_create</code>    <code>nativeWake</code>最终也是<code>Looper.wake</code></p>
</blockquote>
<h2 id="出队">出队</h2>
<p><code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>方法参数<strong>nextPollTimeoutMillis</strong> (即下个消息的延迟时间的)取值情况。</p>
<table>
<thead>
<tr>
<th style="text-align:left">下个消息的延迟时间</th>
<th>消息队列内</th>
<th>阻塞情况</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&gt;0</td>
<td>延迟最近的消息，触发时机未到</td>
<td>阻塞到触发时机</td>
<td>释放cpu资源</td>
</tr>
<tr>
<td style="text-align:left">=0</td>
<td>延迟最近的消息，触发时机到了</td>
<td>不阻塞</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">=-1</td>
<td>根本没消息</td>
<td>休眠到有消息</td>
<td>释放cpu资源</td>
</tr>
</tbody>
</table>
<h3 id="流程解读">流程解读</h3>
<p><code>next()</code>出队方法，需要一个<code>Message</code>返回值。当<code>nativePollOnce</code>不再阻塞时，因为队列是按触发时机早晚排序的：</p>
<ol>
<li>
<p>通常应该取队首消息；</p>
</li>
<li>
<p>但是队首是同步屏障消息时【Barrier1】，应该取触发时机最近的异步消息。</p>
</li>
</ol>
<p>因此我们先取该msg，不管是队首还是最近异步，再判断是否应该将其返回和其他后续操作。</p>
<ul>
<li>
<p>当msg非空时【2】</p>
<ol>
<li>如果msg触发时机到达【3`】，则返回msg。（当然返回前要整理一下队列）</li>
<li>如果msg触发时机未到【3】，则重新计算触发时间，然后将 <strong>nextPollTimeoutMillis</strong> 设为新时间，然后像下文&quot;当msg为空时&quot;一样，进行是否有IdleHandler及对其处理的操作。【4】/【5，6】</li>
</ol>
</li>
<li>
<p>当msg为空时【2`】，先将 <strong>nextPollTimeoutMillis</strong> 设为-1</p>
<ol>
<li>如果也没有待处理的IdleHandler【4】：则跳出本次循环又回到<code>nativePollOnce</code>，此时<code>nextPollTimeoutMillis=-1</code>,阻塞至有新消息将其唤醒。</li>
<li>如果有待处理的IdleHandler：则遍历执行这些IdleHandler【5】（每次最多四个，执行其<code>queueIdle</code>回调），然后重置IdleHandler计数和<code>nextPollTimeoutMillis=0</code>完成本次循环【6】（<code>nextPollTimeoutMillis=0</code>让下次循环不再阻塞，以检查处理IdleHandler时是否又有新消息入队）。</li>
</ol>
</li>
</ul>
<pre><code class="language-java">Message next() {
    final long ptr = mPtr;/*MessageQueue 的native层地址*/
    if (ptr == 0) {//当消息循环已经退出,则直接返回
        return null;
    }
    int pendingIdleHandlerCount = -1; //待处理闲时handler数量
    int nextPollTimeoutMillis = 0;
    for (;;) {
        nativePollOnce(ptr, nextPollTimeoutMillis);//【1】阻塞：作用类似Java的 object.wait()
        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;/*next()的返回值：此时为队头消息，即最近消息*/
            if (msg != null &amp;&amp; msg.target == null) {//【Barrier1】如果队首是同步屏障消息，msg取最近的异步消息
		do {
                   prevMsg = msg;
                   msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());//msg不是异步消息时，从队头至队尾遍历每个消息，直到msg为异步消息才推出遍历
            }            
            if (msg != null) {//【2】取到待处理的msg
                if (now &lt; msg.when) {/*【3】时机未到：更新延迟时间*/
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {/*【3`】处理msg的时机已到：取出msg，并整理队列*/
                    mBlocked = false;/*是否被阻塞：设为false供存消息时用*/
                    if (prevMsg != null) {/*【Barrier1`】若msg是因同步屏障循，而取出的最近的异步消息，改变指针指向跳过msg*/
                        prevMsg.next = msg.next;
                    } else {/* 取出msg，更新下一条消息为队首*/
                        mMessages = msg.next;
                    }
                    msg.next = null;//即将作为返回值，next变得没意义，置空。
                    return msg;/* 返回next消息*/
                }
            } else {/*【2`】消息为空，即没有消息了*/
                nextPollTimeoutMillis = -1;/*没有消息了，nextPollTimeoutMillis设为-1。线程阻塞*/
            }
            
            /*------------------------------空闲handler处理----------------------------------*/
            /* Idlehandles仅在队列为空或队首消息时机未到时才运行*/
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();/*计算闲时任务量*/
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                mBlocked = true;/*【4】若经过计算上个if计算，连闲时Handler都没有，跳出本次循环*/
                continue;
            }
            if (mPendingIdleHandlers == null) {/*必有闲时任务待处理，否则上个if就continue出去了*/
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        /*【5】必有闲时Handler需要遍历执行。连闲时Handler都没有的情况，在上文的if中continue出去。*/
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
                //【5.1】执行IdleHandler的queueIdle方法，运行IdelHandler，例如处理日志上报 Gc等通过返回值由自己决定是否保持存活状态
               idler.queueIdle();
        }
	/*【6】执行完闲时Handler重置闲时计数和下次延迟时间*/
        pendingIdleHandlerCount = 0;
        // 因为执行闲时Handler(步骤【5】不在synchronized中)过程中，可能有新消息enqueue，需要重新检查。
        // 下次延迟时间置0，下次循环到步骤【1】时不阻塞。
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>
<h3 id="时序图">时序图</h3>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7364839512144d3aecb9f4cd54ea3d4~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午1.41.54.png" loading="lazy"></figure>
<h2 id="入队">入队</h2>
<p><strong>关键变量</strong><code>mBlocked</code>：源码上的注释翻译过来：出队方法<code>next()</code>是否被阻塞在<code>pollOnce()</code>处（<code>nextPollTimeoutMillis≠0</code>）。记录<code>pollonce</code>是否被阻塞的目的就是：<strong>是否需要唤醒</strong></p>
<p>外部暴露操作方法的<code>Handler</code>类下，<code>send(empty)Message/post</code> +<code>atTime/delay/AtFrontOfQueue</code>等操作的最终归宿。<br>
<code>enqueueMessage(Message msg, long when)</code>：插入<code>msg</code>入队，<code>when</code>是自系统启动以来的非休眠运行时间（毫秒）。</p>
<blockquote>
<p>拓展： 插入msg一个到队首。</p>
<pre><code class="language-java">public final boolean sendMessageAtFrontOfQueue(Message msg) {//同理post也有类似方法
 MessageQueue queue = mQueue;
 return enqueueMessage(queue, msg, 0);
}
private boolean enqueueMessage(MessagdsieQueue queue, Message msg,
     long uptimeMillis) {
 return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
</blockquote>
<p><code>enqueueMessage(Message msg, long when)</code>：插入<code>msg</code>入队，<code>when</code>是自系统启动以来的非休眠运行时间（毫秒）。</p>
<h3 id="流程解读-2">流程解读</h3>
<p>入队一个消息，流程参考存消息的情况图，并对照下边的代码。</p>
<h4 id="情况一">情况【一】</h4>
<p>队列为空、新消息是即时消息、新消息是延时最短消息时</p>
<p>入队的新消息插入到队头的情况：都需要<code>nativeWake</code>唤醒 出队的<code>pollonce</code></p>
<table>
<thead>
<tr>
<th><strong>a.队列内没消息</strong></th>
<th><strong>b.新入队的消息延时为0</strong></th>
<th>c.新入队的消息比队首的触发时机还早，与b类似</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d1b60d3dcd4231b7dc9f00bf54704d~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午4.42.24.png" style="zoom:33%;" /></td>
<td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5754fd2fe0ca4f1d88c26625ce245c27~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午4.43.42.png" style="zoom:33%;" /></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>通过改变队首消息和新消息的next指针指向，把消息插入。</li>
<li>是否需要唤醒<code>needWake = mBlocked</code>, 这时候出队<code>pollonce</code>处<strong>队列还没消息</strong>或<strong>最近消息时机未到</strong>，还被<strong>阻塞</strong>，<strong>mBlocked=true</strong>是必然的。然后<code>nativeWake</code>去唤醒<code>pollonce</code>去取刚存入的消息。</li>
</ol>
<h4 id="情况二">情况【二】</h4>
<p>新消息不是上述的情况，不插入到队首，而是插入到队列中部。先查找位置再插入。</p>
<table>
<thead>
<tr>
<th>队头是同步屏障消息</th>
<th>且插入的消息是最近的异步消息</th>
<th>插入的消息不是最近的异步消息</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751b07ecd9094d3192904c99ffdcada2~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午5.03.37.png" style="zoom:33%;" /></td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15bbb1919f144d41a8082677781ded3d~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午5.04.16.png" style="zoom:33%;" /></td>
</tr>
<tr>
<td>是否需要唤醒</td>
<td>需要唤醒</td>
<td>不需要唤醒</td>
</tr>
</tbody>
</table>
<p><strong>除非队头是同步屏障消息，插入的消息是最近的异步消息</strong>，其他多数插入到队列中部的情况都不需唤醒</p>
<p>是否需要唤醒的条件<code>needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</code></p>
<ol>
<li>出队<code>pollonce</code>处最近消息时机未到（经过上个if，队列现在非空），还被阻塞，<strong>mBlocked=true</strong>还是必然的。</li>
<li><code>p.target == null</code>队首p的target为空符合同步屏障消息特点。</li>
<li><code>msg.isAsynchronous()</code> 新插入队列中部的消息是异步消息。</li>
</ol>
<p>合起来<strong>唤醒条件</strong>就是：“<strong>队列内最近的消息触发时机未到，且队首消息是同步屏障消息时，新插入了一条异步消息</strong>”（还可能改变）。</p>
<p>然后再通过改变<code>next</code>指针指向，从队首至队尾遍历，查找合适的插入位置：</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb947d8d2954f5898eb54b66680b854~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午6.08.53.png" loading="lazy"></figure>
<ol>
<li><code>（when &lt; p.when）</code>即新消息触发时机早于该位置的触发时机，插入位置找到，跳出遍历。</li>
<li><code>p == null</code>遍历到末尾，新消息的触发时机比队内的消息都晚，插入位置为队尾，跳出遍历。</li>
<li>查找插入位置的过程中。如果发现异步消息，则新消息虽异步，但不是离触发最近的，无需唤醒。因此<strong>唤醒条件</strong>更新为：队首是同步屏障消息时，新插入的消息为<strong>离触发最近的异步消息</strong>。</li>
</ol>
<p>最后改变指针指向，把消息插入到对应位置。</p>
<pre><code class="language-java">boolean enqueueMessage(Message msg, long when) {    
    synchronized (this) {/*可能有多个不同线程发消息*/
        msg.when = when;
        Message p = mMessages;// p 赋值为队首。根据触发时机when 来排序
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
          //【一】插入头部并唤醒：1、队列为空时 2、新消息延时为0是即时消息 3、新消息延时比队首的更短
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;/*出队方法next是否被阻塞在pollOnce()处（nextPollTimeoutMillis≠0）*/
        } else {//【二】消息插入MessageQueue中间，一般不需唤醒线程。除非队首同步屏障，且msg为!最近的!异步消息
            //【二a】队首是同步屏障消息，且插入的msg是异步消息。
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                /*prev、p 从队列的0、1 一直增至 last、null，来寻找msg合适的插入位置*/
                if (p == null /*last.next=null 插入到末尾*/|| when &lt; p.when/*（队列的p.when越来越大1235，when=4）*/
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {//【二b】插入的msg是异步消息是最近的
                    //在寻找msg插入位置过程中发现异步消息。说明msg前还有更早的异步消息。msg虽异步、但非最近。不需唤醒
                     needWake = false;
                }
            }
            /*经过循环确定插入位置，将入队的msg插入到prev与p中间 （3-5之间）*/
            msg.next = p; 
            prev.next = msg;
        }
        if (needWake) {
            nativeWake(mPtr);//【三】唤醒线程，nativePollOnce不在阻塞
        }
    }
    return true;
}
</code></pre>
<h3 id="流程图">流程图</h3>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2adc6671993c4434b420e4f5d4e21811~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午8.15.15.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法思想]]></title>
        <id>https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-04/</id>
        <link href="https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-04/">
        </link>
        <updated>2021-03-13T06:46:53.000Z</updated>
        <content type="html"><![CDATA[<p>贪心算法、分治算法、回溯算法、动态规划是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p>
<h1 id="贪心算法">贪心算法</h1>
<p>贪心算法（greedy algorithm）有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。</p>
<p>贪心算法解决问题的步骤：</p>
<p>针对一组数据，定义了**限制值和期望值，**希望从中选出几个数据，在满足限制值的情况下，期望值最大。比如背包重量不超过 100kg，并且总价值最大。</p>
<ol>
<li><strong>当我们看到这类问题的时候，首先要联想到贪心算法。</strong></li>
<li><strong>再尝试看下这个问题是否可以用贪心算法解决</strong></li>
<li><strong>最后举几个例子看下贪心算法产生的结果是否是最优的</strong></li>
</ol>
<h2 id="分糖果">分糖果</h2>
<p>有 m 个糖果和 n 个孩子。糖果少，孩子多（m&lt;n），每个糖果的大小不等，且孩子对糖果大小要求不同，如何分配才能让更多孩子满足?</p>
<p>每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果</p>
<h2 id="钱币找零">钱币找零</h2>
<p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p>
<h2 id="区间覆盖">区间覆盖</h2>
<p>假设有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>
<p>假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上。按照起始端点从小到大的顺序对这 n 个区间排序。</p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p>
<h2 id="霍夫曼编码">霍夫曼编码</h2>
<p>假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>
<p>假设经过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。</p>
<p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，<strong>根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率</strong>。</p>
<p>由于霍夫曼编码是不等长的，解压缩时每次应该读取几位呢？</p>
<p>为了避免解压缩过程中的歧义，霍夫曼编码要求<strong>各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p>
<p>根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p>
<img src="https://static001.geekbang.org/resource/image/83/45/83921e609c8a4dc81ca5b90c8b4cd745.jpg" alt="  " style="zoom:50%;" />
<p>如何给不同频率的字符选择不同长度的编码呢？</p>
<p>首先，把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>
<p>然后，给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/7b/7a/7b6a08e7df45eac66820b959c64f877a.jpg" alt="  " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/cc/ed/ccf15d048be005924a409574dce143ed.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1 id="分治算法">分治算法</h1>
<p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p>
<p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>分治算法一般都比较适合用递归来实现：</p>
<ul>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题。</li>
</ul>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li>原问题与分解成的小问题具有<strong>相同的模式；</strong></li>
<li>原问题分解成的<strong>子问题可以独立求解</strong>，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>
<li>具有<strong>分解终止条件</strong>，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个<strong>合并操作的复杂度不能太高</strong>，否则就起不到减小算法总体复杂度的效果了。</li>
</ul>
<p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢</strong>？</p>
<p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p>
<p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。这样操作的时间复杂度是 O(n^2)。</p>
<p>用分治算法。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>
<p>借助归并排序算法，快速计算出两个子问题 A1 与 A2 之间的逆序对个数。归并排序算法中将两个有序的小数组，合并成一个有序的数组，每次合并操作，都计算逆序对个数然后求和就是整个数组的逆序对个数。</p>
<p><strong>分治算法解决海量数据处理问题</strong></p>
<h1 id="回溯算法">回溯算法</h1>
<p>很多经典的问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p>
<p>深度优先搜索算法利用的是回溯算法思想；实际开发中，正则表达式匹配、编译原理中的语法分析等也用到回溯思想。</p>
<p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>
<p>大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p>
<h2 id="八皇后">八皇后</h2>
<p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p>
<p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/a0/f5/a0e3994319732ca77c81e0f92cc77ff5.jpg" alt="  " loading="lazy"></figure>
<p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p>
<p>回溯法的搜索空间是多大呢？以 4×4 的棋盘为例，第一行显然有四个位置可以放置皇后，而第一行的皇后使得第二行至少有两个格子处于它的攻击范围之内，因此第二行至多有 4-2=2 个可用位置，以此类推，第三行至多有一个位置，第四行也至多有一个位置。因此搜索空间为 4×2×1×1 = 8 ，较之以前的确小了不少。</p>
<p>这样推导到更通俗的情况，对于 N×N 的棋盘，回溯法的搜索空间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>×</mo><mo>…</mo><mo>×</mo><mn>1</mn><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">N×(N-2)×(N-4)×…×1 = O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 。对于开头提到的八皇后问题，时间复杂度就从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>8</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">8^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>降到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">8!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mclose">!</span></span></span></span></p>
<h2 id="0-1背包">0-1背包</h2>
<p>有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
<blockquote>
<p>0-1 背包问题有很多变体，经典解法是动态规划，不过用回溯算法虽然不够高效，但很简单。</p>
</blockquote>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>	种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。不过，如何才能不重复地穷举出这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种装法呢？</p>
<p>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。还可以加入一些<strong>搜索剪枝</strong>的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，就停止继续探测剩下的物品。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式里最重要的一种算法思想就是回溯</p>
<p>通配符：“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符</p>
<p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>
<p>依次考察正则表达式中的每个字符，当是非通配符时，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>
<p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>
<h1 id="动态规划">动态规划</h1>
<p>动态规划（Dynamic Programming）比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。它的主要学习难点跟递归类似，就是求解问题的过程不太符合人类常规的思维方式。</p>
<h2 id="动态规划问题模型及演化过程">动态规划问题模型及演化过程</h2>
<h3 id="0-1背包问题">0-1背包问题</h3>
<p>对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少？</p>
<p>假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3</p>
<p>回溯的解决方法，就是穷举搜索所有可能的装法，然后找出满足条件的最大值。</p>
<p>回溯求解过程，用递归树画出来如图。递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p>
<img src="https://static001.geekbang.org/resource/image/42/ea/42ca6cec4ad034fc3e5c0605fbacecea.jpg" style="zoom:50%;" />
<p>递归树中，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。可以利用缓存避免冗余计算。</p>
<p>动态规划求解：</p>
<p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p>
<p>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量）。于是，我们就成功避免了每层状态个数的指数级增长。</p>
<p>二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。</p>
<p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 <code>states[0][0]=true</code> 和 <code>states[0][2]=true</code> 来表示这两种状态。</p>
<p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 <code>states[1][0]=true</code>，<code>states[1][2]=true</code>，<code>states[1][4]=true</code> 来表示这三种状态。</p>
<p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/bb/7e/bbbb934247219db8299bd46dba9dd47e.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p>
<p>这个问题用回溯算法解决这个问题的时间复杂度 O(2^n)，是指数级的。用动态规划的时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。但需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。</p>
<p>动态规划是一种空间换时间的解决思路，可以通过其他办法降低空间消耗。实际上只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作， 要注意for 循环重复计算的问题。</p>
<h3 id="0-1-背包问题升级版">0-1 背包问题升级版</h3>
<p>背包问题，只涉及背包重量和物品重量。现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p>
<p>问题依旧可以用回溯算法来解决，穷举搜索所有可能的装法，然后找出满足条件的最大值。</p>
<p>照例画出递归树。在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p>
<img src="https://static001.geekbang.org/resource/image/bf/3f/bf0aa18f367db1b8dfd392906cb5693f.jpg" style="zoom:50%;" />
<p>在递归树中，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。如有节点f(2,2,4) 和 f(2,2,3)的 i 和 cw 是完全相同的，在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p>
<p>还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p>
<p>我们用一个二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。时间复杂度是 <code>O(n*w)</code>，空间复杂度也是 <code>O(n*w)</code></p>
<p>大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。动态规划算法，在执行效率方面，要高很多。但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p>
<p>四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性。</p>
<h2 id="适合解决的问题的特征">适合解决的问题的特征</h2>
<p>动态规划作为一个非常成熟的算法思想，很多人对动态规划能解决的问题有什么规律，已经做了全面的总结：<strong>“一个模型三个特征”</strong></p>
<p>一个模型是指：“<strong>多阶段决策最优解模型</strong>”</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p><strong>三个特征</strong>”分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</p>
<ol>
<li>
<p>最优子结构</p>
<p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p>
</li>
<li>
<p>无后效性</p>
<p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p>
</li>
<li>
<p>重复子问题</p>
<p>这个概念比较好理解。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>
</li>
</ol>
<h3 id="一个模型三个特征实例剖析">“一个模型三个特征”实例剖析</h3>
<p>假设我们有一个 n 乘以 n 的矩阵 <code>w[n][n]</code>。矩阵存储的都是正整数。</p>
<p>棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>
<p><strong>一个模型</strong>：从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步（向右向下各n-1），也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p>
<p><strong>三个特征</strong>：</p>
<p>用回溯算法来解决这个问题。画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在<strong>重复子问题。</strong></p>
<p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“<strong>无后效性</strong>”这一特征。</p>
<p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“<strong>最优子结构</strong>”。</p>
<pre><code class="language-java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
</code></pre>
<h2 id="动态规划解题思路">动态规划解题思路</h2>
<p>两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。</p>
<p>状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。</p>
<p>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p>
<p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p>
<h3 id="状态转移表法">状态转移表法</h3>
<p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用**回溯加“备忘录”**的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p>
<p>先画出一个状态表。状态表一般都是二维的，可以想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p>
<p>高维状态转移表不好画图表示，且人脑确实很不擅长思考高维的东西。所以当问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，便不适合用状态转移表法来解决了。</p>
<p>矩阵最短路径的问题解法：</p>
<p>从起点到终点，有很多种不同的走法。先用回溯算法穷举所有走法，然后对比找出一个最短走法。</p>
<p>接下来，画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了。既然存在重复子问题，用动态规划来解决。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/2c/e2/2c3ec820fa8f8cc7df838c0304b030e2.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/b3/ca/b3f0de1c81533a0d24c43426eaf09aca.jpg" alt=" " loading="lazy"><br /><img src="https://static001.geekbang.org/resource/image/05/7d/05a48baf7fb4d251bf5078840079107d.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充。然后将上面的过程，翻译成代码。</p>
<h3 id="状态转移方程法">状态转移方程法</h3>
<p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p>
<p><strong>状态转移方程是解决动态规划的关键</strong></p>
<pre><code class="language-java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
</code></pre>
<h2 id="四种算法思想各自特点及适用场景">四种算法思想各自特点及适用场景</h2>
<p>基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p>
<p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p>
<p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p>
<h1 id="b树">B+树</h1>
<p><strong>数据库索引是如何实现的呢？</strong></p>
<ul>
<li>根据某个值查找数据，比如 select * from user where id=1234；</li>
<li>根据区间值来查找某些数据，比如 select * from user where id &gt; 1234 and id &lt; 2345。</li>
</ul>
<p><strong>散列表</strong>。散列表的查询时间复杂度是 O(1)。但是不支持按照区间快速查找数据。</p>
<p><strong>平衡二叉查找树</strong>。查询时间复杂度是 O(logn)。且对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p>
<p><strong>跳表</strong>。是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)，也支持按照区间快速地查找数据。</p>
<h3 id="改造二叉查找树">改造二叉查找树</h3>
<p>让二叉查找树支持按照区间来查找数据，改造：树中的节点并不存储数据本身，而是只是作为索引。同时把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg" alt="  " loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>要求某个区间的数据。只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p>
</li>
<li>
<p>为了节省内存，将索引存储在硬盘中，但查找索引时，需要磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数，构建成 m 叉树来降低树高度，从而减少IO次数。</p>
<p>操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，在选择 m 大小的时候，要尽量让<strong>每个节点的大小等于一个页的大小</strong>。读取一个节点，只需要一次磁盘 IO 操作。</p>
</li>
<li>
<p>B+ 树来的m 值是根据页的大小事先计算好的，因此在插入、删除操作时，会打破m个子节点，从而影响IO效率（节点不再是页大小，IO次数增多）。因此需要节点分裂、合并等整理操作来让节点满足页大小。</p>
<p>插入时超出个m个节点时，只需要将这个节点分裂成两个节点，若导致其父节点的子节点个数就有可能超过 m 个，将父节点也分裂成两个节点。从下往上级联反应，一直影响到根节点。</p>
<p>删除时会导致子节点变少，在 B+ 树中，有个阈值为 m/2，若某个节点的子节点个数小于 m/2，就将它跟相邻的兄弟节点合并。（若合并之后结点的子节点个数有超过 m。继续借助插入数据时候的处理方法，再分裂节点。）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt="  " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg" alt="     " loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>总结B+ 树的特点：</p>
<ul>
<li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；(例外：根节点的子节点个数可以不超过 m/2)</li>
<li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li>
<li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li>
<li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li>
</ul>
<blockquote>
<p>除了 B+ 树，还有 B 树、B- 树，实际上，B- 树就是 B 树，英文翻译都是 B-Tree，这里的“-”并不是相对 B+ 树中的“+”，而只是一个连接符。</p>
<p>说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：</p>
<ul>
<li>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；</li>
<li>B 树中的叶子节点并不需要链表来串联。</li>
</ul>
<p>也就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。</p>
</blockquote>
<h1 id="位图与filter">位图与Filter</h1>
<p><strong>布隆过滤器</strong>（Bloom Filter）是filter中的一种。</p>
<p>Filter和Cache都是加快数据访问的缓存思想。二者是互补的。</p>
<p>cache 是在访问数据时，cache中存在则取出，不在则去下层找。</p>
<p>filter 是在访问数据时，filter的关键是<strong>判断元素在与不在</strong>，</p>
<p>Bloom Filter判断一个元素在集合中有一定的错误率，但是判断一个元素不在集合中就绝对不在集合中。</p>
<p><strong>我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</strong></p>
<p><strong>位图</strong>（BitMap）一种比较“特殊”的散列表。比如 Java 中的 BitSet 类就是一个位图</p>
<blockquote>
<p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p>
<p>当我们查询某个整数 K 是否在这 1 千万个整数中的时候，我们只需要将对应的数组值 array[K] 取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p>
<p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p>
</blockquote>
<p>同样的例子，数据个数是 1 千万，数据的范围是 1 到 10 亿时。使用<strong>布隆过滤器</strong>（Bloom Filter）的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。哈希函数可能会存在冲突。</p>
<p>我们使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>X</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>X</mi><mn>3</mn></msub><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><msub><mi>X</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">X_1，X_2，X_3，…，X_K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​。我们把这 K 个数字作为位图中的下标，将对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>1</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>3</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mi>K</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">BitMap[X_1]，BitMap[X_2]，BitMap[X_3]，…，BitMap[X_K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>​ 都设置成 true，也就是说，我们用 K 个<strong>二进制位</strong>，来表示一个数字的存在。</p>
<p>当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mn>3</mn></msub><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">Y_1，Y_2，Y_3，…，Y_K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</p>
<p><strong>步隆过滤器是通过K个函数，对一个元素求得K个二进制位，表示该元素是否在集合里。</strong></p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/94/ae/94630c1c3b7657f560a1825bd9d02cae.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/d0/1a/d0a3326ef0037f64102163209301aa1a.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>但是，这种处理方式容易误判。布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p>
<p>布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能。</p>
<p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，我们就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，如果我们要判断某个数据是否在布隆过滤器中已经存在，我们就需要查看多个位图，相应的执行效率就降低了一些。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[查找]]></title>
        <id>https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-03/</id>
        <link href="https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-03/">
        </link>
        <updated>2021-03-13T06:46:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="二分查找">二分查找</h1>
<h2 id="算法描述">算法描述</h2>
<p>二分查找（Binary Search）也叫折半查找，是针对有序数据集合的查找算法。用循环或递归来实现：</p>
<ul>
<li>折半取中，判断元素与目标元素的大小关系
<ul>
<li>
<p>小于——往前继续折半</p>
</li>
<li>
<p>大于——往后继续折半</p>
</li>
<li>
<p>等于——返回</p>
</li>
</ul>
</li>
</ul>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>易错点：</p>
<ul>
<li>
<p>循环条件：是 low&lt;=high，而不是 low&lt;high。</p>
</li>
<li>
<p>mid与查找的值有大于、小于、等于三种关系。要分别考虑，不要漏掉。</p>
</li>
<li>
<p>mid 的取值：mid=(low+high)/2 这种写法不好。若 low 和 high 比较大的话，两者之和有可能溢出。</p>
<p>优化<code>low+(high-low)/2</code> 或位运算 <code>low+((high-low)&gt;&gt;1)</code></p>
</li>
<li>
<p>low 和 high 的更新，折半时<code>low=mid+1 或 high=mid-1</code> ，一定要 +1 或 -1，直接<code>low=mid 或high=mid</code>，在<code>high=low≠value</code>	即时查找不到时，可能会发生死循环。</p>
</li>
<li>
<h2 id="适用场景">适用场景</h2>
</li>
</ul>
<ul>
<li>依赖顺序表结构。因为要根据下标随机访问。数组可以；链表就不适合，加大了复杂度。</li>
<li>数据本身必须有序。即时对无序数据增加复杂度去排序，也只适合用在插入、删除操作不频繁的数据集合。</li>
<li>数据量相对比较元素的开销要足够大——不然遍历即可</li>
<li>数据量相对内存空间不能太大——不然顺序表装不下</li>
</ul>
<p>最简单的二分查找：在<strong>不存在重复元素</strong>的有序数组中，查找值<strong>等于</strong>给定值的元素。</p>
<h2 id="变体">变体</h2>
<p>复杂二分查找：存在重复元素，查找第一个或最后一个等于、大于、小于给定值的元素。</p>
<p>要根据对<code>arr[mid] = value</code>这种找到了元素的情况，进行额外处理</p>
<pre><code class="language-java">public int bSearchFirstEq(int[] arr, int size, int value) {
    int low = arr[0];
    int high = arr[size - 1];
    while (low &lt;= high) {
        int mid = low + ((low - high) &gt;&gt; 1);
        if (arr[mid] &lt; value) low = mid + 1;
        else if (arr[mid] &gt; value) high = mid - 1;
        else {
	          //mid没有上一个位置，或mid的上一个位置的值也不是value
            if (mid == 0 || arr[mid - 1] != value) return mid;
            else high = mid - 1;/*mid前还有value，value就在[low,mid-1]间*/
        }
    }
    return -1;
}
</code></pre>
<h1 id="跳表skip-list">跳表（Skip List）</h1>
<p>链表加索引的结构，就是跳表</p>
<p>支持快速地：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
</ul>
<p>某些情况下，跳表甚至可以替代红黑树（Red-Black tree）。Redis 当中的有序集合（Sorted Set）是用跳表实现的。</p>
<h2 id="跳表的结构">跳表的结构</h2>
<p>跳表是对链表的改进。对于单链表来说，即使内容是有序的，查找具体某个元素也只能从头到尾遍历链表，时间复杂度也要达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。二分查找又只适合数组。对链表稍加改造，就可以支持类似“二分”的查找算法。改造之后的数据结构叫作<strong>跳表</strong>（Skip list）</p>
<p>每两个结点提取一个结点到上一级，把抽出来的那一级叫作<strong>索引</strong>或**索引层。**查找某个结点，先在索引层遍历，遍历到下个节点大于要查找的元素前，再通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。</p>
<p>跳表的核心思想是用空间换时间，构建足够多级数的索引，来缩短查找具体值的时间开销。抽取结点到上级索引可以是每两个，或者更多个，索引占用的额外空间就越少。实际开发中，不必太在意索引占用的额外空间，和原始链表中存储的对象比起来可以忽略。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="具有二级索引的跳表示例" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="在跳表中插入一个元素" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="高效地插入和删除">高效地插入和删除</h2>
<p>对于链表来说，插入或删除一个<u><em>给定结点</em></u>的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。因此，对于跳表来说，插入或删除某个结点，其时间复杂度完全依赖于查找这类结点的耗时。而我们知道，在跳表中查找某个元素的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。因此，在跳表中插入或删除某个结点的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="跳表索引的动态更新">跳表索引的动态更新</h2>
<p>为了维护跳表的结构，在不断插入数据的过程中，有必要动态维护跳表的索引结构。即如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="索引" loading="lazy"></th>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/a861445d0b53fc842f38919365b004a7.jpg" alt="在跳表中插入一个元素并更新索引" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>一般来说，可以在插入时采用<strong>随机层级</strong>法。具体来说是引入一个输出整数的随机函数。当随机函数输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，则更新从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 级至第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 级的索引。为了保证索引结构和数据规模大小的匹配，一般采用二项分布的随机函数。</p>
<p>红黑树、AVL 树这样平衡二叉树，通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护这种“平衡性”。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<p>跳表的空间复杂度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h1 id="散列表">散列表</h1>
<p>Hash Table也叫“哈希表”或者“Hash 表，<strong>用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，利用数组下标的随机访问特性。</strong></p>
<h2 id="散列思想">散列思想</h2>
<ul>
<li>键/关键字/Key：用来标识一个数据</li>
<li>散列函数/哈希函数/Hash：将 Key 映射到数组下标的函数</li>
<li>散列值/哈希值：Key 经过散列函数得到的数值</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg" alt="" loading="lazy"></figure>
<p>本质：利用散列函数将关键字映射到数组下标，而后利用数组随机访问时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的特性快速访问。</p>
<h2 id="散列函数">散列函数</h2>
<ul>
<li>形式：<code>hash(key)</code></li>
<li>基本要求
<ol>
<li>散列值是非负整数</li>
<li>如果 <code>key1 == key2</code>，那么 <code>hash(key1) == hash(key2)</code></li>
<li>如果 <code>key1 != key2</code>，那么 <code>hash(key1) != hash(key2)</code></li>
</ol>
</li>
</ul>
<p>第 3 个要求，实际上不可能对任意的 <code>key1</code> 和 <code>key2</code> 都成立。因为通常散列函数的输出范围有限而输入范围无限。</p>
<h2 id="散列冲突">散列冲突</h2>
<ul>
<li>散列冲突：<code>key1 != key2</code> 但 <code>hash(key1) == hash(key2)</code></li>
</ul>
<p>散列冲突会导致不同键值映射到散列表的同一个位置。即便像<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC</a>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p>
<p>几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，需要通过其他途径来解决。</p>
<p>常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p>
<h3 id="开放寻址法">开放寻址法</h3>
<p>如果遇到冲突，那就继续寻找下一个空闲的槽位。</p>
<h4 id="线性探测">线性探测</h4>
<p>插入时，如果遇到冲突，那就依次往下寻找下一个空闲的槽位。（橙色表示已被占用的槽位，黄色表示空闲槽位）</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>查找时，如果目标槽位上不是目标数据，则依次往下寻找；直至遇见目标数据或空槽位。</p>
<p>可以将删除的元素，特殊标记为 <code>deleted</code>。当线性探测查找的时候，遇到标记为 <code>deleted</code> 的空间，并不是停下来，而是继续往下探测。</p>
<p><strong>平方探测（Quadratic probing）</strong></p>
<p>插入时，如果遇到冲突，那就往后寻找下一个空闲的槽位，其步长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>。</p>
<p>查找时，如果目标槽位上不是目标数据，则依次往下寻找，其步长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>；</p>
<p><strong>双重散列</strong>（Double hashing）先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<p>还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。</p>
<h4 id="装载因子load-factor">装载因子（load factor）</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>load factor</mtext><mo>=</mo><mfrac><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>(</mo><mo>)</mo></mrow><mrow><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>(</mo><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{load factor} = \frac{size()}{capacity()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">load factor</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><strong>装载因子</strong>（load factor）来表示空闲槽位的多少。装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<h3 id="链表法">链表法</h3>
<p>所有散列值相同的 key 以链表的形式存储在同一个槽位中。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="" loading="lazy"></figure>
<p>插入时，不论是否有冲突，直接插入目标位置的链表。</p>
<p>查找时，遍历目标位置的链表来查询。</p>
<p>删除时，遍历目标位置的链表来删除。</p>
<h1 id="散列表-2">散列表</h1>
<p>核心：散列表的效率仅是在理论上能达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>极端情况下，数据经过散列函数之后，都散列到同一个槽里，散列表就会退化为链表。使得散列表的性能急剧下降。</p>
<p>如何设计一个工业级的散列表？</p>
<h2 id="散列函数-2">散列函数</h2>
<ul>
<li>不能过于复杂——避免计算散列过程耗时</li>
<li>散列函数的结果要尽可能均匀——最小化散列冲突机率</li>
</ul>
<h2 id="动态扩容rehash">动态扩容ReHash</h2>
<p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>针对散列表的扩容，因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。即<code>ReHash</code></p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>直接拷贝移动很低效，如何提高扩容效率？</p>
<p>——将 rehash 的步骤，均摊到每一次插入中去：</p>
<ul>
<li>申请新的空间</li>
<li>不立即使用</li>
<li>每次来了新的数据，往新表插入数据</li>
<li>同时，取出旧表的一个数据，插入新表</li>
</ul>
<h2 id="解决冲突">解决冲突</h2>
<p>LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。</p>
<p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong></p>
<p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p>
<p>开放寻址法，优点：</p>
<ul>
<li>不需要额外空间</li>
<li>有效利用 CPU 缓存</li>
<li>方便序列化</li>
</ul>
<p>开放寻址法，缺点：</p>
<ul>
<li>查找、删除数据时，涉及到 <code>delete</code> 标志，相对麻烦</li>
<li>冲突的代价更高</li>
<li>对装载因子敏感</li>
</ul>
<p>链表法，优点：</p>
<ul>
<li>内存利用率较高——链表的优点</li>
<li>对装载因子不敏感</li>
</ul>
<p>链表法，缺点：</p>
<ul>
<li>需要额外的空间（保存指针）</li>
<li>对 CPU 缓存不友好</li>
</ul>
<p>——将链表改造成更高效的数据结构，例如跳表、红黑树</p>
<h2 id="java-中的-hashmap">JAVA 中的 HashMap</h2>
<ul>
<li>初始大小：16</li>
<li>装载因子：超过 0.75 时动态扩容</li>
<li>散列冲突：优化版的链表法（当槽位冲突元素超过 8 时使用红黑树，否则使用链表）</li>
</ul>
<h1 id="散列表-3">散列表</h1>
<p>散列表和链表的组合？为什么呢？</p>
<ul>
<li>链表：涉及查找的操作慢，不连续存储；</li>
<li>顺序表：支持随机访问，连续存储。</li>
</ul>
<p>散列表 + 链表：结合优点、规避缺点。</p>
<h2 id="结合散列表的-lru-缓存淘汰算法">结合散列表的 LRU 缓存淘汰算法</h2>
<p>缓存的操作接口：</p>
<ul>
<li>向缓存添加数据</li>
<li>从缓存删除数据</li>
<li>在缓存中查找数据</li>
</ul>
<p>然而——不管是添加还是删除，都涉及到查找数据。因此，单纯的链表效率低下。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg" alt="" loading="lazy"></figure>
<ul>
<li><code>prev</code> 和 <code>next</code>：双向链表——LRU 的链表</li>
<li><code>hnext</code>：单向链表——解决散列冲突的链表</li>
</ul>
<p>操作：</p>
<ul>
<li>在缓存中查找数据：利用散列表</li>
<li>从缓存中删除数据：先利用散列表寻找数据，然后删除——改链表就好了，效率很高</li>
<li>向缓存中添加数据：先利用散列表寻找数据，如果找到了，LRU 更新；如果没找到，直接添加在 LRU 链表尾部</li>
</ul>
<h2 id="java-linkedhashmap">Java: LinkedHashMap</h2>
<p>遍历时，按照访问顺序遍历。</p>
<p>往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部；有同值则先删除，再插入末尾。</p>
<p>述 LRU 的结构完全相同——只不过它不是缓存，不限制容量大小。</p>
<h1 id="哈希算法">哈希算法</h1>
<p>将任意长度的二进制值串<strong>映射为固定长度</strong>的二进制值串，这个映射的规则就是<strong>哈希算法。</strong></p>
<p>通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p>
<p>哈希算法的要求</p>
<ul>
<li>从哈希值<strong>不能反向推导</strong>出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对<strong>输入数据敏感</strong>，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li><strong>散列冲突概率小</strong>，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的<strong>执行效率高</strong>，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>哈希算法常见的应用：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p>
<h2 id="安全加密">安全加密</h2>
<p><strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）128 位二进制串</p>
<p><strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。128/256</p>
<p><strong>DES</strong>（Data Encryption Standard，数据加密标准）</p>
<p><strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>
<p>提高哈希算法的复杂度，可以引入一个盐（salt），如用户的密码组合在一起，增加密码的复杂度，再做哈希算法加密。</p>
<h2 id="唯一标识">唯一标识</h2>
<p>一个文件的信息摘要</p>
<h2 id="数据校验">数据校验</h2>
<p>确定数据的完整性，没被篡改过。</p>
<h2 id="和分布式系统有关的应用">和分布式系统有关的应用</h2>
<p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p>
<h1 id="二叉树">二叉树</h1>
<h3 id="树">树</h3>
<p>没有父节点的节点叫作<strong>根节点</strong></p>
<p>没有子节点的节点叫作<strong>叶子节点</strong>(叶节点)</p>
<p><strong>高度</strong>（Height）从下往上算</p>
<p><strong>深度</strong>（Depth）从上往下算</p>
<p><strong>层</strong>（Level）深度+1</p>
<p>树的高度就是根节点的高度。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/40/1e/4094a733986073fedb6b9d03f877d71e.jpg" alt="height" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="deep" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="二叉树-2">二叉树</h3>
<p>每个节点<strong>最多</strong>有两个子节点的树，即<strong>左子节点</strong>和<strong>右子节点</strong>。</p>
<p><strong>满二叉树</strong>	：除最底一层的叶子节点，所有上层左右子节点都开满的树。</p>
<p><strong>完全二叉树</strong>：最后一层的叶子节点靠左排列；且除了最后一层，其他层是满二叉树。</p>
<h2 id="表示法">表示法</h2>
<p>基于指针或者引用的二叉链式存储法</p>
<p>基于数组的顺序存储法。</p>
<p><strong>链式存储法</strong>：每个节点有三个字段：数据、左右子节点的指针。拎住根节点，通过左右子节点的指针，就能把整棵树都串起来。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="link" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg" alt="array" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>顺序存储法</strong>：完全二叉树，“浪费”了一个下标为 0 的存储位置。非完全二叉树会浪费更多数组存储空间。</p>
<p>为了方便计算子节点，根节点会存储在下标为 1 的位置。节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点</p>
<h2 id="遍历">遍历</h2>
<p><strong>前、中、后序遍历</strong>	是指当前节点、左子树、右子树，<strong>当前节点</strong>在三者闭环中的前、后、中的位置。</p>
<ul>
<li>前序遍历是指，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li>
<li>中序遍历是指，先打印节点的左子树，然后再打印节点本身，最后打印节点的右子树。</li>
<li>后序遍历是指，先打印节点的左子树，然后再打印节点的右子树，最后打印这个节点本身。</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg" alt="遍历" style="zoom:50%;" />
<p><strong>前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p>
<pre><code class="language-c">前序遍历的递推公式：
preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)
 
中序遍历的递推公式：
inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)
 
后序遍历的递推公式：
postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r
</code></pre>
<h1 id="二叉查找树">二叉查找树</h1>
<p>二叉查找树Binary Search Tree也叫二叉搜索/排序树，支持动态数据集合的快速插入、删除、查找操作。</p>
<blockquote>
<p>散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。</p>
<p>二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据。</p>
</blockquote>
<p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>
<p><strong>二叉查找树时间复杂度跟树的高度成正比，也就是 O(height)</strong></p>
<p><strong>按照中序的插入后。中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效</strong>。</p>
<p>根节点的左右子树极度不平衡时，会退化成了链表。因此才有了平衡二叉树。</p>
<p><strong>查找</strong>：先取根节点，如果等于要查找的数据就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/96/2a/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="查找" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>插入</strong>：从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<h2 id="删除">删除</h2>
<img src="https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg" style="zoom:50%;" />
<p>二叉查找树的删除操作有三种情况：</p>
<ol>
<li>如果要删除的节点没有子节点，把将父节点中指向要删除节点的指针，置为 null。图中55。</li>
<li>如果要删除的节点只有左或右一个子节点，把新父节点中指向要删除节点的指针，指向要删除节点的子节点就可以了。图中 13。</li>
<li>如果要删除的节点有两个子节点。找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。再删除掉这个最小节点。（因为最小节点肯定没有左子节点，如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点）图中 18。即删除该节点，并找到大于该节点的最小值来替换。具体为，从该节点的右子节点往下找最小值。</li>
</ol>
<blockquote>
<p>另一种删除策略：单纯将要删除的节点标记为“已删除”，并不真正从树中将这个节点去掉。浪费内存空间，但是删除操作就变得简单了很多。</p>
</blockquote>
<h2 id="支持重复数据的二叉查找树">支持重复数据的二叉查找树</h2>
<p>本次讨论中为了更清晰，默认树中节点存储的都是数字。在实际开发中，二叉查找树中存储的，是一个包含很多字段的对象。用对象的某个字段作为键值（key）来构建二叉查找树。把对象中的其他字段叫作卫星数据。</p>
<p><strong>插入</strong>：寻找插入位置时，若发现一个节点的值与要插入的数据相同，把要插入的数据放到该节点的右子树，即把这个新插入的数据当作大于这个节点的值来处理。</p>
<p>**查找：**查找数据时，遇到值相同的节点并不停止查找，而是继续在右子树中查找，直到遇到叶子节点才停止。</p>
<p><strong>删除</strong>：查找到每个要删除的节点，然后依次删除。</p>
<blockquote>
<p>如果存储的两个对象键值相同，还可以通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</blockquote>
<blockquote>
<p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，为什么还要使用二叉查找树呢？</p>
<p>第一，散列表中的数据是无序存储的，想有序输出还要先进行排序；二叉查找树来，想有序输出只需要中序遍历。</p>
<p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定；最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p>
<p>第三，散列表构造复杂，需要考虑散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性且解决方案比较成熟、固定。</p>
<p>尽管散列表的查找等操作的时间复杂度是常量级的，但在哈希冲突时，常量未比必logn小，再加上哈希函数的耗时等，具体开发中具体选择。</p>
</blockquote>
<h1 id="红黑树">红黑树</h1>
<p>二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。因此产生了平衡二叉查找树，使左右节点平衡。红黑树便是最常用的平衡二叉查找树。</p>
<p><strong>平衡二叉查找树</strong>：原定义是任意一个节点的左右子树的高度相差不能大于 1，的二叉查找树。但实际只要整棵树的左右比较平衡，树的高度不比 log2n 大很多，仍然是一个合格的平衡二叉查找树。</p>
<blockquote>
<p>完全二叉树、满二叉树都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p>
<p>最先被发明的平衡二叉查找树是<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL 树</a>	，平衡二叉查找树还有Splay Tree（伸展树）、Treap（树堆）等</p>
<p>AVL 树是一种高度平衡的二叉树，查找的效率非常高。但AVL 树为了维持这种高度的平衡，每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。</p>
</blockquote>
<p>平衡二叉查找树中“平衡”的意思，其实就是让<strong>整棵树左右看起来比较“对称”、比较“平衡”</strong>，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>红黑树“Red-Black Tree”，简称 R-B Tree。是一种不严格的平衡二叉查找树。</p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。且满足四个特征：</p>
<ol>
<li><strong>根节点是黑色的</strong>；</li>
<li><strong>叶子节点不存储数据</strong>，即每个叶子节点都是黑色的空节点（NIL）；</li>
<li><strong>红色节点不相邻</strong>，即红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到其<strong>可达叶子节点的</strong>所有路径，都包含的<strong>黑色节点数目相同</strong>；</li>
</ol>
<p>“叶子节点都是黑色的空节点”，是为了简化红黑树的代码实现而设置的。<strong>在画图思考的时候，一般将黑色的、空的叶子节点都省略掉。</strong></p>
<p>红黑树是“近似平衡”的。“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重**。</p>
<p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以红黑树的高度比较稳定地趋近 log2n 就是近似平衡的。</p>
<h2 id="平衡调整">平衡调整</h2>
<p>当插入、删除节点时，红黑树的红色节点可能会相临，某个节点到其可达叶子节点路径上黑色条目也可能会不同。要通过平衡调整的操作使红色节点不相临，同时每条可达叶子节点路径上的黑色条目相同。</p>
<p>即插入、删除节点时会破坏特征3、4，“平衡调整”就是把破坏的3、4恢复过来。</p>
<p>围绕某个节点<strong>左旋（rotate left）</strong>、<strong>右旋（rotate right）</strong>，和<strong>改变节点颜色</strong>是平衡调整的基本操作。</p>
<p>红黑树的平衡调整过程是一个迭代的过程。正在处理的节点叫作<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p>
<p><strong>红黑树规定，插入的节点必须是红色的。且二叉查找树中新插入的节点都是放在叶子节点上</strong>。</p>
<p>新节点插入之后，如果红黑树的平衡被打破，只需要根据每种情况的特点。通过左右旋、改变颜色不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。</p>
<p>红黑树的平衡调整的过程比作魔方复原，至于平衡调整策略、算法的正确性都无须深究。</p>
<h1 id="递归树">递归树</h1>
<p>递归的思想就是，将大问题分解为小问题来求解，一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p>
<p>把递归一层一层的分解过程画成图，就是一棵树，即<strong>递归树</strong>。<strong>递归树常用来分析递归算法的时间复杂度</strong></p>
<h2 id="归并排序复杂度">归并排序复杂度</h2>
<img src="https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg" style="zoom:50%;" />
<p>归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。每一层归并操作消耗的时间记作 n，树高h，总的时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">∗</mi><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n∗h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">∗</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>	，归并排序的递归树是一棵满二叉树，高度h是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>	，因此归并排序的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>忽略底数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h1 id="堆与堆排序">堆与堆排序</h1>
<p>堆排序是一种原地的、时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">⁡</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的排序算法。</p>
<p>堆的特性：</p>
<ol>
<li>堆是一个完全二叉树；</li>
<li>大顶堆：堆中每一个节点的值都必须大于等于（或小顶堆小于等于）其左右子节点的值。</li>
</ol>
<p>用数组来存储完全二叉树是非常节省存储空间的。不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<p><strong>数组下标为 1 的位置开始存储时节点存在数组中下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，其左节点下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span>，右节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其父节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>i</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong></p>
<p><strong>数组下标为 0 的位置开始存储时节点存在数组中下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，其左节点下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，右节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，其父节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong></p>
<h2 id="插入元素">插入元素</h2>
<p>堆中插入一个元素后，需要进行调整，让其重新满足堆的特性叫做<strong>堆化</strong></p>
<p>插入一个数据和删除堆顶元素都要用到堆化。插入一个数据的时候，把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。</p>
<p><strong>从下往上堆化:</strong> 取最后一个节点，顺着节点所在的路径向上，比较和交换，直到满足堆的特性。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg" alt=" " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="删除堆顶元素">删除堆顶元素</h4>
<p>根据堆的第二特性，堆顶元素就是堆中数据的最大/最小值。</p>
<p>当我们删除堆顶元素时，顶节点空缺，要将左右子节点中较大的节点上移到堆顶；此时第二层有一个位置空缺，再从该位置载第三层的左右子节点中较大的节点上移。以此类推，直到从叶子节点上移填补。</p>
<p><strong>从上往下的堆化方法</strong>:	把最后一个节点放到堆顶，然后父子节点对比。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg" alt=" " loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td>删除栈顶元素</td>
<td>从上往下堆化</td>
</tr>
</tbody>
</table>
<p>一个包含 n 个节点的完全二叉树，树的高度不会超过 log2⁡n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也是 O(log⁡n)。插入数据和删除堆顶元素的主要逻辑就是堆化，时间复杂度都是 O(logn)。</p>
<h2 id="堆排序">堆排序</h2>
<p>堆排序是一种原地的、时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">⁡</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的排序算法。</p>
<p>两大步骤是<strong>建堆</strong>和<strong>排序</strong>。</p>
<p>将原数组下标从  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>到 1 的节点，依次进行从上到下的堆化操作，就可以把数组中的数据组织成堆这种数据结构。然后迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p>
<h3 id="建堆">建堆</h3>
<p>首先将数组原地建成一个堆。不借助另一个数组，就在原数组上操作。</p>
<p>方式一：从下往上堆化：在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但假设起初堆中只包含一个数据，就是下标为 1 的数据。然后将下标从 2 到 n 的数据依次插入到堆中。就组织成了堆。如下标2的元素，与其父节点下标1比较交换.....</p>
<p>方式二：从上往下堆化：在堆中删除堆顶元素的思路：从后往前(从  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>到 1 )取出数组中的元素，依次把元素当作从上往下堆化中插入的新顶点，与子节点比较交换完成堆化。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始堆化就行了。（当下标从0开始时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>到0）</p>
<p>对于完全二叉树来说，下标超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的节点都是叶子节点，不必当作顶点重复比较，因此方式二只需对数组内下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>到 1进行堆化。</p>
<p>建立堆时间复杂度O(n)</p>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/joshua_chang/pic/raw/master/uPic/50c1e6bc6fe68378d0a66bdccfff441e-20210718213839150-20210718213842273.jpg" alt=" " loading="lazy"><br /><img src="https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="排序">排序</h2>
<p>建立了一个(每一个节点的值都必须大于等于/小于等于其左右子节点的值的完全二叉树)大顶堆或小顶堆，数组的第一个元素就是堆顶。</p>
<p>排序的过程类似“删除堆顶元素”的操作：</p>
<p>把堆顶（数组的第一个元素）与最后一个元素交换，即最大元素就放到下标为 n 的位置，下标为 n的元素放到堆顶。</p>
<p>再采用类似“删除堆顶元素”的操作，把原下标为n的元素从上往下堆化。</p>
<p>堆化完成后，再取新的堆顶与下标n-1的元素交换，然后下标n-1的元素继续从上往下堆化</p>
<p>重复这个过程，直到最后数组里只剩下下标为1的元素，排序完成。</p>
<p>每次的堆顶就是数组内剩余的最大值，因此数组得以排序。</p>
<p>建堆过程的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，排序过程的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，所以，堆排序整体的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">⁡</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">⁡</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p><strong>数组下标为 1 的位置开始存储时节点存在数组中下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，其左节点下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，右节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，其父节点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong></p>
<blockquote>
<p>为什么在实际开发中，快速排序要比堆排序性能好？</p>
<ol>
<li>**堆排序数据访问的方式没有快速排序友好。**堆排序来说，数据是跳着访问的对cpu缓存不友好。</li>
<li>**对于同样的数据排序，堆排序算法的数据交换次数要多于快速排序。**快速排序是基于比较的，数据交换的次数不会比逆序度多；堆排序建堆就会打破数据的原有顺序，增加逆序度。</li>
</ol>
</blockquote>
<h1 id="堆的应用">堆的应用</h1>
<p>优先级队列、求 Top K 和求中位数</p>
<h2 id="优先级队列">优先级队列</h2>
<p>队列最大的特性就是先进先出。</p>
<p>优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<p>优先级队列在赫夫曼编码、图的最短路径、最小生成树算法等中都有使用。</p>
<p>一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<p><strong>优先级队列使用场景</strong>：定时器、合并有序小文件等</p>
<h2 id="利用堆求-top-k">利用堆求 Top K</h2>
<p>求TopK问题可分成两类：针对静态数据集合、针对动态数据集合</p>
<p>针对静态数据集合，在包含n个数据的数组中，查找前 K 大数据：</p>
<blockquote>
<p>具体做法：</p>
<ol>
<li>从原数组取前k个元素</li>
<li>对这k个元素建小顶堆</li>
<li>遍历原数组除去前k个，剩余的元素（[k,n]），和小顶堆的堆顶比较。</li>
<li>若大于堆顶则替换堆顶的位置，并触发堆化。</li>
</ol>
</blockquote>
<p><strong>维护一个大小为 K 的小顶堆</strong>，顺序遍历数组，从数组中取出取数据与堆顶元素比较。</p>
<p>如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；比堆顶元素小则不做处理，继续遍历数组。遍历完数组后堆中的数据就是前 K 大数据。时间复杂度为O(nlogn)。</p>
<p>针对动态数据求得 Top K 就是实时 Top K，即数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。</p>
<p>若每次询问前 K 大数据，都基于当前的数据重新计算的话，性能损耗大。可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻返回给。</p>
<h2 id="利用堆求中位数">利用堆求中位数</h2>
<p>求堆的中位数，也可以简化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>p</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Top(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>问题</p>
<p>中位数就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个数据就是中位数；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个和第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>  个数据，可以随意取一个作为中位数，比如取两个数中靠前的那个，就是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​ 个数据。</p>
<p>对于一组<strong>静态数据</strong>，中位数是固定的，可以先排序，查寻时返回固定值。但<strong>动态数据</strong>却不能先排序</p>
<p><strong>借助堆这种数据结构，不用排序，就可以非常高效地实现求中位数操作。</strong></p>
<p>维护两个堆，一个大顶堆，一个小顶堆。满足两个条件</p>
<ol>
<li><strong>大顶堆中存储前半部分数据，小顶堆中存储后半部分数据；</strong></li>
<li><strong>且小顶堆中的数据都大于大顶堆中的数据</strong>。<br>
这样，大顶堆中的堆顶元素就是要找的中位数。</li>
</ol>
<p>如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，就将这个新数据插入到小顶堆。数据个数是奇数时，大顶堆中的堆顶元素就是中位数；偶数时大堆顶和小堆顶都是。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/08/99/08c29d3e014a4baf5f8148c2271e6099.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/ae/b1/aee4dcaf9d34111870a1d66a6e109fb1.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>当两个堆中的数据个数不符合前面约定的情况时，可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p>
<blockquote>
<p><strong>求接口的 99% 响应时间</strong></p>
<p>中位数的概念就是将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 50% 的数据。99 百分位数的概念可以类比中位数，如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。</p>
<p>1，2，3，……，100中，那 99 百分位数就是 99，因为小于等于 99 的数占总个数的 99%。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/bb/2d/bbb043d369eeef1bb7feadd28c6ea32d.jpg" alt=" " loading="lazy"></figure>
<p>维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n<em>99% 个数据，小顶堆中保存 n</em>1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p>
<p><strong>10 亿个搜索关键词中获取到 Top 10 最热门的搜索关键词？</strong></p>
<p>实际中使用MapReduce</p>
<p>假设10亿关键词中，不重复的有1亿条。</p>
<p>用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，对10亿数据一次加载性能损耗太大。</p>
<p>遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，根据余数，分成10中不同的组。再各自求每组的top10。最后对总共的Top100中取出现最频繁的Top10。</p>
</blockquote>
<h1 id="图">图</h1>
<p>树和图都是非线性表数据结构。树中的元素为节点，图中的元素叫作<strong>顶点</strong>（vertex）。图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫作<strong>边</strong>（edge）。跟顶点相连接的边的条数就叫作顶点的<strong>度</strong>（degree），如微信每个用户有多少个好友。</p>
<p>微博不像微信，它允许单向关注。这种边有方向的图叫作“有向图”。有向图把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）</p>
<p>QQ亲密度。是典型的<strong>带权图</strong>（weighted graph）。每条边都有一个权重（weight）</p>
<table>
<thead>
<tr>
<th>无向图</th>
<th>有向图</th>
<th>带权图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://static001.geekbang.org/resource/image/df/af/df85dc345a9726cab0338e68982fd1af.jpg" alt=" " loading="lazy"></td>
<td><img src="https://static001.geekbang.org/resource/image/c3/96/c31759a37d8a8719841f347bd479b796.jpg" alt="" loading="lazy"></td>
<td><img src="https://static001.geekbang.org/resource/image/55/e8/55d7e4806dc47950ae098d959b03ace8.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="邻接矩阵存储方法">邻接矩阵存储方法</h2>
<p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）</p>
<p>邻接矩阵的底层依赖一个二维数组。</p>
<p>对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将<code>A[i][j]</code>和 <code>A[j][i]</code> 标记为 1；</p>
<p>对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A<code>[i][j]</code> 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将<code>A[j][i]</code> 标记为 1。</p>
<p>对于带权图，数组中就存储相应的权重。</p>
<img src="https://static001.geekbang.org/resource/image/62/d2/625e7493b5470e774b5aa91fb4fdb9d2.jpg" style="zoom:50%;" />
<p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p>
<p>如无向图，如果<code>A[i][j]</code> 等于 1，那 <code>A[j][i]</code> 也肯定等于 1。实际上只需要存储一个就可以了。将其用对角线划分为上下两部分，一半的空间浪费掉了。</p>
<p>如果存储的是<strong>稀疏图</strong>（Sparse Matrix），顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。（比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多。）</p>
<p>邻接矩阵的存储方式优点：</p>
<p>简单、直接，基于多维数组，获取两个顶点的关系时，就非常高效。</p>
<p>方便计算，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall 算法</a>，就是利用矩阵循环相乘若干次得到结果。</p>
<h2 id="邻接表存储方法">邻接表存储方法</h2>
<p>针对邻接矩阵比较浪费内存空间的问题，可以采用<strong>邻接表</strong>（Adjacency List）</p>
<p>邻接表有点像散列表，每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p>
<p>有向图每个顶点对应的链表里面，存储的是<strong>指向的顶点</strong>。</p>
<p>无向图每个顶点的链表中存储的，是跟这个顶点<strong>有边相连的顶点</strong></p>
<table>
<thead>
<tr>
<th>邻接表</th>
<th>逆邻接表</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://static001.geekbang.org/resource/image/03/94/039bc254b97bd11670cdc4bf2a8e1394.jpg" alt="" loading="lazy"></td>
<td><img src="https://static001.geekbang.org/resource/image/50/a1/501440bcffdcf4e6f9a5ca1117e990a1.jpg" alt=" " loading="lazy"></td>
</tr>
</tbody>
</table>
<p><strong>逆邻接表</strong>中，每个顶点的链表中，存储的是指向这个顶点的顶点。如在微博中邻接表存储用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p>
<p>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p>
<blockquote>
<p>微博中，如果要查找某个用户关注了哪些用户，在邻接表中查找；如果要查找某个用户被哪些用户关注了，从逆邻接表中查找。</p>
<p>需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表最合适，跳表插入、删除、查找都非常高效，且跳表中存储的数据本来就是有序的。</p>
<p>微博上亿数据规模无法全部加载内存，可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。或外部存储上，如硬盘、数据库等</p>
</blockquote>
<h1 id="深度广度优先搜索">深度广度优先搜索</h1>
<p>深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。</p>
<pre><code class="language-java">public class Graph { // 无向图
  private int v; // 顶点的个数
  private LinkedList&lt;Integer&gt; adj[]; // 邻接表
  public Graph(int v) {
    this.v = v;
    adj = new LinkedList[v];
    for (int i=0; i&lt;v; ++i) {
      adj[i] = new LinkedList&lt;&gt;();
    }
  }
  public void addEdge(int s, int t) { // 无向图一条边存两次
    adj[s].add(t);
    adj[t].add(s);
  }
}
</code></pre>
<p>广度优先搜索和深度优先搜索是两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A*、IDA* 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。仅适用于图不大的搜索。</p>
<p>E 表示边的个数，V表示顶点的个数</p>
<p>在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。</p>
<p>BFS和DFS的代码 都需要：</p>
<ul>
<li>一个顶点数大小的<code>boolean</code>数组<code>visited</code>，来记录顶点是否被访问过</li>
<li>一个数组prev记录走过的路径。（如 <code>prev[q]=w</code>记录下：q顶点是从w顶点访问而来的，即从w顶点访问量q顶点）</li>
<li>BFS需要一个队列记录下一步可以访问的相邻可达的顶点；DFS需要一个栈或回溯来搜索路径。</li>
</ul>
<h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2>
<p>广度优先搜索（Breadth-First-Search），通俗的理解就是，地毯式层层推进，从起始顶点开始，先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>
<p>广度优先搜索需要借助<strong>队列</strong>来实现，遍历得到的路径就是，起始顶点到终止顶点的<strong>最短路径</strong>。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/4f/3a/4fea8c4505b342cfaf8cb0a93a65503a.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://static001.geekbang.org/resource/image/ea/23/ea00f376d445225a304de4531dd82723.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="https://static001.geekbang.org/resource/image/4c/39/4cd192d4c220cc9ac8049fd3547dba39.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<pre><code class="language-java">public void bfs(int s, int t) {
    if (s == t) return;
    boolean[] visited = new boolean[vertices];//顶点数大小的数组，来记录顶点是否被访问过
    visited[s] = true;
	  //先进先出的队列，来记录与被访问的顶点，相邻的顶点。即下一步可以访问的顶点
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    queue.add(s);
    int[] prev = new int[vertices];//记录搜索路径，作为结果 prev[i]=k 表示i顶点是从k访问过来的
    Arrays.fill(prev, -1);
    while (queue.size() != 0) {
        int w = queue.poll();/*最开始是s*/
        for (int i = 0; i &lt; adj[w].size()/*该顶点的边数*/; i++) {
          /*遍历w顶点的邻接表，即遍历该顶点的边*/
            int q = adj[w].get(i);/*第i个相邻可达顶点q*/
            if (!visited[q]) {/*相邻可达顶点q未被访问过*/
                prev[q] = w;//是从w顶点访问的q顶点
                if (q == t) {//到了目的地
                    print(prev, s, t);
                }
                visited[q] = true;/*q被访问过*/
                queue.add(q);//后续的while循环，可以搜索q所有的边
            }
        }
    }
}
</code></pre>
<h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2>
<p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。在迷宫的某个岔路口，随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p>
<p>深度优先搜索用的是<strong>回溯思想</strong>，非常适合用<strong>递归</strong>实现。也可以说深度优先搜索是借助<strong>栈</strong>来实现的。但深度优先搜索只是能找出路径，但<strong>未必是最短路径</strong>。</p>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://static001.geekbang.org/resource/image/87/85/8778201ce6ff7037c0b3f26b83efba85.jpg" alt="" loading="lazy"></figure>
<p>实线箭头表示遍历，虚线箭头表示回退。</p>
</blockquote>
<pre><code class="language-java">public void dfs(int s, int t) {
    found = false;
    boolean[] visited = new boolean[vertices];/*记录顶点是否被访问过*/
    int[] prev = new int[vertices];/*记录访问路径*/
    Arrays.fill(prev, -1);
    recurDfs(s, t, visited, prev);
    print(prev, s, t);
}
private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
    if (found == true)
        return;
    visited[w] = true;
    if (w == t) {/*找到了*/
        found = true;
        return;
    }
    for (int i = 0; i &lt; adj[w].size(); i++) {/*遍历w顶点的邻接表，找出每个边*/
        int q = adj[w].get(i);//w的相邻可达顶点q
        if (!visited[q]) {
            prev[q] = w;//记录下：从q顶点是从w顶点访问而来的，即从w顶点访问量q顶点
            recurDfs(q, t, visited, prev);//递归再把q做为起点找到t的路径
        }
    }
}
</code></pre>
<h1 id="字符串匹配">字符串匹配</h1>
<p>Java 中的 indexOf()，Python 中的 find() 函数等，它们底层就是依赖接下来要讲的字符串匹配算法。</p>
<p>BF 算法和 RK 算法是单模式串匹配的算法，也就是一个串跟一个串进行匹配。Trie 树和 AC 自动机是多模式串匹配算法，在一个串中同时查找多个串。</p>
<p>RK 算法是 BF 算法的改进，它巧妙借助了哈希算法，让匹配的效率有了很大的提升。</p>
<h2 id="bf-算法">BF 算法</h2>
<p>BF 算法Brute Force ，暴力匹配算法，也叫朴素匹配算法。</p>
<p>字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p>
<p><strong>在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</strong>。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/01/ee/015c85a9c2a4adc11236f9a40c6d57ee.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="rk-算法">RK 算法</h2>
<p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p>
<p>BF算法每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。</p>
<p>RK 算法：**通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。**如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>
<p>尽管模式串与子串比较的效率提高了，但需要额外的哈希算法计算子串哈希值，而且还会遇到哈希冲突的问题，因此要提高哈希算法的效率。</p>
<p>当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身就好了。</p>
<h2 id="bmboyer-moore算法">BM（Boyer-Moore）算法</h2>
<p>BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。</p>
<p>BM算法用到了额外的 3 个数组内存消耗大，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。</p>
<h2 id="kmp-算法基本原理">KMP 算法基本原理</h2>
<p>KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的。</p>
<p>在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong></p>
<img src="https://static001.geekbang.org/resource/image/da/8f/da99c0349f8fac27e193af8d801dbb8f.jpg" style="zoom:50%;" />
<p>KMP 算法和BM 算法的本质非常类似，都是根据规律在遇到坏字符的时候，把模式串往后多滑动几位。BM 算法有两个规则，坏字符和好后缀。KMP 算法借鉴 BM 算法的思想，可以总结成好前缀规则。</p>
<h2 id="trie树">Trie树</h2>
<p>Trie这个术语来自于re<strong>trie</strong>val。</p>
<p>F 算法、RK 算法、BM 算法、KMP 算法四种算法都是单模式串匹配算法, Trie 树是多模式串匹配算法。单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，在一个主串中查找多个模式串。</p>
<p>又称<strong>前缀树</strong>或<strong>字典树</strong>，是一种专门处理字符串匹配的树型结构。常用在搜索引擎的搜索关键词提示功能。</p>
<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p>
<p>如how，hi，her，hello，so，see在这六个字符串中查找匹配。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/f8/6c/f848a7d8bda3d4f8bb4a7cbfaabab66c.jpg" alt="trie1 " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/06/b6/06b45fde2ca8077465e0c557bc749ab6.jpg" alt=" " loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/6d/b9/6dbed0579a60c6d170bd8fde5990bfb9.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/05/f9/05c3c5d534921f00a9ae33e7e65b1bf9.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>当在 Trie 树中查找一个字符串“her”的时候，将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。绿色的路径就是在 Trie 树中匹配的路径。</p>
<p>如果要查找的是字符串“he”，路径的最后一个节点“e”并不是红色的。也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p>
<h3 id="实现">实现</h3>
<p>Trie 树主要有两个操作，<strong>一个是将字符串集合构造成 Trie 树</strong>，就是一个将字符串插入到 Trie 树的过程。<strong>另一个是在 Trie 树中查询一个字符串</strong>。</p>
<p><strong>如何存储一个 Trie 树？</strong></p>
<p>Trie 树是一个<strong>多叉树</strong>。借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针。</p>
<img src="https://static001.geekbang.org/resource/image/f5/35/f5a4a9cb7f0fe9dcfbf29eb1e5da6d35.jpg" style="zoom:50%;" />
<blockquote>
<pre><code class="language-java">class TrieNode {
  char data;
  TrieNode children[26];
}
</code></pre>
<p>假设字符串中只有从 a 到 z 这 26 个小写字母，在数组中下标为 0 的位置，存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针。如果某个字符的子节点不存在，就在对应的下标的位置存储 null。</p>
<p>在 Trie 树中查找字符串的时候，就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。比如，d 的 ASCII 码减去 a 的 ASCII 码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。</p>
</blockquote>
<p>Trie 树的本质是避免重复存储一组字符串的相同前缀子串，一种非常独特的、高效的字符串匹配方法，针对Trie可能浪费内存，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。如<strong>缩点优化</strong>，对只有一个子节点的节点，将此节点与子节点合并。节省空间，但却增加了编码难度。</p>
<p>Trie 树的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie 树最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景。</p>
<h2 id="ac-自动机">AC 自动机</h2>
<p>Aho-Corasick 算法是经典的多模式串匹配算法，典型应用场景是<strong>敏感词过滤系统</strong></p>
<p><strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong></p>
]]></content>
    </entry>
</feed>