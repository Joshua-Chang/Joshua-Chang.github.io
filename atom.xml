<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Joshua-Chang.github.io</id>
    <title>Joshua-Chang`Blog</title>
    <updated>2021-03-11T06:51:00.868Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Joshua-Chang.github.io"/>
    <link rel="self" href="https://Joshua-Chang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Joshua-Chang.github.io/images/avatar.png</logo>
    <icon>https://Joshua-Chang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Joshua-Chang`Blog</rights>
    <entry>
        <title type="html"><![CDATA[计算机组成原理01]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/">
        </link>
        <updated>2021-03-11T06:46:55.000Z</updated>
        <content type="html"><![CDATA[<p>是</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetPack Compose 01]]></title>
        <id>https://Joshua-Chang.github.io/post/jetpack-compose-01/</id>
        <link href="https://Joshua-Chang.github.io/post/jetpack-compose-01/">
        </link>
        <updated>2021-02-28T08:27:34.000Z</updated>
        <content type="html"><![CDATA[<p>@Composable/<em>标记组合函数，可提供其他函数使用</em>/</p>
<pre><code class="language-kotlin">@Composable
fun MyApp(content: @Composable () -&gt; Unit) {/*也可以 组合函数为参数*/
MyTheme{
        Surface(color = Color.Yellow) {
            content()
        }
    }
}
</code></pre>
<p>@Preview/<em>只能用与无参函数</em>/</p>
<h2 id="foundation包">foundation包</h2>
<pre><code class="language-kotlin">@Composable
fun NewsStory() {
    MaterialTheme/*遵循 MaterialTheme板式*/ {
        val typography = MaterialTheme.typography/*版式即TextStyle*/
        //val image= ImageBitmap.imageResource(R.drawable.header)/*弃用*/
        val image2 = painterResource(R.drawable.header)/*BitmapPainter or VectorPainter*/
        Column(modifier = Modifier.padding(16.dp)) {
            val modifier = Modifier
                /*即preferredHeight期望高度，可能改变。不变用requiredHeight，范围用heightIn*/
                .height(180.dp)
                .fillMaxWidth()/*可设置百分比，默认1。具体用width，或size同时设置*/
                .clip(RoundedCornerShape(4.dp))/*Material Design包*/
            Image(
                painter = image2,
                contentDescription = &quot;image&quot;,
                modifier = modifier,/*ScaleType*/
                contentScale = ContentScale.Crop
            )
            Spacer(modifier = Modifier.height(16.dp))/*间隔*/
            Text(
                text = &quot;A day wandering through the sandhill &quot; +
                        &quot;in Shark Fin Cove, and a few of the &quot; +
                        &quot;sights I saw&quot;,
                style = typography.h6/*定义好的TextStyle*/,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            Text(text = &quot;Davenport,California&quot;,style = typography.body2)
            Text(text = &quot;December 2018&quot;,style = typography.body2)
        }
    }
}
</code></pre>
<h2 id="重组">重组</h2>
<p>重组是指在输入更改时，再次调用可组合函数的过程。</p>
<ul>
<li>在命令式界面模型中，如需更改某个微件，您可以在该微件上调用 setter 以更改其内部状态。</li>
<li>在声明式Compose 中，您可以使用新数据再次调用可组合函数。</li>
</ul>
<p>这样做会导致函数进行重组 -- 系统会根据需要，使用新数据重新绘制函数发出的微件。不依赖于该数据的其他函数跳过，不会进行重组。</p>
<p>在 Compose 中编程时，有许多事项需要注意：</p>
<ul>
<li>
<p>可组合函数可以按任何顺序执行、可以并行执行。且重组会跳过尽可能多的可组合函数和 lambda。</p>
<p>因此每个可重组函数应保持独立，且不应有附带效应。</p>
</li>
<li>
<p>重组是乐观的操作，可能会被取消。</p>
</li>
<li>
<p>可组合函数可能会像动画的每一帧一样非常频繁地运行。</p>
</li>
</ul>
<pre><code class="language-kotlin">@Composable
@Deprecated(&quot;Example with bug&quot;)
fun ListWithBug(myList: List&lt;String&gt;) {
    var items = 0
    Row(horizontalArrangement = Arrangement.SpaceBetween) {
        Column {
            for (item in myList) {
                Text(&quot;Item: $item&quot;)
                items++ // Avoid! Side-effect of the column recomposing.
            }
        }
        Text(&quot;Count: $items&quot;)
    }
}
</code></pre>
<pre><code class="language-kotlin">/**
 * Display a list of names the user can click with a header
 */
@Composable
fun NamePicker(
    header: String,
    names: List&lt;String&gt;,
    onNameClicked: (String) -&gt; Unit
) {
    Column {
        // this will recompose when [header] changes, but not when [names] changes
        Text(header, style = MaterialTheme.typography.h5)
        Divider()

        // LazyColumnFor is the Compose version of a RecyclerView.
        // The lambda passed is similar to a RecyclerView.ViewHolder.
        LazyColumnFor(names) { name -&gt;
            // When an item's [name] updates, the adapter for that item
            // will recompose. This will not recompose when [header] changes
            NamePickerItem(name, onNameClicked)
        }
    }
}

/**
 * Display a single name the user can click.
 */
@Composable
private fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) {
    Text(name, Modifier.clickable(onClick = { onClicked(name) }))
}
</code></pre>
<h2 id="state">State</h2>
<pre><code class="language-kotlin">fun MyScreenContent() {
    val countState = remember {
        mutableStateOf(0)
    }
    Column {
        Counter()
        Counter2(count = countState.value,updateCount = {newCount-&gt;
            countState.value=newCount
        })
    }
}

@Composable
fun Counter() {
    val count = remember {
        mutableStateOf(0)
    }
    Button(onClick = { count.value++ }) {
        Text(text = &quot;${count.value} times&quot;)
    }
}
@Composable
fun Counter2(count:Int,updateCount:(Int)-&gt;Unit) {
    Button(onClick = { updateCount(count+1) }) {
        Text(text = &quot;$count times&quot;)
    }
}
</code></pre>
<h2 id="lazycolumn">LazyColumn</h2>
<pre><code class="language-kotlin">@Composable
fun NameList(names: List&lt;String&gt;, modifier: Modifier = Modifier) {
    LazyColumn(modifier = modifier) {
        items(items = names) { name -&gt;
            Greeting(name = name)
            Divider(color = Color.Black)
        }
    }
}
Column(modifier = Modifier.fillMaxHeight()) {
    NameList(names, Modifier.weight(1f))
    Counter2(count = countState.value, updateCount = { newCount -&gt;
        countState.value = newCount
    })
}
</code></pre>
<pre><code class="language-kotlin">@Composable
fun Greeting(name: String) {
    /*by委托：将set/get委托出去*/
    var isSelected by /*Boolean*/remember { mutableStateOf(false) }
    val backgroundColor by /*委托State&lt;Color&gt;*/animateColorAsState(if (isSelected) Color.Red else Color.Transparent)
    Text(text = &quot;hello $name&quot;,
        modifier = Modifier
            .padding(24.dp)
            .background(color = backgroundColor)
            .clickable(onClick = { isSelected = !isSelected })
    )
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Navigator源码分析]]></title>
        <id>https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/</id>
        <link href="https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/">
        </link>
        <updated>2020-12-14T16:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="讨论案例">讨论案例</h3>
<pre><code class="language-xml">activity_main.xml

&lt;fragment
    android:id=&quot;@+id/nav_host_fragment&quot;
    android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:defaultNavHost=&quot;true&quot;
    app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt;

mobile_navigation.xml

&lt;navigation
    android:id=&quot;@+id/mobile_navigation&quot;
    app:startDestination=&quot;@id/navigation_home&quot;&gt;
    &lt;fragment
        android:id=&quot;@+id/navigation_home&quot;
        android:name=&quot;org.devio.as.hi.hirouter.ui.home.HomeFragment&quot;
        tools:layout=&quot;@layout/fragment_home&quot;&gt;
        &lt;argument
            android:name=&quot;name&quot;
            app:argType=&quot;string&quot;
            app:nullable=&quot;true&quot; /&gt;
        &lt;action
            android:id=&quot;@+id/action_navigation_home_to_navigation_notifications&quot;
            app:destination=&quot;@id/navigation_notifications&quot;
            app:launchSingleTop=&quot;true&quot;
            app:popUpTo=&quot;@id/navigation_notifications&quot; /&gt;
        &lt;deepLink
            android:id=&quot;@+id/deepLink&quot;
            app:uri=&quot;www.imooc.com&quot; /&gt;
    &lt;/fragment&gt;
&lt;/navigation&gt;
</code></pre>
<h3 id="navhostfragmentoninflate">NavHostFragment.onInflate:</h3>
<p>去查找声明在NavHostFragment的xml布局文件中的，defaultNavHost、navGraph属性,得到mGraphId</p>
<pre><code class="language-kotlin">onInflate：任何能在xml布局文件中声明的组建，当它们被从xml解析完成，被创建成功后都会调用此方法
activity和dialog是不可以的，因为他们不能在xml布局文件中直接声明
    @CallSuper
    @Override
    public void onInflate(@NonNull Context context, @NonNull AttributeSet attrs,
            @Nullable Bundle savedInstanceState) {
        super.onInflate(context, attrs, savedInstanceState);

        final TypedArray navHost = context.obtainStyledAttributes(attrs, R.styleable.NavHost);
        final int graphId = navHost.getResourceId(R.styleable.NavHost_navGraph, 0);
        if (graphId != 0) {
            mGraphId = graphId;
        }
        navHost.recycle();

        final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.NavHostFragment);
        final boolean defaultHost = a.getBoolean(R.styleable.NavHostFragment_defaultNavHost, false);
        if (defaultHost) {
            mDefaultNavHost = true;
        }
        a.recycle();
    }
</code></pre>
<h3 id="navhostfragmentoncreate">NavHostFragment.onCreate:</h3>
<ul>
<li>往NavigatorProvider内addNavigator：</li>
</ul>
<p>构造NavHostController方法内，先添加不可或缺的ActivityNavigator、和NavGraphNavigator （<navigation/>startDestination）</p>
<p>onCreateNavController方法内，添加DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转</p>
<ul>
<li>配置回退栈</li>
<li>NavController.setGraph(mGraphId)。把声明在NavHostFragment的app:navGraph的id，交给NavController处理（和fragmentController设计原因一样，隔离作用）</li>
</ul>
<pre><code class="language-kotlin">NavHostFragment:
@CallSuper
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final Context context = requireContext();
		//构建NavController对象 内部立即注册两个Navigator：start、activity的
    mNavController = new NavHostController(context);//继承自NavController
		//设置回退栈
    mNavController.setOnBackPressedDispatcher(requireActivity().getOnBackPressedDispatcher());
	  //...
		//通过controller得到Provider，并对其注册DialogFragmentNavigator，FragmentNavigator。以支持dialog、fragment类型的导航跳转
    onCreateNavController(mNavController);
    //。。。

        //把声明在NavHostFragment的xml布局文件中的资源id
				//app:navGraph=&quot;@navigation/mobile_navigation&quot;（navGraph属性）
				//交给NavController处理（和fragmentController设计原因一样，隔离作用）
        mNavController.setGraph(mGraphId);
}
//通过controller得到Provider（存储一个个navigator对象），
//并注册DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转
protected void onCreateNavController(@NonNull NavController navController) {
        navController.getNavigatorProvider().addNavigator(
                new DialogFragmentNavigator(requireContext(), getChildFragmentManager()));
        navController.getNavigatorProvider().addNavigator(createFragmentNavigator());
    }

//立即注册两个Navigator
NavController：
public NavController(@NonNull Context context) {
//....路由首页和activity都是不可或缺的，但fragmentNavigator未必，所以这里注册了两个
//mobile_navigation.xml资源文件加载完，用来启动其中的startDestination对应的页面的
        mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider));
//能给activity提供路由服务的navigator
        mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));
    }
//设置dispatcher后将mOnBackPressedCallback加入callback
void setOnBackPressedDispatcher(@NonNull OnBackPressedDispatcher dispatcher) {
	      //...
        dispatcher.addCallback(mLifecycleOwner, mOnBackPressedCallback);
    }

private final OnBackPressedCallback mOnBackPressedCallback =
            new OnBackPressedCallback(false) {
        @Override
        public void handleOnBackPressed() {
            popBackStack();//回退栈
        }
    };
</code></pre>
<h3 id="navinflaterinflate">NavInflater().inflate</h3>
<p>解析路由资源文件返回NavGraph对象：由路由资源xml定义的节点名，得到相应类型的Navigator，在去创建相应类型的Destination节点。</p>
<p><navigation/>特殊：会得到NavGraphNavigator类型的navigator，并创建出NavGraph类型的节点。</p>
<p>NavGraph是特殊的Destination节点：</p>
<ul>
<li>成员：含app:startDestination的id，和SparseArrayCompat<NavDestination>的路由节点集合</li>
<li>自己可以嵌套自己，即mobile_navigation.xml内的<navigation/>标签内还可以有<navigation/>形成一个个的路由组，且每组以各自的app:startDestination为起始点</li>
<li>NavInflater().inflate时遇到NavGraph类型的节点，递归调用inflate，将自节点加入其路由节点集合</li>
</ul>
<p>onGraphCreated：路由文件解析/节点创建完毕，开始路由跳转流程NavController.navigate</p>
<pre><code class="language-kotlin">NavController：
		@CallSuper
    public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) {
        setGraph(getNavInflater().inflate(graphResId)/*得到NavGraph*/, startDestinationArgs);
    }

		public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) {
        if (mGraph != null) {
            // Pop everything from the old graph off the back stack
            popBackStackInternal(mGraph.getId(), true);
        }
        mGraph = graph;//将得到的NavGraph保存起来
				//第一阶段：路由文件解析节点创建流程完毕
        onGraphCreated(startDestinationArgs);
				//内部会调用navigate(mGraph, startDestinationArgs, null, null);启动第一个路由节点//第二阶段路由跳转流程开始					
  }

NavInflater：
//layoutInflater专门解析布局资源文件，NavInflater专门解析路由资源文件，返回NavGraph对象
public NavGraph inflate(@NavigationRes int graphResId) {
      //。。。路由xml文件（app:navGraph=&quot;@navigation/mobile_navigation&quot;）的解析
			//生产路由节点对象
			NavDestination destination = inflate(res, parser, attrs, graphResId);
			if (!(destination instanceof NavGraph)) {//如果返回结果不是NavGraph类型则会抛出异常。即mobile_navigation.xml根结点必须&lt;navigation/&gt;标签
                throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot;
                        + &quot; did not inflate into a NavGraph&quot;);
            }
            return (NavGraph) destination;
    }

private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser,
            @NonNull AttributeSet attrs, int graphResId)
            throws XmlPullParserException, IOException {
//根据mobile_navigation.xml中的定义的节点类型，
//特殊：mobile_navigation.xml中的第一个节点为navigation解析出NavGraphNavigator类型的navigator导航
//正常：后边的节点为activity/fragment等，解析出fragmentnavigator/activitynavigator等类型的navigator
        Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName());
//使用navigator创建Destination节点（ADestination/FDestination等），以activityNavigator为例
//使用NavGraphNavigator创建出NavGraph
        final NavDestination dest = navigator.createDestination();
        dest.onInflate(mContext, attrs);//NavDestination节点（具体是子类activity或fragment）解析填充
				//...
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
              // ....
            } else if (dest instanceof NavGraph) {//如果节点是NavGraph则递归调用自己，继续解析并加入到NavGraph的节点集合中
                ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId));
            }
        }
        return dest;
}

ActivityNavigator：
public Destination createDestination() {
        return new Destination(this);//传入navigator自己
    }
ActivityNavigator$Destination
public static class Destination extends NavDestination{
	super(activityNavigator);//调父类NavDestination
}

NavDestination节点:的构造需要创建NavDestination的Navigator，或navigatorName
//无论是activity还是fragment类型的节点，
//创建时都需要把创建他的Navigator传递进来，以便正确的跳转
//从而把Destination节点和创建他的Navigator导航 关联起来
public NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) {}
public NavDestination(@NonNull String navigatorName) {}

NavGraphNavigator：特殊Navigator
public NavGraph createDestination() {
        return new NavGraph(this);
    }
NavGraph：特殊Destination节点，自己可以嵌套自己，
即mobile_navigation.xml内的&lt;navigation/&gt;标签内还可以有&lt;navigation/&gt;
形成一个个的路由组，且每组以各自的app:startDestination为起始点
例子：电商交易支付完成后，将一组都关闭

NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; {
    final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;();//路由节点的集合
    private int mStartDestId;//该集合的启动ID app:startDestination=&quot;@id/navigation_home&quot;
    private String mStartDestIdName;
}
</code></pre>
<h3 id="navcontrollernavigate">NavController.navigate</h3>
<p>第二阶段路由跳转流程开始</p>
<p>根据NavGraph这一特殊节点的name，得到NavGraphNavigator对象</p>
<pre><code class="language-kotlin">private void navigate(@NonNull NavDestination node, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    //...
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            node.getNavigatorName());//根据NavGraph的name，找创建该节点的到navigator对象 即NavGraphNavigator对象
    Bundle finalArgs = node.addInDefaultArgs(args);
    NavDestination newDest = navigator.navigate(node, finalArgs,//然后发起真正的路由
            navOptions, navigatorExtras);
    mBackStack.add(entry);//把路由节点添加到回退栈
}
</code></pre>
<h3 id="navgraphnavigatornavigate">NavGraphNavigator.navigate</h3>
<p>找到<navigator/>内 的startDestination节点</p>
<p>根据startDestination节点的name，在NavigatorProvider里找到创建他的具体的f/a/dialog等类型的Navigator</p>
<p>再让具体f/a/dialog等类型的Navigator去处理路由</p>
<pre><code class="language-kotlin">NavGraphNavigator：
public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) {
    int startId = destination.getStartDestination();//app:startDestination的id

		//根据app:startDestination的id找到相应的startDestination节点
    NavDestination startDestination = destination.findNode(startId, false);
	
		//根据startDestination节点的name属性，找到创建他的具体navigator
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            startDestination.getNavigatorName());//此时的navigator可能是f/a/dialog等类型的Navigator
		//再将路由操作委托给f/a/dialog等类型的Navigator
    return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args),
            navOptions, navigatorExtras);
}

1、activityNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
				//构造intent
        Intent intent = new Intent(destination.getIntent());
        if (args != null) {
            intent.putExtras(args);//添加args
            //。。。
        }
				//配置启动模式
        if (!(mContext instanceof Activity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) {
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        }

				//进出动画等。。。

				mContext.startActivity(intent);//通过startActivity完成路由
    }

2、fragmentNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();//根据destination节点得到类名
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = instantiateFragment(mContext, mFragmentManager,
                className, args);//根据类名反射得到fragment实例
        frag.setArguments(args);//设置args
        final FragmentTransaction ft = mFragmentManager.beginTransaction();//开启事务
				
        //进出动画等。。。

        ft.replace(mContainerId, frag);
				//此处使用的是replace，因此使用Navigator路由时切换fragment时，声明周期重新执行
    }

3、dialogFragmentNavigator
public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = mFragmentManager.getFragmentFactory().instantiate(
                mContext.getClassLoader(), className);//反射
        if (!DialogFragment.class.isAssignableFrom(frag.getClass())) {//类型判断：是否时dialogFragment类型的
            throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName()
                    + &quot; is not an instance of DialogFragment&quot;);
        }
        final DialogFragment dialogFragment = (DialogFragment) frag;//上文以确定为dialogFragment
        dialogFragment.setArguments(args);//添加args
        dialogFragment.getLifecycle().addObserver(mObserver);

				//show出dialogFragment
        dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++);
        return destination;
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1607965068319.png" alt="" loading="lazy"></figure>
<h3 id="缺点">缺点：</h3>
<ol>
<li>节点必须在路由文件mobile_navigation.xml中定义</li>
<li>fragment类型节点的路由操作，是使用replace，会导致fragment页面声明周期重启，数据的重新加载</li>
<li>不支持路由过程的拦截监听</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update MacOS to Mojave Vim: Caught deadly signal SEGV]]></title>
        <id>https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/</id>
        <link href="https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/">
        </link>
        <updated>2018-10-24T03:51:37.000Z</updated>
        <content type="html"><![CDATA[<h5 id="极有可能是youcompleteme或者powerline等插件的问题">极有可能是<em>YouCompleteMe</em>或者<em>Powerline</em>等插件的问题</h5>
<pre><code class="language-bash">Vim: Caught deadly signal SEGV

Error detected while processing function &lt;SNR&gt;78_PollServerReady[7]..&lt;SNR&gt;78_Pyeval:Vim: Finished.

line    4:
Exception MemoryError: MemoryError() in &lt;module 'threading' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'&gt; ignored
[1]    72868 segmentation fault  vim Test.java
</code></pre>
<h5 id="解决">解决：</h5>
<pre><code class="language-bash">brew install vim --with-lua --with-override-system-vi
</code></pre>
<p>and restart shell , fixed</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App使用统计与静默拍摄]]></title>
        <id>https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/</id>
        <link href="https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/">
        </link>
        <updated>2018-10-03T10:29:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="app使用统计">App使用统计</h3>
<p>监控或统计手机内的app使用情况可以从两个思路考虑</p>
<ul>
<li>
<p>统计每个app的使用时长</p>
<p>UsageStatsManager这一统计管理类，可以查出每个app简单的最近开启时间、某时限内的使用时长等信息。更复杂的手机亮屏次数，开启<!--more-->应用次数可以使用UsageStatsService或者过滤包名的形式统计。</p>
</li>
<li>
<p>统计每个Android系统耗电情况的每个app占比</p>
<p>在做电量优化的时候经常会通过adb使用Battery-Historian分析电量报告，所以由此灵感，具体的实现还需要头脑风暴一下。</p>
</li>
</ul>
<h5 id="对app使用时常统计的简单实现">对app使用时常统计的简单实现</h5>
<ol>
<li>
<p>开启ACTION_USAGE_ACCESS_SETTINGS权限</p>
<figure data-type="image" tabindex="1"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2lhoyj308r0fkt9b.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>得到使用分析管理UsageStatsManager并根据时限查询统计状态</p>
<pre><code class="language-java">UsageStatsManager manager = (UsageStatsManager) getApplicationContext().getSystemService(USAGE_STATS_SERVICE);
List&lt;UsageStats&gt; stats = manager.queryUsageStats(UsageStatsManager.INTERVAL_MONTHLY, beginCal.getTimeInMillis(), endCal.getTimeInMillis());
</code></pre>
</li>
<li>
<p>根据UsageStats查询每个app的统计信息</p>
<pre><code class="language-java">for (UsageStats us : stats) {
    try {
        PackageManager pm = getApplicationContext().getPackageManager();
        ApplicationInfo applicationInfo = pm.getApplicationInfo(us.getPackageName(), PackageManager.GET_META_DATA);
        if ((applicationInfo.flags &amp; applicationInfo.FLAG_SYSTEM) &lt;= 0) {
            sb.append(pm.getApplicationLabel(applicationInfo)+&quot; 使用时长：&quot;+formatTime(us.getTotalTimeInForeground())+&quot;\n&quot;);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2tdo9j308r0fkabf.jpg" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="静默后台拍摄">静默后台拍摄</h3>
<h5 id="静默拍摄的简单思路">静默拍摄的简单思路</h5>
<ul>
<li>
<p>将SurfaceView或TextureView这一采集呈现的layout参数设为最小。（不能设置visibility：gone 不会采集到图像），可见现在采集时没有采集预览，但采集到的bitmap可以成功设置。</p>
<figure data-type="image" tabindex="3"><img src="https://thumbs.gfycat.com/DenseFailingGroundhog-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
<li>
<p>再将SurfaceView所在的Activity主题透明化</p>
<p>可见此时的采集效果从UI上看静默进行。”拍摄“按键只是方便展示效果，如果使用Service去掉用则</p>
<p>真正实现了后台静默采集的效果，至于采集到bitmap可以储存也可以直接用三方sdk做一些图像分析。</p>
<figure data-type="image" tabindex="4"><img src="https://thumbs.gfycat.com/SpryBeautifulChafer-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开发一个IntelliJ IDEA插件]]></title>
        <id>https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/</id>
        <link href="https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/">
        </link>
        <updated>2017-12-26T16:03:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="灵感">灵感</h3>
<p>IDEA和AS中的大小写切换快捷键，一直是比较良心的。</p>
<p>在声明一些常量时极其省事，但常量由多个单词组成时，还要手动的加上下划线又及其麻烦。</p>
<h3 id="思路">思路</h3>
<p>开发一个插件，把符合驼峰命名的多单词组成名字，分别加上下划线。反之，把由下划线拼成的名字变成驼峰<!--more--></p>
<p>命名。</p>
<h3 id="eg">e.g.</h3>
<ul>
<li>
<p>light_dialog_type --&gt; lightDialogType</p>
</li>
<li>
<p>anApplePie --&gt; an_apple_pie</p>
</li>
<li>
<p>homeActivityTimer --&gt;home_activity_timer --&gt; HOME_ACTIVITY_TIMER</p>
</li>
</ul>
<h3 id="实现">实现</h3>
<ol>
<li>新建一个IntelliJ Platform Plugin项目，创建相应的action复写actionPerformed()</li>
<li>得到AS/IDEA选中的常量名</li>
</ol>
<pre><code class="language-java">       //获取Editor和Project对象
        Editor editor = e.getData(PlatformDataKeys.EDITOR);
        Project project = e.getData(PlatformDataKeys.PROJECT);
        if (editor == null || project == null)
            return;

        //获取SelectionModel和Document对象
        SelectionModel selectionModel = editor.getSelectionModel();
        Document document = editor.getDocument();

        selectionModel.selectWordAtCaret(false);
        //拿到选中部分字符串
        String selectedText = selectionModel.getSelectedText();

        //得到选中字符串的起始和结束位置
        int startOffset = selectionModel.getSelectionStart();
        int endOffset = selectionModel.getSelectionEnd();
</code></pre>
<ol start="3">
<li>新线程中去执行驼峰命名与下划线的转换操作</li>
</ol>
<pre><code class="language-java">        //对文档进行操作部分代码，需要放入Runnable接口中实现，由IDEA在内部将其通过一个新线程执行
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                if (isLine(selectedText)) {
                    document.replaceString(startOffset, endOffset, lineToHump(selectedText));
                }else {
                    String temp=null;
                    if (selectedText.charAt(0) == 'm' &amp;&amp; selectedText.charAt(1) &lt;= 'Z' &amp;&amp; selectedText.charAt(1) &gt;= 'A') {//情况一：把mActivityInstance这种变为ActivityInstance
                        temp = selectedText.substring(1);
                    }
                    String result = temp != null ? temp : selectedText;
                    result=humpToLine(result);
                    if (result.charAt(0)=='_') {
                        result=result.substring(1);
                    }
                    document.replaceString(startOffset, endOffset, result);
                }
            }
        };
</code></pre>
<ol start="4">
<li>加入任务，由IDEA调度执行这个任务</li>
</ol>
<pre><code class="language-java">WriteCommandAction.runWriteCommandAction(project, runnable);
</code></pre>
<ol start="5">
<li>其他：转换方法都是些常用算法不做赘述；Action的update方法看需求情况编写。</li>
</ol>
<h3 id="完工">完工</h3>
<p>发布在JetBrains给提提意见：<a href="https://plugins.jetbrains.com/plugin/11121-underline-camel-toggle-case">Underline Camel Toggle Case</a> 或在AS/IDEA的plugin中搜索</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[View滑动的几种方式]]></title>
        <id>https://Joshua-Chang.github.io/post/View滑动的几种方式/</id>
        <link href="https://Joshua-Chang.github.io/post/View滑动的几种方式/">
        </link>
        <updated>2017-09-28T06:27:58.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="view的滑动">View的滑动</h3>
<p>实现View滑动大概有：layout()、offsetLeftAndRight()／offsetTopAndBottom()、LayoutParams、动画、scollTo与scollBy和Scroller等几种方法。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="view的滑动">View的滑动</h3>
<p>实现View滑动大概有：layout()、offsetLeftAndRight()／offsetTopAndBottom()、LayoutParams、动画、scollTo与scollBy和Scroller等几种方法。</p>
<!--more-->
<h3 id="layout">layout()</h3>
<pre><code class="language-java">layout(getLeft()+offsetX, getTop()+offsetY,getRight()+offsetX , getBottom()+offsetY);
</code></pre>
<h3 id="offset">offset</h3>
<pre><code class="language-java">offsetLeftAndRight(offsetX);
offsetTopAndBottom(offsetY);
</code></pre>
<h3 id="layoutparams">LayoutParams</h3>
<pre><code class="language-java">ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
layoutParams.leftMargin = getLeft() + offsetX;
layoutParams.topMargin = getTop() + offsetY;
setLayoutParams(layoutParams);
</code></pre>
<h3 id="scollby">scollBy</h3>
<p>反向移动父布局画布</p>
<pre><code class="language-java">((View)getParent()).scrollBy(-offsetX,-offsetY);
</code></pre>
<h3 id="scroller">Scroller</h3>
<ul>
<li>初始化Scroller</li>
</ul>
<pre><code class="language-java">public CustomView(Context context, AttributeSet attrs) {
      super(context, attrs);
      mScroller = new Scroller(context);
  }
</code></pre>
<ul>
<li>
<p>复写computeScroll()  在绘制View的时候在draw()中调用该方法</p>
<p>调用父类的scrollTo()方法并通过Scroller来不断获取当前的滚动值，并调用invalidate()不断重绘，重绘就会调用computeScroll()方法，连贯成移动</p>
</li>
</ul>
<pre><code class="language-java">@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
         //通过不断的重绘不断的调用computeScroll方法
         invalidate();
    }  
}
</code></pre>
<ul>
<li>startScroll()</li>
</ul>
<pre><code class="language-java">public void smoothScrollTo(int destX,int destY){
      int scrollX=getScrollX();
      int delta=destX-scrollX;
      //1000秒内滑向destX
      mScroller.startScroll(scrollX,0,delta,0,2000);
      invalidate();
  }
</code></pre>
<ul>
<li>外部调用</li>
</ul>
<pre><code class="language-java">mCustomView.smoothScrollTo(-400,0);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TabLayout indicator宽度工具类]]></title>
        <id>https://Joshua-Chang.github.io/post/TabLayout-indicator宽度工具类/</id>
        <link href="https://Joshua-Chang.github.io/post/TabLayout-indicator宽度工具类/">
        </link>
        <updated>2017-09-22T13:35:36.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="宽度工具类">宽度工具类</h4>
<p>一劳永逸之法</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="宽度工具类">宽度工具类</h4>
<p>一劳永逸之法</p>
<!--more-->
<pre><code class="language-java">public void reflex(final TabLayout tabLayout){
    //了解源码得知 线的宽度是根据 tabView的宽度来设置的
    tabLayout.post(new Runnable() {
        @Override
        public void run() {
            try {
                //拿到tabLayout的mTabStrip属性
                LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0);

                int dp10 = dp2px(tabLayout.getContext(), 10);

                for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) {
                    View tabView = mTabStrip.getChildAt(i);

                    //拿到tabView的mTextView属性  tab的字数不固定一定用反射取mTextView
                    Field mTextViewField = tabView.getClass().getDeclaredField(&quot;mTextView&quot;);
                    mTextViewField.setAccessible(true);

                    TextView mTextView = (TextView) mTextViewField.get(tabView);

                    tabView.setPadding(0, 0, 0, 0);

                    //因为我想要的效果是   字多宽线就多宽，所以测量mTextView的宽度
                    int width = 0;
                    width = mTextView.getWidth();
                    if (width == 0) {
                        mTextView.measure(0, 0);
                        width = mTextView.getMeasuredWidth();
                    }

                    //设置tab左右间距为10dp  注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的
                    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();
                    params.width = width ;
                    params.leftMargin = dp10;
                    params.rightMargin = dp10;
                    tabView.setLayoutParams(params);

                    tabView.invalidate();
                }

            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    });

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IPC机制之Messenger]]></title>
        <id>https://Joshua-Chang.github.io/post/IPC机制之Messenger/</id>
        <link href="https://Joshua-Chang.github.io/post/IPC机制之Messenger/">
        </link>
        <updated>2017-06-02T02:42:31.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，通过Messenger可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据就可以轻松实现数据在进程间传递了。</p>
<p>在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。</p>
<p>Messenger的使用很简单，由于它一次处理一个请求，因此在服务端不用考虑线程同步的问题。Messenger实现进程间通信大致可以分为以下几步，分为服务端和客户端。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，通过Messenger可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据就可以轻松实现数据在进程间传递了。</p>
<p>在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。</p>
<p>Messenger的使用很简单，由于它一次处理一个请求，因此在服务端不用考虑线程同步的问题。Messenger实现进程间通信大致可以分为以下几步，分为服务端和客户端。</p>
<!--more-->
<h4 id="服务端进程">服务端进程</h4>
<p>服务端新建一个Service来处理客户端发起的请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<p>如果需要客服端能够回应客户端，那么和服务端一样，在客户端还需要创建一个新的Messenger,并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<pre><code class="language-java">public class MyService extends Service {
    public static final int MSG_FROM_SERVICE=2;
    public MyService() {}
    public static class MessagerHandler extends Handler{
        @Override
        public void handleMessage(Message msg) {
            if (msg.what==MainActivity.MSG_FROM_CLIENT){
                Log.e(&quot;xxx&quot;,&quot;msg from client: &quot;+msg.getData().getString(&quot;msg&quot;));

                Messenger mReplyTo = msg.replyTo;
                Message mMessage=Message.obtain(null,MSG_FROM_SERVICE);
                Bundle mBundle=new Bundle();
                mBundle.putString(&quot;reply&quot;,&quot;Hi,service received succeed&quot;);
                mMessage.setData(mBundle);
                try {
                    mReplyTo.send(mMessage);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }
    }
  //1.创建Messenger（需要handler）对象
    private Messenger mMessenger=new Messenger(new MessagerHandler());
    @Override
    public IBinder onBind(Intent intent) {
      //2.在Service的onBind中返回这个Messenger对象底层的Binder 供客户端使用
        return mMessenger.getBinder();
    }
}
</code></pre>
<h4 id="客户端进程">客户端进程</h4>
<p>客户端进程中首先要绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送类型为Message的消息了，message内可以存入Bundle。</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    public static final int MSG_FROM_CLIENT=1;

    private ServiceConnection mServiceConnection=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
          //2.绑定成功后,根据上文返回的IBinder对象创建一个Messenger
            Messenger mMessenger=new Messenger(service);
            Message mMessage = Message.obtain(null, MSG_FROM_CLIENT);
            Bundle mBundle=new Bundle();
            mBundle.putString(&quot;msg&quot;,&quot;hello,this msg from client&quot;);
            mMessage.setData(mBundle);

            mMessage.replyTo=mReplyMessenger;
            try {
                mMessenger.send(mMessage);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };
    private static class ReceiveHandler extends Handler{
        @Override
        public void handleMessage(Message msg) {
            if (msg.what==MyService.MSG_FROM_SERVICE){
                Log.e(&quot;xxx&quot;,&quot;msg from service: &quot;+msg.getData().getString(&quot;reply&quot;));
            }
        }
    }
    private Messenger mReplyMessenger=new Messenger(new ReceiveHandler());

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      //1.绑定服务端的Service
        Intent mIntent=new Intent(this,MyService.class);
        bindService(mIntent,mServiceConnection,BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        unbindService(mServiceConnection);
        super.onDestroy();
    }
}
</code></pre>
<h4 id="extra">Extra</h4>
<p>注册service时为新的全局进程</p>
<pre><code class="language-xml">&lt;service
    android:name=&quot;.MyService&quot;
    android:process=&quot;com.coolapk.developer_verify_package&quot;&gt;
&lt;/service&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dagger2的Qualifier与Scope]]></title>
        <id>https://Joshua-Chang.github.io/post/dagger2的Qualifier与Scope/</id>
        <link href="https://Joshua-Chang.github.io/post/dagger2的Qualifier与Scope/">
        </link>
        <updated>2017-05-21T11:18:57.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="qualifier即named">Qualifier即Named</h4>
<p>当module的@Provides提供相同变量的不同属性时：用于区分把哪一个初始化</p>
<h5 id="module">Module</h5>
<pre><code class="language-java">@Module
public class ClothModule {
    @Blue
    @Provides
    public Cloth getBluecloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;蓝&quot;);
        return mCloth;
    }
    @Named(&quot;Red&quot;)
    @Provides
    public Cloth getRedcloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;红&quot;);
        return mCloth;
    }
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="qualifier即named">Qualifier即Named</h4>
<p>当module的@Provides提供相同变量的不同属性时：用于区分把哪一个初始化</p>
<h5 id="module">Module</h5>
<pre><code class="language-java">@Module
public class ClothModule {
    @Blue
    @Provides
    public Cloth getBluecloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;蓝&quot;);
        return mCloth;
    }
    @Named(&quot;Red&quot;)
    @Provides
    public Cloth getRedcloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;红&quot;);
        return mCloth;
    }
}
</code></pre>
<!--more-->
<h5 id="component">Component</h5>
<pre><code class="language-java">@Component(modules=ClothModule.class)
public interface ClothCompetent {
    void inject(MainActivity mainActivity);
}
</code></pre>
<h5 id="activity">Activity</h5>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    TextView mTextView;
    @Named(&quot;Red&quot;)
    @Inject
    Cloth mClothRed;
    @Blue
    @Inject
    Cloth mClothBlue;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView= (TextView) findViewById(R.id.tv1);
        ClothCompetent mClothCompetent=DaggerClothCompetent.builder().clothModule(new ClothModule()).build();
        mClothCompetent.inject(this);
        mTextView.setText(mClothRed+&quot;\n&quot;+mClothBlue);
    }
}
</code></pre>
<h5 id="qualifier">Qualifier</h5>
<p>自定义的Qualifier与官方的Named原理一样</p>
<pre><code class="language-java">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Blue {
}
</code></pre>
<p>官方的Named</p>
<pre><code class="language-java">@Qualifier
@Documented
@Retention(RUNTIME)
public @interface Named {

    /** The name. */
    String value() default &quot;&quot;;
}
</code></pre>
<h4 id="scope即singleton">Scope即Singleton</h4>
<p>以Component为依据，在指定范围内的单例</p>
<h5 id="module-2">Module</h5>
<ol>
<li>在@Provides为外界提供Jacket时，参数中用到了Cloth，必须在Module中@Provides为Jacket提供Cloth</li>
<li>自定义的Qualifier和Named也可以在参数中使用</li>
</ol>
<pre><code class="language-java">@Module
public class JacketModule {
    @Provides
    public Jacket getJacket(@Named(&quot;Red&quot;) Cloth cloth){
        return new Jacket(cloth);
    }
    @Singleton
    @Named(&quot;Red&quot;)
    @Provides
    public Cloth getRedCloth(){
       Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;红&quot;);
        return mCloth;
    }
    @Blue
    @Provides
    public Cloth getBluecloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;蓝&quot;);
        return mCloth;
    }
}
</code></pre>
<h5 id="component-2">Component</h5>
<p>在用到的Cloth和Component上同时添加@Singleton，此时Cloth为单例</p>
<pre><code class="language-java">@Singleton
@Component(modules = JacketModule.class)
public interface JacketComponent {
    void inject(MainActivity mainActivity);
}
</code></pre>
<h5 id="activity-2">Activity</h5>
<p>此时的Cloth和JacketRed.getCloth()为同一个</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    TextView mTextView;
    @Named(&quot;Red&quot;)
    @Inject
    Cloth mClothRed;
    @Inject
    Jacket mJacketRed;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView= (TextView) findViewById(R.id.tv1);
        JacketComponent mJacketComponent = DaggerJacketComponent.builder().jacketModule(new JacketModule()).build();
        mJacketComponent.inject(this);
        mTextView.setText((mJacketRed.getCloth() == mClothRed) + &quot;&quot;);
    }
}
</code></pre>
<h5 id="scope">Scope</h5>
<p>自定义的Scope与官方的Singleton原理一样，替换Singleton为JacketSingleton仍返回true</p>
<p>自定义的JacketSingleton：在JacketSingleton作用域内单例</p>
<pre><code class="language-java">@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface JacketSingleton {
}
</code></pre>
<p>官方的Singleton</p>
<pre><code class="language-java">@Scope
@Documented
@Retention(RUNTIME)
public @interface Singleton {}
</code></pre>
<h4 id="dependencies">dependencies</h4>
<p>实例：分别创建两个Activity，跳转后的实例为同一个（工具类多此用法在app层单例）</p>
<h5 id="分别创建两个module">分别创建两个Module</h5>
<p>JacketModule与JacketModule2</p>
<h5 id="创建component">创建Component</h5>
<h6 id="方法一dependencies">方法一：dependencies</h6>
<pre><code class="language-java">@JacketSingleton
@Component(modules = JacketModule.class,dependencies = BaseComponent.class)
public interface JacketComponent {
    void inject(MainActivity mainActivity);
}
</code></pre>
<h6 id="方法二subcomponent">方法二：Subcomponent</h6>
<pre><code class="language-java">@JacketSingleton
@Subcomponent(modules = JacketModule2.class)
public interface JacketComponent2 {
    void inject(MainActivity2 mainActivity);
}
</code></pre>
<h5 id="创建basemodule">创建BaseModule</h5>
<pre><code class="language-java">@Module
public class BaseModule {
    @Singleton
    @Provides
    public Jacket getJacket(@Named(&quot;Red&quot;) Cloth cloth){
        return new Jacket(cloth);
    }
    @Singleton
    @Provides
    @Named(&quot;Red&quot;)
    public Cloth getRedCloth(){
        Cloth mCloth=new Cloth();
        mCloth.setColor(&quot;红&quot;);
        return mCloth;
    }
}
</code></pre>
<h5 id="创建basecomponent">创建BaseComponent</h5>
<pre><code class="language-java">@Singleton
@Component(modules = BaseModule.class)
public interface BaseComponent {
    Jacket getJacket();//dependencies依赖声明的方式
    JacketComponent2 getJacketComponent2(JacketModule2 jacketModule2);//@Subcomponent使用的声明方式,声明一个返回值为子组件的方法,子组件需要什么Module,就在方法参数中添加什么
}
</code></pre>
<h5 id="在app中初始化basecomponent">在app中初始化BaseComponent</h5>
<pre><code class="language-java">public class App extends Application {
        private BaseComponent baseComponent;
        @Override
        public void onCreate() {
            super.onCreate();
            baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build();
        }

        public BaseComponent getBaseComponent() {
            return baseComponent;
        }
}
</code></pre>
<h5 id="在两个activity中使用">在两个Activity中使用</h5>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    TextView mTextView;
    @Named(&quot;Red&quot;)
    @Inject
    Cloth mClothRed;
    @Inject
    Jacket mJacketRed;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView= (TextView) findViewById(R.id.tv1);
        JacketComponent mJacketComponent = DaggerJacketComponent.builder().baseComponent(((App) getApplication()).getBaseComponent()).jacketModule(new JacketModule()).build();
        mJacketComponent.inject(this);
        mTextView.setText(mJacketRed.hashCode()+&quot;&quot;);
    }
    public void go(View view) {
        Intent intent = new Intent(this,MainActivity2.class);
        intent.putExtra(&quot;xx&quot;,mJacketRed.hashCode()+&quot;&quot;);
        startActivity(intent);
    }
}
</code></pre>
<pre><code class="language-java">public class MainActivity2 extends AppCompatActivity {
    TextView mTextView;
    @Named(&quot;Red&quot;)
    @Inject
    Cloth mClothRed;
    @Inject
    Jacket mJacketRed;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);
        mTextView= (TextView) findViewById(R.id.tv2);
        App application = (App) getApplication();
        application.getBaseComponent().getJacketComponent2(new JacketModule2()).inject(this);
        String mString = (String) getIntent().getExtras().get(&quot;xx&quot;);
        mTextView.setText(mString+&quot;\n&quot;+mJacketRed.hashCode()+&quot;&quot;);
    }
}
</code></pre>
<h5 id="结论">结论</h5>
<p>分别在两个Activity中初始化的Jacket哈希值相同，为同一个变量，app层单例。</p>
<h4 id="lazy与provider">Lazy与Provider</h4>
<p>Lazy用于延迟加载,所谓的懒加载就是当你需要用到该依赖对象时,Dagger2才帮你去获取一个;Provide用于强制重新加载,也就是每一要用到依赖对象时,Dagger2都会帮你依赖注入一次</p>
<pre><code class="language-java">    @Inject //Lazy声明方式
    Lazy&lt;Cloth&gt; redCloth;
    @Inject //Provider声明方式
    Provider&lt;Shoe&gt; shoe;
</code></pre>
]]></content>
    </entry>
</feed>