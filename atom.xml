<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Joshua-Chang.github.io</id>
    <title>Joshua-Chang`Blog</title>
    <updated>2021-06-20T10:26:17.550Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Joshua-Chang.github.io"/>
    <link rel="self" href="https://Joshua-Chang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Joshua-Chang.github.io/images/avatar.png</logo>
    <icon>https://Joshua-Chang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Joshua-Chang`Blog</rights>
    <entry>
        <title type="html"><![CDATA[计算机网路]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-wang-lu/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-wang-lu/">
        </link>
        <updated>2021-06-07T05:40:09.000Z</updated>
        <content type="html"><![CDATA[<p>公司内网中每个路由器、交换机构成一级子网。最高级的路由器在公司网络的边缘，它可以将网络内部节点连接到其他的网络（网络外部）。本地网络提供商（ISP）提供的互联网先到达边缘的路由器，然后再渗透到内部的网络节点。公司内部的若干服务器可以通过交换机形成一个局域网络；公司内部的办公设备，比如电脑和笔记本，也可以通过无线路由器或者交换机形成局域网络。局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M01/38/64/Cgp9HWB5O5KAFGFAAAD-82hpYWc483.png" alt="Drawing 2.png" style="zoom: 50%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image6/M00/38/6D/CioPOWB5O7uAUZ7qAAB_rmbTigw120.png" alt="Drawing 4.png" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>通信<strong>链路</strong>（Communication Link），用于传输网络信号。公司<strong>内网</strong>从<strong>本地网络服务提供商</strong> （Internet Service Provider） 接入，然后内部再分成一个个<strong>子网</strong>。路径分叉时需要进行<strong>交换</strong>（Switch），数据从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径，常见的交换设备是链路层交换机（Link-Layer Switch）和路由器（Router），交换机连接多台设备，路由器连接两个网络，但是路由器通常也具有交换机的功能。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/38/6D/Cgp9HWB5RAmAZRwzAACtAP-CPWs242.png" alt="Drawing 1.png" style="zoom: 25%;" />
<p>TCP（Transport Control Protocol）是一个传输层协议：提供主机到主机的（Host-To-Host）数据的可靠传输，支持全双工，是一个连接导向的协议。</p>
<p>TCP 上层应用层：不同应用要使用TCP的能力，通过端口号区分应用。</p>
<p>TCP 下层网络层：提供地址到地址的通信（Address-To-Address），IP 协议解决地址到地址的通信。</p>
<p>网络层只负责ip地址到地址的通讯，再往下层通过路由/交换的链路传输网络信号，再通过下层物理层的具体传输介质作为载体。</p>
<table>
<thead>
<tr>
<th>应用层http/ssh</th>
<th>传输层tcp/udp</th>
<th>网络层ip</th>
</tr>
</thead>
<tbody>
<tr>
<td>Port-To-Port</td>
<td>Host-To-Host</td>
<td>Address-To-Address</td>
</tr>
<tr>
<td>Session</td>
<td>Connection</td>
<td></td>
</tr>
</tbody>
</table>
<p>TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是一个应用的行为。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3A/20/CioPOWB-RYSASfPkAAEen4ZR3gw297.png" alt="619.png" style="zoom:25%;" />
<p>如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；</p>
<p>如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；</p>
<p>如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。</p>
<p>以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M00/38/6D/Cgp9HWB5RCqAVfhiAADJmfGn2O0616.png" alt="Drawing 4.png" style="zoom:33%;" /></th>
<th><img src="https://s0.lgstatic.com/i/image6/M00/3D/55/CioPOWCTwu-AD9PgAABp1yJqsPI439.png" alt="图片2.png" style="zoom:33%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）</p>
<p>握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复。</p>
<p>到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），等所有工作结束，再发送请求中断连接（FIN）。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3A/3C/Cgp9HWB-mz2ALAO6AAFJNuQ9-SU088.png" alt="Drawing 5.png" style="zoom:50%;" />
<p>TCP 拆包的作用是将任务拆分处理，减小底层网络处理的压力，降低整体任务出错的概率。</p>
<p>在内存中开辟的一块缓冲区供TCP 段排队，将数据拆分成不超过缓冲区大小的部分，即 TCP 段（<strong>TCP Segment</strong>）进行发送。</p>
<p>拆包：一个数据太大，经过拆分多个 TCP 段发送，然后在目的地重组。</p>
<p>粘包：多个数据太小，合并成一个 TCP 段发送，在目的地再还原成多个数据。</p>
<p>TCP 利用Seq、ACK（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。</p>
<p>MSS（Maximun Segment Size）是 TCP Header 中的可选项，双方协商控制TCP 段的大小。</p>
<p>MSS 太小，每一份数据都要增加一个头部，那头部的数据占比会上升，吞吐量下降。</p>
<p>MSS 太大，会降低性能，比如缓冲区变大造成的内存性能/服务器资源的占用等硬件和计算资源、支持 TCP 协议工作的 IP 协议（TCP 协议不肯拆包，IP 协议就需要拆出大量的包），工作效率会下降。</p>
<blockquote>
<p>TCP Header</p>
<figure data-type="image" tabindex="1"><img src="/Users/joshuachang/Desktop/tcpsegment.png" alt="" loading="lazy"></figure>
</blockquote>
<p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p>
<p>但是每一个请求收到响应之后，再发送下一个请求，吞吐量会很低，浪费带宽。改进方式，就是让发送方有请求就发送出去，而不是等待响应。发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。</p>
<p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是我们不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p>
<p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可。（其他用途：求一个数组中最大的连续 k 项和）。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>滑动窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://s0.lgstatic.com/i/image6/M00/3A/FA/CioPOWCCKwuAfBn5AABKdgtX54w997.png" alt="image (3).png" style="zoom:33%;" /></td>
<td><img src="https://s0.lgstatic.com/i/image6/M00/3A/F2/Cgp9HWCCKxSAROSpAAA_zThgiBA669.png" alt="image (4).png" style="zoom:33%;" /></td>
</tr>
</tbody>
</table>
<p>实现这样的模型，用队列要用多个队列。用滑动窗口才是最合适的数据结构，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。假设我们最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK（浅绿色）。如果一个封包 ACK 到达，我们就将它标记为已接收（深绿色）。</p>
<p>RTT 表示 Round Trip Time，就是消息一去一回的时间。</p>
<p><strong>确认与重发的机制</strong></p>
<p>自适应重传算法**（<strong>Adaptive Retransmission Algorithm</strong>）**</p>
<p>快速重传：接收方可以发送多次某段的 ACK，如果发送方收到多个该段ACK，就会重发该段。</p>
<p><strong>Selective Acknowledgment</strong> （<strong>SACK</strong>）</p>
<p>发送方将数据拆包，变成多个段。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的段会一次性发送。窗口中序号最小的段如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。</p>
<p>UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。UDP 协议不会拆分数据，Datagram 就是数据传输的最小单位。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3B/0F/Cgp9HWCCfQeAGOF3AACK2Gf5t6I606.png" alt="图片1.png" style="zoom:50%;" />
<p>Length 是Datagram长度。</p>
<p>Data octets 就是一个字节一个字节的数据，Octet 是 8 位。</p>
<p>IP（Internet Protocol）协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行分片Fragmentation。然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个IP 封包（Datagram）之后，通过寻址和路由目的地和路径确认，最后调用底层的数据链路层传送数据。</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3C/0B/CioPOWCH4u-AWVEAAAH_xR5D6lU716.png" alt="Drawing 1.png" style="zoom: 33%;" />
<blockquote>
<p>主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv4/v6 封包（Datagram or Packet），寻址路由，再调用数据链路层传输数据。</p>
</blockquote>
<p>可靠性保证数据无损地到达目的地。可靠性是 IP 协议上方的 Host-To-Host 协议保证的，比如 TCP 协议通过应答机制、窗口等保证数据的可靠性。 IP 协议自身不能保证可靠性。IP 协议可能会有如下问题：</p>
<ol>
<li>
<p>封包损坏（数据传输过程中被损坏）；</p>
</li>
<li>
<p>丢包（数据发送过程中丢失）；</p>
</li>
<li>
<p>重发（数据被重发，比如中间设备通过 2 个路径传递数据）；</p>
</li>
<li>
<p>乱序（到达目的地时数据和发送数据不一致）。</p>
</li>
</ol>
<p>网络层主要有 3 个问题要解决：</p>
<ol>
<li>
<p>延迟</p>
</li>
<li>
<p>吞吐量</p>
</li>
<li>
<p>丢包率</p>
</li>
</ol>
<p>IP Header</p>
<img src="https://s0.lgstatic.com/i/image6/M00/3C/7D/Cgp9HWCKhJaAKKEhAABhmC7udP0409.png" alt="image (1).png" style="zoom:50%;" />
<p>IHL（Internet Header Length）用来描述 IP 协议头的大小。所以 IP 协议头的大小是可变的。IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）。</p>
<p>Type Of Service 服务的类型，三个波段（band）的优先级也不相同。被分配到三个波段（band）里面的，band 0 的优先级最高，band 2 的最低，用来平衡延迟、吞吐量和丢包率之间的关系。</p>
<p>Total Length 定义报文（封包 Datagram）的长度。</p>
<p>Identification（报文的 ID），发送方分配，代表顺序。</p>
<p>Fragment offset 描述要不要分包（拆分），以及如何拆分。</p>
<p>Time To Live 描述封包存活的时间。因此每个 IP 封包发送出去后，就开始销毁倒计时。</p>
<p>Protocol 是描述上层的协议，比如 TCP = 6，UDP = 17。</p>
<p>Header Checksum 用来检验封包的正确性，如果 Checksum 对不上，就需要选择丢弃这个封包。</p>
<p>原地址和目标地址。IPv4 的地址是 4 组 8 位的数字，共是 32 位。</p>
<p>Options 代表可选项。</p>
<p>延迟（latency）</p>
<p>延迟指的是 1 bit 的数据从网络的一个终端传送到另一个终端需要的时间。这个时间包括在发送端准备发送的时间、排队发送的时间、发送数据的时间、数据传输的时间等。</p>
<p>吞吐量（Throughput）</p>
<p>吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps。</p>
<p>丢包率（Packet loss）</p>
<p>丢表率指发送出去的封包没有到达目的地的比例。 在最大流速确定的网络中，丢包率会直接影响吞吐量。</p>
<p>寻址Addressing：地址高位到低位和255.0.0.0（子网掩码）做位与运算依次得到子网地址。子网掩码的作用就是帮助根据 IP 地址找到对应子网。</p>
<p>路由Routing：由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关Gateway。</p>
<p>IPv4 的地址是 4 个 8 位（octet），总共 32 位。 IPv6 的地址是 8 个 16 位（hextet），总共 128 位。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/0B/CioPOWCH4wGAT3bUAALH_YQ0Q-U502.png" alt="Drawing 3.png" style="zoom:33%;" />
<p>省略表示</p>
<pre><code class="language-jade">0123:4567:0000:0000:0123:4567:0000:cdef
0123:4567::0123:4567:0000:cdef //::省略了若干组0000
123:4567::123:4567:0:cdef //省略开头的0
3c4d::/16 //只有前16位有数据
</code></pre>
<p><strong>IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可</strong>。</p>
<p>IPv6 的寻址分成了几种类型：</p>
<ul>
<li>全局单播寻址（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）；</li>
<li>本地单播（类似 IPv4 里的一个内部网络，要求地址必须以<code>fe80</code>开头，类似我们 IPv4 中<code>127</code>开头的地址）；</li>
<li>分组多播（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；</li>
<li>任意播（Anycast），这个方式比较特殊，接下来我们会详细讲解。</li>
</ul>
<blockquote>
<p>全局单播时，IPv6 地址通常分成 3 个部分</p>
<ul>
<li>站点前缀（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；</li>
<li>子网号（Subnet ID），16bit，用于站点内部区分子网；</li>
<li>接口号（Interface ID）， 64bit，用于站点内部区分设备。</li>
</ul>
<p>IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（即设备的网卡）。</p>
</blockquote>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4w-AEinAAAHIfeF4_II848.png" alt="Drawing 5.png" style="zoom:25%;" />
<blockquote>
<p>本地单播 虽然理论上 IPv6 可以将所有的设备都连入一个网络。但实际中还是需要一个内部网络。在局域网络中，实现设备到设备的通信，就是本地单播。本地单播地址必须以<code>fe80</code>开头，后面 64 位的 0，然后接上 54 位的设备编号。类似于127.0.0.。上图中的 Interface 可以理解成网络接口，其实就是网卡。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4x6AJJxNAAEMhuOKNmY768.png" alt="Drawing 7.png" style="zoom:25%;" />
</blockquote>
<blockquote>
<p>IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是<code>ff00</code>开头，后面会跟上一个分组的编号时，就是在进行分组多播。</p>
</blockquote>
<blockquote>
<p>任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。客户端想要获取时间，就将请求发送到这个任播地址。会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。</p>
</blockquote>
<p>IPv6 和 IPv4 的兼容</p>
<p><strong>IPv4 网络和 IPv6 网络通信</strong>时通过DNS64 查询服务把 IPv4 地址和 IPv6 地址同时返回。再通过NAT64 路由器将 IPv6 地址转换为 IPv4 地址。</p>
<p><strong>两个 IPv6 网络被 IPv4 隔离</strong>时通过Tunnel，<strong>隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序</strong>。</p>
<p><strong>IPv6 解决的是地址耗尽的问题</strong>。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。</p>
<p>链路层发送数据靠的是 MAC 地址，不同于IP地址（住址），MAC 地址就好像人的身份证一样。</p>
<p>数据的发送方，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个分组（Packet），也称作 <strong>Frame</strong> 或者封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。</p>
<blockquote>
<p>TCP 协议滑动窗口中的MSS（Maximun Segment Size）是 TCP 段最大值，是传输层概念。</p>
<p>IP层 封包（Datagram）</p>
<p>如果 IP 协议要传输数据，就要将数据转换成为链路层的Frame，然后才可以在链路层传输。IP 协议要根据 MTU 拆分封包。</p>
<p><strong>MTU</strong>（Maximun Transmission Unit）链路层网络允许的最大传输数据分组的大小，是链路层概念。<strong>IP 协议要根据 MTU 拆分封包</strong></p>
<p>交换机的作用更侧重局域网内各主机交换，路由器的作用更侧重从局域网内主机到另一个局域网内主机路经的路由。</p>
<p>数据从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径叫做Switch，链路层交换机（Link-Layer Switch）和路由器（Router）都是能起这一作用设备。局域网边界与另一局域网边界即为网关，因为路由器也起到连结两个局域网的作用，因此网关一般理解为就是路由器的IP。</p>
</blockquote>
<p>已知 IP 地址，找到 MAC 地址的协议，叫作地址解析协议（ARP Address Resolution Protoco）。<strong>ARP</strong>和 <strong>DNS 非常相似，采用的是逐级缓存的设计减少 ARP 请求</strong>。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。</p>
<p>局域网内主机数据交换根据MAC 地址，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个 Frame 封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。当然13/26交叉网线连结两主机的特殊局域网另算。</p>
<p>发到外网要先发到网关这一特殊主机Mac地址，在由网关往外发。</p>
<p>网络地址解析协议（<strong>NAT</strong> Network Address Translation）解决的是内外网通信的问题。NAT 通常发生在内网和外网衔接的路由器中，NAT将内网中某个 IP 地址映射到外网 IP，然后再把数据发送给外网的服务器。</p>
<p><strong>127.0.0.1, localhost, 0.0.0.0 有什么不同</strong></p>
<p><code>127.0.0.1</code>是本地回环<strong>地址</strong>（loopback），发送到 loopback 的数据会被转发到本地应用。</p>
<p>localhost 是<strong>主机</strong>名，指代的本地计算机，用于访问绑定在 loopback 上的服务。</p>
<p><code>0.0.0.0</code>是不可路由 IP 地址，当把一个服务绑定到<code>0.0.0.0</code>，相当于把服务绑定到任意的 IP 地址。</p>
<p>客户端将数据发送给在客户端侧的Socket 对象，然后客户端侧的 Socket 对象将数据发送给服务端侧的 Socket 对象。Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。</p>
<p>对于一个服务端 Socket 文件，我们要设置它监听的端口。比如 Nginx 监听 80 端口、Node 监听 3000 端口、SSH 监听 22 端口、Tomcat 监听 8080 端口。端口监听不能冲突，不然客户端连接进来创建客户端 Socket 文件，文件描述符就不知道写入哪个服务端 Socket 文件了。</p>
<p>服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind。</p>
<img src="https://s0.lgstatic.com/i/image6/M01/3E/7B/Cgp9HWCZ8deAY_UqAAFeGtcsKIg099.png" style="zoom:25%;" />
<p>从另一个角度去分析，Socket 还是一种双向管道文件，也是文件描述符。</p>
<p>在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用。</p>
<p>主动式的 I/O 多路复用（select poll），对负责 I/O 的线程压力过大，因此通常会设计一个高效的中间数据结构作为 I/O 事件的观察者，线程通过订阅 I/O 事件被动响应，这就是响应式模型。在 Socket 编程中，最适合提供这种中间数据结构的就是操作系统的内核，事实上 epoll 模型也是在操作系统的内核中提供了红黑树结构。</p>
<p>扫描和监听：对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。</p>
<p>之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。</p>
<p>上述的过程，我们通过一个线程就可以响应多个客户端的连接，也被称作I/O 多路复用技术</p>
<table>
<thead>
<tr>
<th><img src="https://s0.lgstatic.com/i/image6/M01/3E/83/CioPOWCZ8fOAaVwEAAJ4CITeHSs003.png" alt="" loading="lazy"></th>
<th><img src="https://s0.lgstatic.com/i/image6/M01/3E/7B/Cgp9HWCZ8fyAJIK7AAFzaGqyFsw603.png" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>如果接入的客户端 Socket 较多，每次轮询的开销都会很大。从程序设计的角度来看，像这样主动遍历，比如遍历一个 Socket 集合看看有没有发生写入（有数据从网卡传过来），称为命令式的程序。</p>
<p>响应式（Reactive）epoll：响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。 Socket 文件的读写都要经过操作系统，所以最合适的观察者其实是操作系统本身。</p>
<ol>
<li>线程需要告诉中间的观察者自己要观察什么：即注册</li>
<li>中间的观察者服务于很多的线程，需要实现一个高效的数据结构：通常是基于红黑树的二叉搜索树</li>
</ol>
<blockquote>
<p>响应式为什么用红黑树？</p>
<p>中间观察者核心诉求：第一是让线程可以注册自己关心的消息类型。第二能够快速地判断是哪个线程需要知道这个消息。因此需要一个快速能插入（注册过程）、查询（通知过程）一个整数的数据结构，这个整数就是 Socket 的文件描述符。能够解决这个问题的数据结构中，跳表和二叉搜索树都是不错的选择。</p>
<p>epoll 为什么用红黑树？</p>
<p>【解析】在 Linux 的设计中有三种典型的 I/O 多路复用模型 select、poll、epoll。</p>
<p>select 是一个主动模型，需要线程自己通过一个fdset集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。</p>
<p>poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，你可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。</p>
<p>epoll 模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。</p>
</blockquote>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210610220052461.png" alt="image-20210610220052461" style="zoom:67%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210610215833870.png" alt="image-20210610215833870" style="zoom:67%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210610220128299.png" alt="image-20210610220128299" style="zoom:67%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611113050387.png" alt="image-20210611113050387" style="zoom:50%;" />
<p><img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611113309558.png" alt="image-20210611113309558" style="zoom:50%;" /><img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611113510282.png" alt="image-20210611113510282" style="zoom:50%;" /></p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611103433126.png" alt="image-20210611103433126" style="zoom:67%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611115050524.png" alt="image-20210611115050524" style="zoom:50%;" />
<p>幂等方法：提交一次和多次效果一样。</p>
<p>服务端相应码</p>
<p>1XX 请求已接收到，还需进一步处理。</p>
<p>2XX OK成功返回响应</p>
<p>3xx 重定向 301永久 302临时</p>
<p>4xx 客户端错误 401认证错误 407认证代理错误 403权限错误 404临时没找到资源 406语言/编码资源不存在</p>
<p>408请求超时</p>
<p>5XX服务器错误 501功能尚未实现 502代理服务器错误 504代理服务器超时</p>
<p>Connection 头部 Keep-Alive:长连接</p>
<p>客户端请求长连接Connection: Keep-Alive</p>
<p>服务器表示支持长连接Connection: Keep-Alive</p>
<p>客户端复用连接</p>
<blockquote>
<p>HTTP/1.1 默认支持长连接Connection: Keep-Alive 无意义， Connection：Close关闭</p>
<p>Connection只对当前连接有效，层层代理服务器，每层单独处理。</p>
</blockquote>
<p>典型的REST（Representational state transfer表现状态转换） 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。按照HTTP 协议中方法的约定就是最好的使用。</p>
<p>Restful 中的 State是服务端状态，可以理解为业务的状态。</p>
<p>前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation。</p>
<p>用户通过前端向服务端做状态的变化请求即为转换。</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611145334304.png" alt="image-20210611145334304" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611145251103.png" alt="image-20210611145251103" style="zoom:50%;" />
<blockquote>
<p>X-Real-Ip非RFC官方规定的头，nignix里的。</p>
<p>Max-Forwards 代理服务器最大转发次数，Via指名经过的代理服务器名称及版本，Cache-Control：no-transform禁止代理服务器修改响应包体</p>
</blockquote>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611151227487.png" alt="image-20210611151227487" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611152015637.png" alt="image-20210611152015637" style="zoom:50%;" />
<p>请求的上下文</p>
<p>User-Agent ：指名客户端类型</p>
<p>Referer:来自某一页面的请求自动添加的头部，服务器端常用于统计分析、缓存优化、防盗链等功能</p>
<p>From：告诉服务器如何通过邮件联系到爬虫的负责人</p>
<p>响应上下文</p>
<p>Server：指明服务器上所用软件的信息,用于帮助客户端定位问题或者统计数</p>
<p>Allow:告诉客户端,服务器上该 URI 对应的资源允许哪些方法的执行 Allow: GET, HEAD, PUT</p>
<p>Accept-Ranges:告诉客户端服务器上该资源是否允许 range 请求 Accept-Ranges = bytes接收range请求  none相反</p>
<p>内容协商</p>
<p>每个 URI 指向的资源可以是任何事物,可以有多种不同的表述,例如一份文档可以有不同语言的翻译、不同的媒体格式、可以针对不同的浏览器提供不同的压缩编码等。</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611153755910.png" alt="image-20210611153755910" style="zoom:50%;" />
<p>协商要素</p>
<p>质量因子 q:内容的质量、可接受类型的优先级</p>
<p>媒体资源的 MIME 类型及质量因子（Accept: text/html,application/xhtml+xml）</p>
<p>字符编码:由于 UTF-8 格式广为使用, Accept-Charset 已被废弃 （Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7）</p>
<p>内容编码:主要指压缩算法（Accept-Encoding: gzip, deflate）</p>
<p>表述语言（Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7）</p>
<p>internationalization(i18n,i  和  n  间有  18  个字符) 指设计软件时,在不同的国家、地区可以不做逻辑实现层面的修改便能够以不同的语言显示</p>
<p>localization(l10n,l  和  n  间有  10  个字符) 指内容协商时,根据请求中的语言及区域信息,选择特定的语言作为资源表述</p>
<p>资源表述的元数据头部</p>
<p>媒体类型、编码content-type: text/html; charset=utf-8</p>
<p>内容编码• content-encoding: gzip</p>
<p>语言Content-Language: de-DE, en-CA</p>
<p>HTTP 包体:承载的消息内容• 请求或者响应都可以携带包体• HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ] • message-body = *OCTET:二进制字节流• 以下消息不能含有包体• HEAD 方法请求对应的响应• 1xx、204、304 对应的响应• CONNECT 方法对应的 2xx 响应</p>
<p>发送 HTTP 消息时两种传输 HTTP 包体的方式</p>
<p>已确定包体的全部长度，使用 Content-Length 头部明确指明包体长度（10进制），不能写错</p>
<p>不能确定包体的全部长度，使用 Transfer-Encoding 头部指明使用 Chunk 传输方式。Content-Length 头部应被忽略</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611160524934.png" alt="image-20210611160524934" style="zoom:50%;" />
<p>multipart(RFC1521):一个包体中多个资源表述</p>
<p>Content-type 头部指明这是一个多表述包体，Content-type: multipart/form-data; boundary=----WebKitFormBoundaryRRJKeWfHPGrS4LKe</p>
<p>Boundary 分隔符的格式boundary := 0*69<bchars> bcharsnospace • bchars := bcharsnospace / &quot; &quot; • bcharsnospace := DIGIT / ALPHA / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;+&quot; / &quot;_&quot; / &quot;,&quot; / &quot;-&quot; / &quot;.&quot; / &quot;/&quot; / &quot;:&quot; / &quot;=&quot; / &quot;?&quot;</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611205116993.png" alt="image-20210611205116993" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611211036459.png" alt="image-20210611211036459" style="zoom:50%;" />
<p>拿之前的Etag做指纹去请求，未失效/修改则继续返回数据，否则返回412错误（服务端的数据发生变化）。</p>
<p>服务器响应range请求：</p>
<p>服务器不支持range请求时返回200 ok，支持时返回状态码 206 Partial Content   Content-Range：bytes 300-500/1000  Content-Range: bytes 500-600/* （a-b/完整大小 未知用*）</p>
<p>范围错误时返回416 Range Not Satisfiable</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210611212825096.png" alt="image-20210611212825096" style="zoom:50%;" />
<p>boundary 分隔符和表单提交一样，分割时 前-- ，结尾时 --前后--</p>
<p>Cookie 是保存在客户端、由浏览器维护、表示应用状态的  HTTP 头部</p>
<p>存放在内存或者磁盘中，服务器端生成 Cookie 在响应中通过Set-Cookie 头部告知客户端(允许多个 Set-Cookie 头部传递多个值) ，客户端得到 Cookie 后,后续请求都会自动将 Cookie 头部携带至请求中</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619183506361.png" alt="image-20210619183506361" style="zoom:50%;" />
<p>Cookie 头部中可以存放多个 name/value 名值对，Set-Cookie  头部一次只能传递  1  个  name/value  名值对,响应中可以含多个头部</p>
<p>Cookie 在协议设计上的问题？</p>
<ol>
<li>Cookie 会被附加在每个 HTTP 请求中,所以无形中增加了流量</li>
<li>由于在 HTTP 请求中的 Cookie 是明文传递的,所以安全性成问题(除非用 HTTPS)</li>
<li>Cookie 的大小不应超过 4KB,故对于复杂的存储需求来说是不够用的</li>
</ol>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619184311413.png" alt="image-20210619184311413" style="zoom:50%;" />
<p>支持双向通讯的 WebSocket</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619184642156.png" alt="image-20210619184642156" style="zoom:50%;" />
<p>长连接的心跳保持</p>
<p>HTTP 长连接只能基于简单的超时(常见为 65 秒)</p>
<p>WebSocket 连接基于 ping/pong 心跳机制维持</p>
<p>兼容 HTTP 协议，默认使用 80 或者 443 端口，协议升级，代理服务器可以简单支持。基于帧:不是基于流(HTTP、TCP)  每一帧要么承载字符数据,要么承载二进制数据。</p>
<p>URI格式：</p>
<p>默认 port 端口 80 ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</p>
<p>默认 port 端口 443 wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</p>
<p>客户端提供信息：host 与 port:主机名与端口• shema:是否基于 SSL • 访问资源:URI • 握手随机数:Sec-WebSocket-Key • 选择子协议: Sec-WebSocket-Protocol • 扩展协议: Sec-WebSocket-Extensions • CORS 跨域:Origin</p>
<p>1 条消息由 1 个或者多个帧组成,frame头有opcode =8关闭帧</p>
<p>心跳帧：可以插在数据帧中传输：ping 帧 opcode=9  可以含有数据； pong 帧 opcode=A  必须与 ping 帧数据相同</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619185513649.png" alt="image-20210619185513649" style="zoom:50%;" />
<p>![image-20210610221234379](/Users/joshuachang/Library/Application Support/typora-user-images/image-20210610221234379.png)</p>
<p>每一层都可以添加头部，物理层是比特流，link链路层是frame，网络层packet加ip头，连接层sequence/datagram加tcp头，应用层http加头部</p>
<p>隐藏data urls：隐藏（ css/base64图片等小文件嵌入到html中以减少http请求数的）data urls。</p>
<p>domain: (*)按域名，is:running websocket资源 is:from-cache缓存的资源 larger-than:大于bit的资源</p>
<p>method:http方法的资源 mine-type:mime类型的资源 多过滤条件加空格并列</p>
<p>连接的上下游：按住shift红色下游，绿色上游</p>
<p>DNS：把可读的域名与IP地址进行映射的数据库，递归查询先根域名服务器com 后权威域名服务器baidu</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613144056200.png" alt="image-20210613144056200" style="zoom:50%;" />
<p>DNS报文：查寻与响应 query查寻域名 response返回IP地址 DNS请求与响应用的是UDP</p>
<p>HTTP1.1重复传输的体积巨大的 HTTP 头部</p>
<p>HTTP/2 (借鉴了SPDY)主要特性</p>
<ol>
<li>传输数据量的大幅减少：以二进制方式传输、HPACK 头部压缩压缩算法:Huffman 编码</li>
<li>多路复用：消息优先级</li>
<li>服务器消息推送：并行推送</li>
<li>应用层下的TLS层</li>
</ol>
<p>HTTP2.0的TCP+TLS 建链握手过多、多路复用与 TCP 的队头阻塞问题</p>
<p>HTTP3/QUIC协议，UDP 报文:先天没有队列概念，解决了握手过多、队头阻塞问题</p>
<p>HTTP3在1RTT 完全握手，在0RTT 恢复会话握手。</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619191802310.png" alt="image-20210619191802310" style="zoom:50%;" />
<p><img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619190739776.png" alt="image-20210619190739776" style="zoom:50%;" /><img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619190829293.png" alt="image-20210619190829293" style="zoom:50%;" /></p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210619190914482.png" alt="image-20210619190914482" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613204537171.png" alt="image-20210613204537171" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613222750330.png" alt="image-20210613222750330" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613222840024.png" alt="image-20210613222840024" style="zoom:50%;" />
<p>TLS设计目的：身份验证、保密性、完整性</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613222623395.png" alt="image-20210613222623395" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613225106463.png" alt="image-20210613225106463" style="zoom:50%;" />
<p>拿到公钥有两种方式：通过PKI（Public Key Infrastrucure公钥基础设施）第三方、建立连结后先进行一次握手，把公钥给过来</p>
<p>RSA算法早期用在tsl握手中传递对称密钥，先在常用做生成ca证书</p>
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210613231139689.png" alt="image-20210613231139689" style="zoom:50%;" />
<img src="/Users/joshuachang/Library/Application Support/typora-user-images/image-20210615153258583.png" alt="image-20210615153258583" style="zoom:50%;" />
<p>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。被点分隔为四个部分，每个部分 8 个 bit，共 32 位。</p>
<img src="/Users/joshuachang/Downloads/IP分类.jpg" alt="IP分类" style="zoom:75%;" />
<p><strong>无类型域间选路</strong>，简称<strong>CIDR</strong>将 32 位的 IP 地址一分为二，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。如10.100.122.2/24，这种地址表示形式，就是 CIDR。斜杠后面数字 24指：32 位中，前 24 位是网络号，后 8 位是主机号。</p>
<p>伴随着 CIDR 存在的，一个是<strong>广播地址</strong>，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是<strong>子网掩码</strong>，255.255.255.0。</p>
<p><strong>子网掩码</strong></p>
<p>IP地址与子网掩码通过二进制的与运算（AND：非同时为1皆为0）</p>
<p>1.用来判断出IP地址的网络号和主机号位数</p>
<p>2.用来判断两台机器是否在同一子网，不在同一个子网的两个机器需要通信必须借助路由器。</p>
<ul>
<li>A类IP的子网掩码默认为：255.0.0.0</li>
<li>B类IP的子网掩码默认为：255.255.0.0</li>
<li>C类IP的子网掩码默认为：255.255.255.0</li>
</ul>
<p>人为指定子网掩码为：225.225.255.240（11111111.11111111.11111111.11110000）时，00000000-00001111间的主机才在同一子网如200.67.83.3(0011)和200.67.83.14(1110) 分别与上225.225.255.240（11111111.11111111.11111111.11110000）在同一子网，200.67.83.13(00001101)和200.67.83.77(00101101)不在同一子网。</p>
<p><strong>广播地址</strong></p>
<p>广播的覆盖范围就是其所在网络号下的所有主机号，把主机号所在的二进制位全部变为1即可得到广播地址，如192.168.211.32/24的广播地址为：192.168.211.255</p>
<figure data-type="image" tabindex="2"><img src="/Users/joshuachang/Downloads/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80.jpg" alt="私有地址" loading="lazy"></figure>
<p>IP 分公有的 IP 和私有的 IP。公有 IP 地址通过组织统一分配。 192.168.0.x 是最常用的私有 IP 地址，一般你家里地上网设备不会超过 256 个，所以 /24 的CIDR基本就够了，明显看出 192.168.0 是网络号，后面是主机号。而整个网络里面的第一个地址 192.168.0.1就是你这个私有网络的出口地址，私有网络路由器的地址就是 192.168.0.1，而 192.168.0.255 就是广播地址。</p>
<p>当CIDR斜杠后不是 8 的整数倍时，如16.158.165.91/22</p>
<p>变成二进制来看，22位网络号，16.158不变占16位，165转换二进制为&lt;10100101&gt;，取前6位和之前的16位凑齐22位网络号即16.158.&lt;101001&gt;，后边的&lt;01&gt;和 .91组成10位机器号。</p>
<p>第一个地址是 16.158.&lt;101001&gt;&lt;00&gt;.1，即 16.158.164.1（网络号.1）</p>
<p>子网掩码是 255.255.&lt;111111&gt;&lt;00&gt;.0，即 255.255.252.0。</p>
<p>广播地址为 16.158.&lt;101001&gt;&lt;11&gt;.255，即 16.158.167.255。</p>
<p>lo 全称是<strong>loopback</strong>，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p>
<p>**一个网络包要从一个地方传到另一个地方，要有确定的地址（ip），还需要有定位功能。**MAC 地址更像是身份证，是一个唯一的标识，MAC 地址的通信范围比较小，局限在一个子网里面。如从 192.168.0.2/24 访问 192.168.0.3/24 是可以用 MAC 地址的。一旦跨子网，即从 192.168.0.2/24 到 192.168.1.2/24，MAC 地址就不行了，需要 IP 地址起作用。CIDR 可以用来判断是不是本地人。</p>
<p>MTU  最大传输单元MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p>
<p><strong>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。要去的这个地址和我是一个网段的，它才会发送 ARP 请求</strong>如果配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。网关要和当前的网络至少一个网卡是同一个网段。</p>
<p><strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。**如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。**DHCP 协议主要是用来给客户租用 IP 地址，要通过广播商谈、签约、续租。</p>
<p><strong>Hub集线器</strong>采取的是广播的模式连结主机，临如下问题</p>
<ol>
<li>这个包是发给谁的？谁应该接收？Mac地址</li>
<li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？Mac媒体访问控制</li>
<li>如果发送的时候出现了错误，怎么办？crc</li>
</ol>
<p><strong>MAC</strong>的全称是<strong>Medium Access Control</strong>，即**媒体访问控制，<strong>其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。即多路访问</strong></p>
<ul>
<li>分多个车道。作<strong>信道划分；</strong></li>
<li>今天单号出行，明天双号出行，作<strong>轮流协议；</strong></li>
<li>有事就出门，发现特堵，就回去。错过高峰再出。我们叫作**随机接入协议。**以太网，用的就是这个方式</li>
</ul>
<p><strong>链路层地址</strong>主要解决媒体接入控制的问题，所以称为<strong>MAC 地址</strong></p>
<p>IP 数据包，开始就是目标的 MAC 地址和源的 MAC 地址。接下来是<strong>类型</strong>。然后IP 里面层层封装 TCP/UDP、HTTP 等。发送时IP数据包在链路上广播，然后目标 MAC 地址发现![IP 数据包](/Users/joshuachang/Downloads/IP 数据包.jpg)</p>
<p>当不知道目标 MAC 地址时目标 MAC 地时，通过<strong>ARP 协议</strong>，即已知目标 IP 地址，求目标MAC 地址的协议，当知道了 目标IP 地址，不知道 MAC 地址，发出广播，谁是这个 IP 谁来应答。为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。</p>
<p><strong>交换机switch</strong>是局域网内主机交换数据的设备，有 MAC 地址学习能力的，维持一个记录目的地址Mac地址的 <strong>转发表</strong> ，新的ARP 请求后，转发表有了记录，下次再去目标Mac地址，便不需APR广播。</p>
<p><strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p>
<p>当交换机数目肯定越来越多，整个拓扑结构复杂，出现<strong>环路问题</strong> 。数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为<strong>图</strong>。将图中的环破了，就生成了<strong>树</strong>。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。</p>
<ul>
<li>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</li>
<li>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li>
</ul>
<p>ping 是基于 ICMP 协议工作的。<strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>,ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。<strong>类型字段</strong>，请求为8响应为0；<strong>顺序号</strong>，区分连续 ping 的时候发出的多个数据包；为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p>
<img src="/Users/joshuachang/Downloads/ping.jpg" alt="ping" style="zoom:50%;" />
<p>ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；ping 使用查询报文，Traceroute 使用差错报文。</p>
<p><strong>Traceroute 的第一个作用就是故意设置特殊的 TTL（time to live），来追踪去往目的地时沿途经过的路由器</strong>，<strong>还有一个作用是故意设置不分片，从而确定路径的 MTU</strong></p>
<img src="/Users/joshuachang/Downloads/MAC 头和 IP 头.jpg" alt="MAC 头和 IP 头" style="zoom:50%;" />
<p>当要访问另一个 IP 地址的时候，先判断目标 IP 地址和当前机器的 IP 地址，是否在同一个网段（需要 CIDR 和子网掩码)。</p>
<p><strong>如果是同一个网段</strong> ，那就没网关什么事情，直接将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。</p>
<p><strong>如果不是同一网段</strong>，就需要发往默认网关 Gateway(<strong>将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC 头中，发送出去</strong>)。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个(如 192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24 或者 192.168.1.2/24)。</p>
<p><strong>网关往往是一个路由器</strong> <strong>是一个转发的设备</strong>把 MAC 头和 IP 头都取下来，根据里面的内容，看看接下来把包往哪里转发。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。网关也是一个处在跨局域网处的特殊主机（路由嵌入式系统软路由），也有IP和Mac地址。</p>
<p>**路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。**任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p>
<p>**静态路由，其实就是在路由器上，配置一条一条规则。**每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳 IPX。</p>
<p><strong>MAC 地址是一个局域网内才有效的地址。<strong>MAC 地址只要过网关，就必定会改变，因为已经换了局域网。同时不改变 IP 地址的网关，我们称为</strong>转发网关；<strong>改变 IP 地址的网关，我们称为</strong>NAT 网关（Network Address Translation）</strong>。</p>
<p>转发网关，嵌套header里的IP和目标IP不变，只有Mac和目标Mac随每次从一个网关ip到另一个网关IP而变化（目标Mac依次为下一个网关的Mac地址）</p>
<p>每家都有家用路由器都是 192.168.1.x，当我们家里的包发出去的时候，都被家用路由器 NAT 成为了运营商的地址。一般就是整个办公室共用一个到两个出口 IP 地址。</p>
<ul>
<li>
<p>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</p>
</li>
<li>
<p>路由器是一个三层设备，里面有如何寻找下一跳的规则；</p>
</li>
<li>
<p>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</p>
</li>
<li>
<p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p>
</li>
</ul>
<p>动态路由根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。</p>
<ul>
<li>动态路由主流算法有两种，<strong>距离矢量路由</strong>（<strong>distance vector routing</strong>）算法基于 Bellman-Ford 算法产生外网路由协议**（<strong>Border Gateway Protocol</strong>，简称<strong>BGP</strong>）和链<strong>链路状态路由</strong>（<strong>link state routing</strong>）基于 Dijkstra 算法，产生OSPF （<strong>Open Shortest Path First</strong>，<strong>开放式最短路径优先</strong>）动态路由协议   即内部网关协议**（<strong>Interior Gateway Protocol</strong>，简称<strong>IGP</strong>）。</li>
</ul>
<p><strong>TCP 是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而<strong>UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</strong>不保证不丢失，不保证按顺序到达**</p>
<img src="/Users/joshuachang/Downloads/udp.jpg" alt="udp" style="zoom:50%;" />
<p>无论是 TCP 还是 UDP 包头里面应该有源端口号和目标端口号，根据端口号，将数据交给相应的应用程序。</p>
<ul>
<li>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</li>
</ul>
<p>链路层Mac叫帧，网络层IP叫包，传输层tcp叫段。</p>
<img src="/Users/joshuachang/Downloads/tcp.jpg" alt="tcp" style="zoom:50%;" />
<p>TCP 双方都要维护各自的状态机。</p>
<table>
<thead>
<tr>
<th><img src="/Users/joshuachang/Downloads/tcp连结.jpg" alt="tcp连结" style="zoom:50%;" /></th>
<th><img src="/Users/joshuachang/Downloads/tcp断开.jpg" alt="tcp断开" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<img src="/Users/joshuachang/Downloads/tcp状态机.jpg" alt="tcp状态机" style="zoom:50%;" />
<p>TCP为了保证顺序性,按照 ID 一个个发送,采用<strong>累计确认</strong>或者<strong>累计应答</strong>（<strong>cumulative acknowledgment</strong>）。</p>
<p>TCP 里，接收端会给发送端报一个窗口的大小，叫<strong>Advertised window</strong>，超过这个窗口的，接收端做不过来，发送端就不能发送了。</p>
<p>Socket 编程进行的是端到端的通信</p>
<p>在网络层，Socket函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。<br>
在传输层，还要指定到底是 TCP 还是 UDP。TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p>
<p>TCP 的 Socket 就是一个文件流，在 Linux 中就是以文件的形式存在的，写读通过文件描述符。在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p>
<p>两端创建了 Socket 之后，接下来的过程中，TCP 和 UDP 稍有不同。</p>
<table>
<thead>
<tr>
<th><img src="/Users/joshuachang/Downloads/sockettcp.jpg" alt="sockettcp" style="zoom:50%;" /></th>
<th><img src="/Users/joshuachang/Downloads/socketudp.jpg" alt="socketudp" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。</p>
</li>
<li>
<p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听，这个时候客户端就可以发起连接了。</p>
<p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p>
</li>
<li>
<p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p>
</li>
<li>
<p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p>
<p>监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听 Socket</strong>，一个叫作<strong>已连接 Socket</strong>。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据。</p>
</li>
</ol>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p>
<p><strong>socket最大连接数</strong>:系统会用一个四元组来标识一个 TCP 连接<code>{本机 IP, 本机端口, 对端 IP, 对端端口}</code>只有客户端的 IP 和客户端的端口是可变的。</p>
<p>1.多进程方式：在 Linux 下，创建子进程使用 fork 函数。这是在父进程的基础上完全拷贝一个子进程（在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程，根据 fork 的返回值来区分到底是父进程（其他整数即子进程id），还是子进程（0））</p>
<p>2.多线程方式：在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。比多进程更轻量，但一直创建很多进程或者线程操作系统是无法承受的。</p>
<p>3.IO 多路复用，一个线程维护多个 Socket：<strong>一个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，调用 select 函数来监听文件描述符集合是否有变化</strong>。数量由 FD_SETSIZE 限制,一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。每次 Socket 所在的fd_set中有 Socket 发生变化的时候，都需要通过轮询的方式。</p>
<p>4.IO 多路复用,事件通知:epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p>
<p>当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。</p>
<p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题(（即单机1万个并发连接问题）)的利器</strong>。</p>
<p>目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。</p>
<p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头。HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</p>
<p>对称加密：加密和解密使用的是同一个密钥。</p>
<p>非对称加密：客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p>
<p>数字证书：如何将非对称加密的公钥给对方？由<strong>CA</strong>（ <strong>Certificate Authority</strong>）颁发的称为<strong>证书</strong>（<strong>Certificate</strong>）：里面有<strong>公钥</strong>，证书的**所有者、发布机构、证书有效期、签名算法，CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。**root CA层层授信背书，CA 证书的作用，是保证服务器的公钥的来历。</p>
<p>你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。不是伪装钓鱼的公钥。</p>
<p>无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p>
<img src="/Users/joshuachang/Downloads/https.jpg" alt="https" style="zoom:50%;" />
<ul>
<li>
<p>加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。</p>
</li>
<li>
<p>非对称加密需要通过证书和权威机构来验证公钥的合法性。</p>
</li>
<li>
<p>HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。</p>
</li>
<li>
<p>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</p>
</li>
<li>
<p>压缩好的数据，为了传输组成一系列 NALU<strong>网络提取层单元</strong>（<strong>NALU</strong>，<strong>Network Abstraction Layer Unit</strong>），按照帧和片依次排列；</p>
</li>
<li>
<p>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输；</p>
</li>
<li>
<p>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。</p>
</li>
</ul>
<p><code>www.example.com. IN A 139.18.28.5;</code>DNS记录：</p>
<p>IN 代表记录用于互联网，是 Intenet 的缩写</p>
<p>A 代表IPv4地址 AAAA IPv6地址</p>
<p>CNAME用于定义域名的别名：将一个域名映射到另一个域名。</p>
<ul>
<li>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</li>
<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>
<li><strong>HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。</strong></li>
<li>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</li>
<li>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</li>
</ul>
<p>内容分发网络（Content Dilivery Network，CDN）是一个专门用来分发内容的分布式应用，CDN 构建在现有的互联网之上，通过在各地部署数据中心，让不同地域的用户可以就近获取内容。内容通常指的是文件、图片、视频、声音、应用程序安装包等静态资源。很多大型的应用，会把 DNS 解析作为一种负载均衡的手段。</p>
<p>能集中提供这些静态资源呢？这和域名系统的 DNS 记录不能集中提供是一个道理，需要考虑到流量、单点故障、延迟等因素。在离用户更近的地理位置提供资源，可以减少延迟。按照地理位置分散地提供资源，也可以降低中心化带来的服务压力。</p>
<p>当用户请求一个静态资源的时候，首先会触发域名系统的解析。域名系统会将解析的责任交由 CDN 提供商来处理，CDN 的智能 DNS 服务会帮助用户选择离自己距离最近的节点，返回这个节点的 A（或 AAAA）记录。然后客户端会向 CDN 的资源节点发起请求，最终获得资源。</p>
<ul>
<li><strong>有了 CDN 之后，情况发生了变化</strong>。在 web.com 这个权威 DNS 服务器上，会设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.web.cdn.com">www.web.cdn.com</a>，返回给本地 DNS 服务器。</li>
</ul>
<p>CDN 回源就是 CDN 节点到源站请求资源，重新设置缓存。通常服务提供方在使用 CDN 的时候，会在自己的某个域名发布静态资源，然后将这个域名交给 CDN。</p>
<blockquote>
<p>比如源站在 s.example.com 中发布静态资源，然后在 CDN 管理后台配置了这个源站。在使用 CDN 时，服务提供方会使用另一个域名，比如说 b.example.com。然后配置将 b.example.com 用 CNAME 记录指向 CDN 的智能 DNS。这个时候，如果用户下载b.example.com/a.jpg，CDN 的智能 DNS 会帮用户选择一个最优的 IP 地址（最优的 CDN 节点）响应这次资源的请求。如果这个 CDN 节点没有 a.jpg，CDN 就会到 s.example.com 源站去下载，缓存到 CDN 节点，然后再返回给用户。</p>
<p>CDN 回源有 3 种情况，一种是 CDN 节点没有对应资源时主动到源站获取资源；另一种是缓存失效后，CDN 节点到源站获取资源；还有一种情况是在 CDN 管理后台或者使用开放接口主动刷新触发回源。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity启动模式]]></title>
        <id>https://Joshua-Chang.github.io/post/activity-qi-dong-mo-shi/</id>
        <link href="https://Joshua-Chang.github.io/post/activity-qi-dong-mo-shi/">
        </link>
        <updated>2021-06-06T09:51:42.000Z</updated>
        <content type="html"><![CDATA[<p>按下RecentTask键时，显示出一个个的Task。我们可以在最近的Task间切换。<br>
当我们在某个app内，不停按返回键，直到Task里最后一个Activity被关闭，Task的生命结束。但作为最近的Task，他在RecentTask里并不会消失，仍保留一个残影等待重新打开app。（RecentTask里看到的task未必是存活的）</p>
<p>不仅activity在Task内可以叠成栈，不同task也可以叠成栈。但task的叠加只在前台；一旦进入后台task就不再叠加，并拆开成不同Task。进入后台的场景有按home回到桌面、按recentTask查看最近Task。</p>
<ol>
<li>
<p>standard：Activity与启动它的Task相关。在不同Task中打开同一个Activity，Activity会被创建多个实例，分别放进每一个Task顶，互不干扰。<br>
从A app中打开B app里的Activity时，该Activity会直接放到A的task顶。对于B的task没影响。</p>
<p>短信app里点击号码添加联系人，通讯录app的添加联系人Activity被打开，放到短信app所在栈的栈顶，对通讯录app没影响。</p>
</li>
<li>
<p>singleTop：和standard一样，只有会复用Task顶的Activity并<code>onNewIntent</code>，而不必创建新的实例。<br>
从A app中打开B app里的Activity时，只有当A Task顶的Activity的刚好是准备要打开的activity时，才不在栈顶创建该Activity，而是复用之前打开的并<code>onNewIntent</code></p>
</li>
</ol>
<blockquote>
<p>假设主界面为 MainActivity，显示新闻的界面是 DetailActivity，显然显示任何一条新闻都会使用 DetailActivity，即把新闻内容通过 Intent 传给 DetailActivity 就可以了。 假设你正在看新闻1(即在 DetailActivity)，此时手机收到服务器的推送：收到一条通知(新闻2)，点击通知就会跳转到 DetailActivity 并显示新闻2，当你点击通知时，因为目前栈顶的 Activity 就是 DetailActivity，因此这里就是使用 SingleTop 的地方，即点击通知后以 SingleTop 加载模式打开 DetailActivity 并显示新闻2，因此新闻1的 DetailActivity 就被覆盖掉了。 此后你点击返回键会回到主界面。</p>
<p>OnNewIntent</p>
<p>针对网易新闻这个案例来看，DetailActivity一般是一个webView,然后 根据上一个页面（新闻列表）传过来的url展示对应的网页，“通知“也是一样的。都是通过intent把url传到DetailActivity。以下一段代码简单的模拟DetailActivity 接收数据的过程。</p>
</blockquote>
<p>standard、singleTop都是直接在原Task上新建或复用，而singleTask、singleInstance是跨Task打开Activity(过渡时原生有应用间切换动画)。</p>
<ol start="3">
<li>
<p>singleTask：Activity被其他的Task启动的时候：不会直接放到启动他的Task栈顶，而是在自己的Task的栈顶；同时把自己的Task叠加到启动它的Task上(不同task过渡时原生有应用间切换动画)。连按返回键时，退出完自己的task，再退(过渡动画)启动它的task。</p>
<p>第一步：<strong>将被启动Activity放到被启动Task顶部</strong>：没有原Task(外部app未启动)则新开一个；有task但其内没有要启动的Activity(要启动的外部Activity所在的app已启动，但该Activity不在栈内，即没被启动过)则将被启动的Activity放到所在Task栈顶；有task且task内有要启动的Activity时推到栈顶，上边的被推出。</p>
<table>
<thead>
<tr>
<th>没有将被启动的Task(所在app未启动)</th>
<th>有将被启动的Task</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>被启动的activity放入新的task？</td>
<td>将被启动的Activity不在task内(activity未被启动)</td>
<td>在task内</td>
</tr>
<tr>
<td>被启动的activity再启动其他Activity</td>
<td>将被启动的Activity放到Task栈顶 (其他Activity在下)</td>
<td>把顶部推出</td>
</tr>
<tr>
<td>要看被启动者具体的启动模式</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>第二步：<strong>将被启动的task移动到当前task顶</strong>。</p>
<p>被启动的Activity原本的Task里，把Activity推到栈顶并<code>onNewIntent</code>刷新数据，<strong>Activity原来上边的会被推出</strong>。原来还没有task，新开一个Task。<br>
特殊情况：Activity被其他的Task启动后，Activity原task叠加在启动它的task上，此时按下home/recentTask从前台切后台，两个task不再叠加，都出现在recentTask里，在Activity原本的Task栈顶回退不会退到启动他的Task。</p>
<p>短信app里点击邮箱发送邮件，邮箱app的编写邮件Activity被打开。此时回退：会先回退邮箱app打开的页面，再回退短信app的页面。若先按recentTask则发现两个app都出现在最近Task里，再在邮箱里回退不会到短信里。</p>
<p>设置<code>android:allowTaskReparenting=&quot;true&quot;</code> 能回到其原来的父Task，的Activity也有类似效果。Activity被其他的Task启动的时候，会把Activity从原来的Task，移到当前Task栈顶（但不像standard到处创建）。直接回退时不会有切换task动画，切后台再回退也不会。若不回退而是打开原来Task，Activity又回移动回原来Task的额栈顶，再切回启动他的Task时Activity不在里边。</p>
<p>singleTask：只有一个Task里有这个Activity（不同于standard）<strong>唯一性</strong>。</p>
</li>
<li>
<p>singleInstance：比singleTask更严厉，Task里只有一个Activity，要求<strong>独占性</strong>。当Activity被其他的Task启动的时候，把Activity单独放进一个Task（没Task新建后可复用触发<code>onNewIntent</code>），并叠加到启动它的Task上（切换动画）。连续退出也是task切换，若切后台也拆成俩Task。<br>
Home切后台后。若从桌面进入Activity所在的app，原来task的Activity消失（在同TaskAffinity被隐藏的单Activity的task里。此时在recentTask看不见的Task未必被杀死，可能同TaskAffinity被隐藏）。<br>
recentTask切后台后。若进入只有一个Activity的task退一次就回到桌面。</p>
<p>若Activity被其他的Task启动，（没切后台）成为一个单Activity的Task叠加到启动他的Task上，（没切后台）再从单Activity的Task启动另一个Activity，新启动的Activity所在的Task（可以是最初Activity的原Task也无所谓，真是这样原task成了俩task叠在一起），会在单Activity的Task上继续叠加。</p>
</li>
<li>
<p>TaskAffinity：Task相关性。默认情况下一个app只有一个Task在recentTask显示。recentTask根据不同的TaskAffinity列出不同的任务，当多个task有相同TaskAffinity时recentTask显示最近前台展示的一个recent的。</p>
<p>每个Activity有TaskAffinity<code>&lt;activity&gt;默认取&lt;application&gt;的，默认取包名</code>所以默认一个task在recentTask里；<br>
每个Task也有TaskAffinity取自栈底的Activity的TaskAffinity（第一个启动的Activity的TaskAffinity）。</p>
<p>若新打开的Activity设置了singleTask，则系统要比较Activity和当前Task的TaskAffinity是否相同，相同则在当前task入栈；不同则去寻找TaskAffinity相同的task入栈，没有则新建一个Task。</p>
<p>所以在打开一个配置了singleTask的Activity时。若是外部app的，TaskAffinity不同，发送task切换；若是app自己的，TaskAffinity相同，则进入栈顶，前面被推出。若给这个Activity设置一个独立的TaskAffinity，哪怕是在同一个app内也会被拆到另一个task里，若这个独立的TaskAffinity恰好与其他app的一样，这个Activity甚至会被放到别人的app的task里。</p>
</li>
</ol>
<p><code>adb shell dumpsys activity</code>可查看task与activity关系。<code>getRunningTasks</code>等方法早被屏蔽</p>
<pre><code class="language-kotlin">val ams = getSystemService(ActivityManager::class.java)
for (task in ams.appTasks) {
    Log.e(TAG, &quot;${task.taskInfo.numActivities}:[${task.taskInfo.baseActivity?.className}-&gt;${task.taskInfo.topActivity?.className}]&quot;)
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1622973147070.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从MessageQueue视角理解Handler]]></title>
        <id>https://Joshua-Chang.github.io/post/cong-messagequeue-shi-jiao-li-jie-handler/</id>
        <link href="https://Joshua-Chang.github.io/post/cong-messagequeue-shi-jiao-li-jie-handler/">
        </link>
        <updated>2021-04-23T12:09:57.000Z</updated>
        <content type="html"><![CDATA[<p><em>本文适合对Handler有过了解，~~即使又忘了。~~但对网上的&lt;&lt;loop轮询转圈图&gt;&gt;有点印象的玩家。</em></p>
<p><strong>前置概念</strong></p>
<hr>
<p><strong>同步屏障消息</strong></p>
<ol>
<li>作用：系统使用的特殊的消息，可以看作优先处理异步消息的标识，当MessageQueue的队首是<strong>同步屏障消息时</strong>，忽略同步消息，一直执行最近的异步消息。通过<code>postSyncBarrier</code>/<code>removeSyncBarrier</code>增删同步屏障消息，非手动移除不会自动移除。</li>
<li>特点：<code>target</code>属性为空的<code>Message</code>就是同步屏障消息</li>
<li>事例：<code>ViewRootImpl.scheduleTraversals</code> 优先处理异步消息</li>
</ol>
<p><strong>IdleHandler</strong></p>
<ol>
<li>作用：闲时<code>Handler</code>，在没有消息或消息未到触发时机这样的闲时，执行的操作。</li>
<li>特点：是<code>MessageQueue</code>的静态接口，使用时复写<code>boolean queueIdle()</code>的方法执行闲时操作，返回值表示执行后是否保持存活状态。<br>
<strong>epoll</strong></li>
</ol>
<p><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></p>
<p><strong>正文</strong></p>
<hr>
<p><em>废话一下基本原理先</em></p>
<p>使用者通过<code>Handler</code>外部暴露的方法，向处于目标线程<code>TLS</code>的<code>Looper</code>内的消息队列输入消息；</p>
<p>消息队列及时/延时地取出消息，并分发处理。以达到调度或延时地操作。</p>
<p><code>Handler</code>通过<code>MessageQueue.enqueueMessage(msg,when)</code>入队消息</p>
<p><code>Looper.loop</code>通过<code>MessageQueue.next()</code>出队消息</p>
<h2 id="messagequeue">MessageQueue</h2>
<p>MessageQueue的关键变量<code>mMessages</code>：</p>
<p>消息队列实例，把消息根据触发时机早晚排列。具体代码表现为单链表的节点，代指队首（链表头）消息。</p>
<pre><code class="language-mermaid">graph LR
1[A 延迟:1s]--next--&gt;2[B 延迟:2s]--next--&gt;3[C 延迟:3s]--next--&gt;5[D 延迟:5s]
</code></pre>
<p><strong>入队出对</strong></p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9898b6b674c646eb9b9fa60b69be3714~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.10.15.png" style="zoom:50%;" />
<ol>
<li>入队方法<code>enqueueMessage()</code>，往队列存延迟触发的消息，并根据触发时间排好队。</li>
<li>出队方法<code>next()</code>一直死循环遍历队列，有到达触发时机的消息就取出消息。</li>
</ol>
<p><strong>阻塞/休眠</strong>：</p>
<p>怎么能让入队消息的延迟触发呢？</p>
<pre><code>先阻塞住next()方法，让其无法取消息。时间到了，在把阻塞恢复，取出消息即可。
</code></pre>
<p>队列内根本没消息，出队方法还一直死循环取消息，怎么办？</p>
<pre><code>没消息也阻塞住next()方法，让其无法取消息。有新消息插入时，再通知他去取。
</code></pre>
<table>
<thead>
<tr>
<th>队内的下条消息还有很久才到触发时机：先阻塞。</th>
<th>队内的根本没有消息：一直休眠到有消息。</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a84eb0ae8f54979815597c85ec0db50~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.21.31.png" style="zoom: 33%;" /></td>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426a3ab271e54dcaa5c8a6df04dcdab5~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午2.22.27.png" style="zoom: 33%;" /></td>
</tr>
</tbody>
</table>
<p><strong>具体做法</strong></p>
<p><code>next()</code>的取消息死循环中用<code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>阻塞/休眠。</p>
<ul>
<li>消息的触发时机未到时，阻塞到触发时机到为止；</li>
<li>队列内一直没消息时，休眠直到有新消息入队，再用<code>enqueueMessage()</code>内的<code>nativeWake(mPtr)</code>唤醒。</li>
</ul>
<blockquote>
<p>本文中分别用<strong>阻塞</strong>和<strong>休眠</strong>只是做语义区分：是自己超时返回，还是被动触发唤醒。</p>
<p><code>nativePollOnce</code>传入的参数<code>timeout</code>通过JNI到Native层<code>Looper::pollOnce</code>-&gt;<code>Looper::pollInner</code> -&gt;<code>epoll_wait</code>方法。</p>
<p><code>epoll_wait</code>用 <code>epoll_create</code>创建的文件描述符A，去监听管道读取端文件描述符B的事件(使用<code>epoll_ctl</code>添加)。</p>
<ul>
<li>timeout&gt;0时，监听时长超过这个<code>timeout</code>仍没有事件就返回，中断阻塞。</li>
<li>timeout=-1，<code>epoll_wait</code>一直等待，直到新消息入队<code>enqueueMessage()</code>内<code>nativeWake(mPtr)</code>在Native层向管道写入端写入“W”，触发监听中断阻塞。同时清空管道数据。</li>
</ul>
<p>上边两种情形，都会给返回一种result，而<code>pollOnce</code>收到任何一种result都会退出。</p>
<p>epoll I/O复用机制是用一个文件描述符监听多个文件描述符的事件。</p>
<p>Looper.prepare -&gt; new Looper -&gt; new MessageQueue-&gt;nativeInit-&gt;native层NativeMessageQueue构造方法中实例化Looper的构造方法中初始化管道和<code>epoll_create</code>    <code>nativeWake</code>最终也是<code>Looper.wake</code></p>
</blockquote>
<h2 id="出队">出队</h2>
<p><code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>方法参数<strong>nextPollTimeoutMillis</strong> (即下个消息的延迟时间的)取值情况。</p>
<table>
<thead>
<tr>
<th style="text-align:left">下个消息的延迟时间</th>
<th>消息队列内</th>
<th>阻塞情况</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&gt;0</td>
<td>延迟最近的消息，触发时机未到</td>
<td>阻塞到触发时机</td>
<td>释放cpu资源</td>
</tr>
<tr>
<td style="text-align:left">=0</td>
<td>延迟最近的消息，触发时机到了</td>
<td>不阻塞</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">=-1</td>
<td>根本没消息</td>
<td>休眠到有消息</td>
<td>释放cpu资源</td>
</tr>
</tbody>
</table>
<h3 id="流程解读">流程解读</h3>
<p><code>next()</code>出队方法，需要一个<code>Message</code>返回值。当<code>nativePollOnce</code>不再阻塞时，因为队列是按触发时机早晚排序的：</p>
<ol>
<li>
<p>通常应该取队首消息；</p>
</li>
<li>
<p>但是队首是同步屏障消息时【Barrier1】，应该取触发时机最近的异步消息。</p>
</li>
</ol>
<p>因此我们先取该msg，不管是队首还是最近异步，再判断是否应该将其返回和其他后续操作。</p>
<ul>
<li>
<p>当msg非空时【2】</p>
<ol>
<li>如果msg触发时机到达【3`】，则返回msg。（当然返回前要整理一下队列）</li>
<li>如果msg触发时机未到【3】，则重新计算触发时间，然后将 <strong>nextPollTimeoutMillis</strong> 设为新时间，然后像下文&quot;当msg为空时&quot;一样，进行是否有IdleHandler及对其处理的操作。【4】/【5，6】</li>
</ol>
</li>
<li>
<p>当msg为空时【2`】，先将 <strong>nextPollTimeoutMillis</strong> 设为-1</p>
<ol>
<li>如果也没有待处理的IdleHandler【4】：则跳出本次循环又回到<code>nativePollOnce</code>，此时<code>nextPollTimeoutMillis=-1</code>,阻塞至有新消息将其唤醒。</li>
<li>如果有待处理的IdleHandler：则遍历执行这些IdleHandler【5】（每次最多四个，执行其<code>queueIdle</code>回调），然后重置IdleHandler计数和<code>nextPollTimeoutMillis=0</code>完成本次循环【6】（<code>nextPollTimeoutMillis=0</code>让下次循环不再阻塞，以检查处理IdleHandler时是否又有新消息入队）。</li>
</ol>
</li>
</ul>
<pre><code class="language-java">Message next() {
    final long ptr = mPtr;/*MessageQueue 的native层地址*/
    if (ptr == 0) {//当消息循环已经退出,则直接返回
        return null;
    }
    int pendingIdleHandlerCount = -1; //待处理闲时handler数量
    int nextPollTimeoutMillis = 0;
    for (;;) {
        nativePollOnce(ptr, nextPollTimeoutMillis);//【1】阻塞：作用类似Java的 object.wait()
        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;/*next()的返回值：此时为队头消息，即最近消息*/
            if (msg != null &amp;&amp; msg.target == null) {//【Barrier1】如果队首是同步屏障消息，msg取最近的异步消息
		do {
                   prevMsg = msg;
                   msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());//msg不是异步消息时，从队头至队尾遍历每个消息，直到msg为异步消息才推出遍历
            }            
            if (msg != null) {//【2】取到待处理的msg
                if (now &lt; msg.when) {/*【3】时机未到：更新延迟时间*/
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {/*【3`】处理msg的时机已到：取出msg，并整理队列*/
                    mBlocked = false;/*是否被阻塞：设为false供存消息时用*/
                    if (prevMsg != null) {/*【Barrier1`】若msg是因同步屏障循，而取出的最近的异步消息，改变指针指向跳过msg*/
                        prevMsg.next = msg.next;
                    } else {/* 取出msg，更新下一条消息为队首*/
                        mMessages = msg.next;
                    }
                    msg.next = null;//即将作为返回值，next变得没意义，置空。
                    return msg;/* 返回next消息*/
                }
            } else {/*【2`】消息为空，即没有消息了*/
                nextPollTimeoutMillis = -1;/*没有消息了，nextPollTimeoutMillis设为-1。线程阻塞*/
            }
            
            /*------------------------------空闲handler处理----------------------------------*/
            /* Idlehandles仅在队列为空或队首消息时机未到时才运行*/
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();/*计算闲时任务量*/
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                mBlocked = true;/*【4】若经过计算上个if计算，连闲时Handler都没有，跳出本次循环*/
                continue;
            }
            if (mPendingIdleHandlers == null) {/*必有闲时任务待处理，否则上个if就continue出去了*/
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        /*【5】必有闲时Handler需要遍历执行。连闲时Handler都没有的情况，在上文的if中continue出去。*/
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
                //【5.1】执行IdleHandler的queueIdle方法，运行IdelHandler，例如处理日志上报 Gc等通过返回值由自己决定是否保持存活状态
               idler.queueIdle();
        }
	/*【6】执行完闲时Handler重置闲时计数和下次延迟时间*/
        pendingIdleHandlerCount = 0;
        // 因为执行闲时Handler(步骤【5】不在synchronized中)过程中，可能有新消息enqueue，需要重新检查。
        // 下次延迟时间置0，下次循环到步骤【1】时不阻塞。
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>
<h3 id="时序图">时序图</h3>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7364839512144d3aecb9f4cd54ea3d4~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午1.41.54.png" loading="lazy"></figure>
<h2 id="入队">入队</h2>
<p><strong>关键变量</strong><code>mBlocked</code>：源码上的注释翻译过来：出队方法<code>next()</code>是否被阻塞在<code>pollOnce()</code>处（<code>nextPollTimeoutMillis≠0</code>）。记录<code>pollonce</code>是否被阻塞的目的就是：<strong>是否需要唤醒</strong></p>
<p>外部暴露操作方法的<code>Handler</code>类下，<code>send(empty)Message/post</code> +<code>atTime/delay/AtFrontOfQueue</code>等操作的最终归宿。<br>
<code>enqueueMessage(Message msg, long when)</code>：插入<code>msg</code>入队，<code>when</code>是自系统启动以来的非休眠运行时间（毫秒）。</p>
<blockquote>
<p>拓展： 插入msg一个到队首。</p>
<pre><code class="language-java">public final boolean sendMessageAtFrontOfQueue(Message msg) {//同理post也有类似方法
 MessageQueue queue = mQueue;
 return enqueueMessage(queue, msg, 0);
}
private boolean enqueueMessage(MessagdsieQueue queue, Message msg,
     long uptimeMillis) {
 return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
</blockquote>
<p><code>enqueueMessage(Message msg, long when)</code>：插入<code>msg</code>入队，<code>when</code>是自系统启动以来的非休眠运行时间（毫秒）。</p>
<h3 id="流程解读-2">流程解读</h3>
<p>入队一个消息，流程参考存消息的情况图，并对照下边的代码。</p>
<h4 id="情况一">情况【一】</h4>
<p>队列为空、新消息是即时消息、新消息是延时最短消息时</p>
<p>入队的新消息插入到队头的情况：都需要<code>nativeWake</code>唤醒 出队的<code>pollonce</code></p>
<table>
<thead>
<tr>
<th><strong>a.队列内没消息</strong></th>
<th><strong>b.新入队的消息延时为0</strong></th>
<th>c.新入队的消息比队首的触发时机还早，与b类似</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d1b60d3dcd4231b7dc9f00bf54704d~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午4.42.24.png" style="zoom:33%;" /></td>
<td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5754fd2fe0ca4f1d88c26625ce245c27~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午4.43.42.png" style="zoom:33%;" /></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>通过改变队首消息和新消息的next指针指向，把消息插入。</li>
<li>是否需要唤醒<code>needWake = mBlocked</code>, 这时候出队<code>pollonce</code>处<strong>队列还没消息</strong>或<strong>最近消息时机未到</strong>，还被<strong>阻塞</strong>，<strong>mBlocked=true</strong>是必然的。然后<code>nativeWake</code>去唤醒<code>pollonce</code>去取刚存入的消息。</li>
</ol>
<h4 id="情况二">情况【二】</h4>
<p>新消息不是上述的情况，不插入到队首，而是插入到队列中部。先查找位置再插入。</p>
<table>
<thead>
<tr>
<th>队头是同步屏障消息</th>
<th>且插入的消息是最近的异步消息</th>
<th>插入的消息不是最近的异步消息</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751b07ecd9094d3192904c99ffdcada2~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午5.03.37.png" style="zoom:33%;" /></td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15bbb1919f144d41a8082677781ded3d~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 上午5.04.16.png" style="zoom:33%;" /></td>
</tr>
<tr>
<td>是否需要唤醒</td>
<td>需要唤醒</td>
<td>不需要唤醒</td>
</tr>
</tbody>
</table>
<p><strong>除非队头是同步屏障消息，插入的消息是最近的异步消息</strong>，其他多数插入到队列中部的情况都不需唤醒</p>
<p>是否需要唤醒的条件<code>needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</code></p>
<ol>
<li>出队<code>pollonce</code>处最近消息时机未到（经过上个if，队列现在非空），还被阻塞，<strong>mBlocked=true</strong>还是必然的。</li>
<li><code>p.target == null</code>队首p的target为空符合同步屏障消息特点。</li>
<li><code>msg.isAsynchronous()</code> 新插入队列中部的消息是异步消息。</li>
</ol>
<p>合起来<strong>唤醒条件</strong>就是：“<strong>队列内最近的消息触发时机未到，且队首消息是同步屏障消息时，新插入了一条异步消息</strong>”（还可能改变）。</p>
<p>然后再通过改变<code>next</code>指针指向，从队首至队尾遍历，查找合适的插入位置：</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb947d8d2954f5898eb54b66680b854~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午6.08.53.png" loading="lazy"></figure>
<ol>
<li><code>（when &lt; p.when）</code>即新消息触发时机早于该位置的触发时机，插入位置找到，跳出遍历。</li>
<li><code>p == null</code>遍历到末尾，新消息的触发时机比队内的消息都晚，插入位置为队尾，跳出遍历。</li>
<li>查找插入位置的过程中。如果发现异步消息，则新消息虽异步，但不是离触发最近的，无需唤醒。因此<strong>唤醒条件</strong>更新为：队首是同步屏障消息时，新插入的消息为<strong>离触发最近的异步消息</strong>。</li>
</ol>
<p>最后改变指针指向，把消息插入到对应位置。</p>
<pre><code class="language-java">boolean enqueueMessage(Message msg, long when) {    
    synchronized (this) {/*可能有多个不同线程发消息*/
        msg.when = when;
        Message p = mMessages;// p 赋值为队首。根据触发时机when 来排序
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
          //【一】插入头部并唤醒：1、队列为空时 2、新消息延时为0是即时消息 3、新消息延时比队首的更短
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;/*出队方法next是否被阻塞在pollOnce()处（nextPollTimeoutMillis≠0）*/
        } else {//【二】消息插入MessageQueue中间，一般不需唤醒线程。除非队首同步屏障，且msg为!最近的!异步消息
            //【二a】队首是同步屏障消息，且插入的msg是异步消息。
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                /*prev、p 从队列的0、1 一直增至 last、null，来寻找msg合适的插入位置*/
                if (p == null /*last.next=null 插入到末尾*/|| when &lt; p.when/*（队列的p.when越来越大1235，when=4）*/
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {//【二b】插入的msg是异步消息是最近的
                    //在寻找msg插入位置过程中发现异步消息。说明msg前还有更早的异步消息。msg虽异步、但非最近。不需唤醒
                     needWake = false;
                }
            }
            /*经过循环确定插入位置，将入队的msg插入到prev与p中间 （3-5之间）*/
            msg.next = p; 
            prev.next = msg;
        }
        if (needWake) {
            nativeWake(mPtr);//【三】唤醒线程，nativePollOnce不在阻塞
        }
    }
    return true;
}
</code></pre>
<h3 id="流程图">流程图</h3>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2adc6671993c4434b420e4f5d4e21811~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-23 下午8.15.15.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法01复杂度分析]]></title>
        <id>https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-01-fu-za-du-fen-xi/</id>
        <link href="https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-01-fu-za-du-fen-xi/">
        </link>
        <updated>2021-03-13T06:46:49.000Z</updated>
        <summary type="html"><![CDATA[<p>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p>
<!-- more -->
<p>通过统计、监控，就能得到算法执行的时间和占用的内存大小<strong>事后统计法</strong>有缺陷</p>
<ol>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ol>
<p>因此需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。即<strong>时间、空间复杂度分析方法</strong>。</p>
<h2 id="大-o-复杂度表示法">大 O 复杂度表示法</h2>
<pre><code class="language-java"> int cal(int n) {
   int sum = 0;//1
   int i = 1;//1
   int j = 1;//1
   for (; i &lt;= n; ++i) {//执行n次
     j = 1;//执行n次
     for (; j &lt;= n; ++j) {//执行n^2次
       sum = sum +  i * j;//执行n^2次
     }
   }
 }
</code></pre>
<p>假设每行代码执行的时间都一样，为 unit_time。</p>
<p>总的执行时间 T(n) = (2n^2+2n+3)*unit_time。</p>
<p><strong>代码总的执行时间 T(n) 与每行代码的执行次数n成正比</strong>，总结成公式为</p>
<blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>n表示数据的规模大小</p>
<p>T(n)总代码执行的时间</p>
<p>f(n) 表示每行代码执行的次数总和是一个表达式。</p>
<p>O：表示代码的执行时间 T(n) 与 f(n)代码执行总次数表达式成正比。</p>
</blockquote>
<p>T(n) = O(2n^2+2n+3)。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。</p>
<ol>
<li>
<p><strong>1. 只关注循环执行次数最多的一段代码</strong></p>
<p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p>
</li>
<li>
<p><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p>
<p>整体中有多个独立的复杂度操作，整体的复杂度为独立操作中最大的复杂度</p>
</li>
<li>
<p><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p>
<p>嵌套循环复杂度为内外操作复杂度的乘积</p>
</li>
</ol>
<h3 id="常见时间复杂度">常见时间复杂度</h3>
<img src="https://Joshua-Chang.github.io/post-images/1615628804979.jpg" style="zoom: 50%;" />
<ol>
<li><strong>O(1)</strong><br>
代码的执行时间不随 n 的增大而增长。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</li>
<li><strong>O(m+n)、O(m*n)</strong><br>
时间复杂度<strong>由两个数据的规模</strong>决定</li>
<li><strong>O(logn)、O(nlogn)</strong></li>
</ol>
<pre><code class="language-java">i=1;
while (i &lt;= n)  {
i = i * 2;
}
</code></pre>
<p>时间复杂度可转化成</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^i=n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8746639999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>求i问题，结果为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>以2为底n的对数，因此这段代码时间复杂度为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>同理当循环内为 i = i * 3时因为对数间可以相互转换</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mn>2</mn><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_3n=log_32 * log_2n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>所以同理可得</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>C</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_3n) = O(C * log_2n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">C=log_32
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span></span></p>
<p>C是一个常量，忽略系数则复杂度相同。因此在对数阶时间复杂度的表示方法里，忽略对数的“底”。</p>
<p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就为:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>归并排序、快速排序的时间复杂度都是这样。</p>
<p>常见的复杂度从低阶到高阶：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )</p>
<img src="https://Joshua-Chang.github.io/post-images/1615628794973.jpg" style="zoom: 33%;" />
<h2 id="空间复杂度分析">空间复杂度分析</h2>
<p>空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<h2 id="概率纬度">概率纬度</h2>
<p><strong>最好情况时间复杂度</strong>（best case time complexity）、<strong>最坏情况时间复杂度</strong>（worst case time complexity）、<strong>平均情况时间复杂度</strong>（average case time complexity）、<strong>均摊时间复杂度</strong>（amortized time complexity）。</p>
<pre><code class="language-java">// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x){
			pos = i;      
      break;
    } 
  }
  return pos;
}
</code></pre>
<p>在无序的数组中，查找变量的位置</p>
<p><strong>最好情况时间复杂度</strong>:遍历数组时第一位就是O(1)</p>
<p><strong>最坏情况时间复杂度</strong>:遍历数组完毕也没找到O(n)</p>
<p><strong>平均情况时间复杂度</strong>:变量在数组中的位置有n+1种情况（在数组中n种，不在1种）,求得其<strong>加权平均值</strong>为 (3n+1)/4。去掉系数和常量仍为O(n)</p>
<p><strong>均摊时间复杂度</strong>：</p>
<ol>
<li>insert() 在大部分情况下，时间复杂度都为 O(1)，个别情况下为 O(n)。</li>
<li>O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，的频率有前后时序关系规律。一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入，循环往复。</li>
</ol>
<p><strong>摊还分析法</strong>：把1次耗时多的 O(n) 的插入操作，均摊到接下来的 n-1 次耗时少的操作上。均摊时间复杂度就是 O(1)。</p>
<pre><code class="language-java"> int[] array = new int[n];
 int count = 0;
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i &lt; array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }
 
    array[count] = val;
    ++count;
 }
</code></pre>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理05处理器设计 下]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-05-chu-li-qi-she-ji-xia/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-05-chu-li-qi-she-ji-xia/">
        </link>
        <updated>2021-03-12T17:53:50.000Z</updated>
        <content type="html"><![CDATA[<img src="https://Joshua-Chang.github.io/post-images/1615571610811.png" style="zoom:25%;" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理04处理器设计 上]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-04-chu-li-qi-she-ji-shang/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-04-chu-li-qi-she-ji-shang/">
        </link>
        <updated>2021-03-12T17:52:40.000Z</updated>
        <content type="html"><![CDATA[<p>指令+运算=CPU</p>
<p>“<strong>指令</strong>”部分，代码如何变成机器能够理解的指令，以及是按照什么样的顺序运行的。</p>
<p>“<strong>计算</strong>”部分，数据的二进制表示、加法和乘法又是通过什么样的电路来实现的。</p>
<p>本文把“指令”和“计算”连通起来，完整的 CPU 运转。</p>
<img src="https://Joshua-Chang.github.io/post-images/1615571610811.png" style="zoom:25%;" />
<h2 id="建立数据通路">建立数据通路</h2>
<h4 id="指令周期instruction-cycle">指令周期（Instruction Cycle）</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理03指令和运算 下]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan-xia/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan-xia/">
        </link>
        <updated>2021-03-12T08:00:23.000Z</updated>
        <summary type="html"><![CDATA[<p>程序 = 算法 + 数据结构</p>
<p>算法：各种计算机指令</p>
<p>数据结构：二进制数据</p>
]]></summary>
        <content type="html"><![CDATA[<p>程序 = 算法 + 数据结构</p>
<p>算法：各种计算机指令</p>
<p>数据结构：二进制数据</p>
<!-- more -->
<img src="https://Joshua-Chang.github.io/post-images/1615480260058.png" style="zoom:25%;" />
<h2 id="二进制">二进制</h2>
<p>二进制转十进制：从 0 开始，从右到左的第 N 位✖️2 的 N 次方，然后相加。</p>
<p>十进制转二进制：<strong>短除法</strong>，递归除以 2 的余数，从右往左填入，直到商0。</p>
<p>负数：一个 4 位的二进制数，补码最左侧的一位，当成正负号，0 为正数，1 为负数。这一位并非单独的符号位。在计算整个二进制值的时候，在左侧最高位前面加个正负号。 十进制−5，用4 位的二进制补码数值 1011。-2<sup>3+2</sup>1+2^0。首位前加负号：-8+2+1=-5。</p>
<h3 id="字符串">字符串</h3>
<p>最早计算机只需要使用英文字符，加上数字和一些特殊符号，然后用 8 位的二进制就能表示，即<strong>ASCII 码</strong>（American Standard Code for Information Interchange，美国信息交换标准代码）。ASCII 码就好比一个字典，用 8 位二进制中的 128 个不同的数，映射成 128 个不同的字符。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548790038.png" style="zoom: 33%;" /></p>
<blockquote>
<p>小写字母 a 在 ASCII 里面，就是第 97 个，8位二进制的 0110 0001，十六进制61</p>
<p>大写字母 A 在 ASCII 里面，就是第 65 个，8位二进制的 0100 0001，十六进制41</p>
<p>单个数字不再用整数表示法，反而用8位二进制，字符串数字9，第57个，用8位二进制0011 1001 ，十六进制39</p>
<p>字符串 数字15 不用 0000 1111 这 8 位来表示，而用两个 8 位来表示，即用两个字符 1 和 5 连续在一起，也就是 0011 0001 和 0011 0101。</p>
</blockquote>
<p>因此在存储数据的时候，采用二进制序列化这样的方式，而不是 CSV 或者 JSON，这样的文本格式。<strong>不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。</strong></p>
<p>随着越来越多的不同国家的人都用上了计算机，ASCII 码128 个字符不够用。于是出现了不同的的<strong>字符集</strong>（Charset）和<strong>字符编码</strong>（Character Encoding）。</p>
<p>其中Unicode字符集，包含了 150 种语言的 14 万个不同的字符。</p>
<p>字符编码则是对于字符集里的字符，用二进制表示出来的一个字典。Unicode，可以用 UTF-8、UTF-16，UTF-32、GB2312等来进行编码，存储成二进制。解码和展示时使用不同的编码方式，就会出现乱码。</p>
<p><strong>ASCII 码</strong>是对有128个字符的“小字符集”的编码。编码的目的就是把文字二进制存储。</p>
<h2 id="理解电路">理解电路</h2>
<p>我们通过电路的“开”和“关”，来表示“1”和“0”，晶体管在不同的情况下，表现为导电的“1”和绝缘的“0”的状态。</p>
<p>一方面，我们可以通过继电器或者中继（Relay），进行长距离的信号传输。另一方面，我们也可以通过设置不同的线路和开关状态，实现更多不同的信号表示和处理方式，这些线路的连接方式就是我们在数字电路中所说的门电路。</p>
<blockquote>
<p>“与（AND）”：提供串联的两个开关，只有两个开关都打开，电路才接通</p>
<p>“或（OR）”：两条线路上各有一个开关，任何一个开关打开了，电路都接通</p>
<p>“非（NOT）”：数字电路中使用<strong>反向器</strong>（Inverter）</p>
</blockquote>
<p><strong>门电路</strong>是我们创建 CPU 和内存的基本逻辑单元。各种对于计算机二进制的“0”和“1”的门电路操作，叫作组合逻辑电路。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548823929.jpg" alt="" loading="lazy"></p>
<h2 id="加法器">加法器</h2>
<p><strong>bit</strong> （缩写b）位。是计算机存储数据的最小单位，只有0和1两种值。</p>
<p><strong>byte</strong>（缩写B）字节。是8个bit组成了信息的最小单位，也就是字节。来源于<strong>ASCII码</strong>有128个字符，需用8位表示。</p>
<p>二进制，从右往左数，第一列是个位，第二列是“二位”，对应的再往左，就应该分别是四位、八位。</p>
<h3 id="异或门">异或门</h3>
<p>四种个位数相加</p>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615548862709.jpg" alt="" loading="lazy"></figure>
<p>输入：4 种组合00、01、10、11。</p>
<p>输出：00/11 情况下输出0，10/01 情况下输出1</p>
<p>这种输入输出的对应关系即“异或门（XOR / ^）”。虽然在逻辑运算里面没有出现的形式，但作为一个基本电路。<strong>异或门就是一个最简单的整数加法所需要的基本门电路</strong>。</p>
<h3 id="半加器">半加器</h3>
<p>输入的是 11 的情况下，还需向更左侧进位。对应一个与门：即当且仅当加数和被加数都是 1 的时候，才进位 1。</p>
<p>通过一个<strong>异或门</strong>计算出个位，通过一个<strong>与门</strong>计算出是否进位，就通过电路算出了一个一位数的加法。<strong>我们把两个门电路打包，给它取一个名字，就叫作半加器</strong>（Half Adder）。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548907425.jpg" alt="" loading="lazy"></p>
<h3 id="全加器">全加器</h3>
<p>半加器不能计算“二位”，因为“二位”是加数、被加数、进位信号 三个数相加。<strong>我们用两个半加器和一个或门，就能组合成一个全加器</strong>。（此处的二位与非个位的其他位原理相同）</p>
<p>第一个半加器，个位的加法，得到是否进位 X 和对应的二个数加和后的结果 Y；</p>
<p>然后把结果 Y和右侧个位数相加后的进位信息 ，连接到第二个半加器上；</p>
<p>就产生一个是否进位的信号 V 和对应的加和后的结果 W 即二位的结果；</p>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615548945005.jpg" alt="" loading="lazy"></figure>
<p>最后把两个半加器的进位信息，输入或门连接起来。即两次加法中，任何一个需要进位，都向左侧进位。</p>
<p>（即使三个 bit 相加，即使 3 个 bit 都是 1，也最多会进一位）</p>
<p>有了全加器，对两个 8 bit 数相加变得容易，只要把 8 个全加器串联起来即可。个位的全加器的进位信号作为二位全加器的输入信号，二位全加器的进位信号再作为四位的全加器的进位信号。同理可扩展到 16 位、32 位，乃至 64 位。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548959815.jpg" alt="" loading="lazy"></p>
<p>对于这个8位串联全加器：</p>
<p>在最右侧个位，我们只需要用一个半加器，或者让全加器的进位输入始终是 0。</p>
<p>在最左侧的一位输出的进位信号，并不表示再进一位，而表示加法是否溢出。</p>
<p><strong>分层</strong><br>
<img src="https://Joshua-Chang.github.io/post-images/1615548968172.jpg" style="zoom: 10%;" /></p>
<p>在上面的一层，我们只需要考虑怎么用下一层的组件搭建出自己的功能，而不需要下沉到更低层的其他组件。就像你之前并没有深入学习过计算机组成原理，一样可以直接通过高级语言撰写代码，实现功能。</p>
<p>在硬件层面，通过门电路、半加器、全加器一层层搭出了加法器这样的功能组件。这些用来做算术逻辑计算的组件叫作 ALU，也就是算术逻辑单元。</p>
<p>当进一步打造强大的 CPU 时，我们不再关注最细颗粒的门电路，只需要把门电路组合而成的 ALU，当成一个能够完成基础计算的黑盒子就可以了。</p>
<h2 id="乘法器">乘法器</h2>
<p>实际的乘法，就退化成了位移和加法。</p>
<p>13×9 被乘数 13 表示成二进制是 1101，乘数 9 在二进制里面是 1001。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615563769473.jpg" alt="" loading="lazy"></p>
<p>实际上，像 13×9 这样两个四位数的乘法，不需要把四次单位乘法的结果，用四组独立的开关单独都记录下来，然后再把这四个数加起来。</p>
<p>先拿乘数最右侧的个位乘以被乘数，然后把结果写入用来存放计算结果的开关里面，然后，把被乘数左移一位，把乘数右移一位，仍然用乘数去乘以被乘数，然后把结果加到刚才的结果上。反复重复这一步骤，直到不能再左移和右移位置。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615563804280.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>这里的控制测试，其实就是通过一个时钟信号，来控制左移、右移以及重新计算乘法和加法的时机。</p>
</blockquote>
<p>把乘法展开，变成了“<strong>加法 + 位移</strong>”来实现。 4 位数要进行 4 组“位移 + 加法”的操作。而且这 4 组操作还不能同时进行。因为<strong>下一组的加法要依赖上一组的加法后的计算结果，下一组的位移也要依赖上一组的位移的结果。这样，整个算法是“顺序”的，每一组加法或者位移的运算都需要一定的时间</strong>。</p>
<p>一个顺序乘法器硬件进行计算的时间复杂度是 O(N)。这里的 N，就是乘法的数里面的<strong>位数</strong>。</p>
<h3 id="电路并行">电路并行</h3>
<p>目前的乘法实现就像是单败淘汰赛</p>
<img src="https://Joshua-Chang.github.io/post-images/1615563936931.jpg" style="zoom:25%;" />
<p>我们 CPU 的硬件上，用更多的晶体管开关，来放下中间计算结果。把 O(https://Joshua-Chang.github.io/post-images/1615563995243.jpg&quot; style=&quot;zoom:25%;&quot; /&gt;</p>
<p>加法器中每一个全加器，都要等待上一个全加器，这个等待的时间叫作<strong>门延迟</strong>（Gate Delay）。每通过一个门电路，计作1“T”。全加器就已经有了 3T 的延迟（进位需要经过 3 个门电路），而 4 位整数，最高位的计算需要等待前面三个全加器的进位结果，即等 9T 延迟。</p>
<p>除了门延迟外，还有<strong>时钟频率</strong>，在上面的顺序乘法计算里面，如果我们想要用更少的电路，计算的中间结果需要保存在寄存器里面，然后等待下一个时钟周期的到来，控制测试信号才能进行下一次移位和加法。</p>
<p>因为电路是天然并行的，一个输入信号，可以同时传播到所有接通的线路当中。下图展示了加法器。如果完全展开电路，高位的进位和计算结果，可以和低位的计算结果同时获得。</p>
<blockquote>
<img src="https://Joshua-Chang.github.io/post-images/1615564005050.jpg" style="zoom:15%;" />
C4 是前 4 位的计算结果是否进位的门电路表示。因此一个 4 位整数最高位是否进位，展开门电路图，你会发现，我们只需要 3T 的延迟就可以拿到是否进位的计算结果。
</blockquote>
<p>电路天然的并行性。电路只要接通，输入的信号自动传播到了所有接通的线路里面，这其实也是硬件和软件最大的不同。</p>
<p>无论是把对应的门电路逻辑进行完全展开以减少门延迟，还是通过并行计算多个位的乘法，都把一个计算的电路变复杂了。而电路变复杂了，也就意味着晶体管变多了。通过更多的晶体管，就可以拿到更低的门延迟，以及用更少的时钟周期完成一个计算指令。</p>
<p>是用更少更简单的电路，但是需要更长的门延迟和时钟周期；还是用更复杂的电路，但是更短的门延迟和时钟周期来计算一个复杂的指令，就是RISC 和 CISC 的区别。</p>
<h2 id="浮点数和定点数">浮点数和定点数</h2>
<p>计算机通常用 16或32 个比特（bit）4/8byte来表示一个数，只能表示 2 的 32 次方个不同的数，差不多是 40 亿个。</p>
<p>实数集合是无限多的，让这 40 亿个数映射到实数集合上的哪些数呢？</p>
<h3 id="定点数的表示">定点数的表示</h3>
<p>每4bit来表示 0～9 的整数，32bit即可表示8个这样的正数，把最右边的 2 个 0～9 的整数，当成小数部分；把左边 6 个 0～9 的整数，当成整数部分。这样用 32 个bit，表示从 0 到 999999.99 共 1 亿个实数这种直观的表示法叫<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E7%A2%BC%E5%8D%81%E9%80%B2%E6%95%B8"><strong>BCD 编码</strong></a>（Binary-Coded Decimal），用于超市、银行这样需要用小数记录金额。</p>
<p><strong>第一，这样的表示方式有点“浪费”</strong>：本来可以表示2^32约40亿个数，结果才表示了1亿个。</p>
<p><strong>第二，这样的表示方式没办法同时表示很大的数字和很小的数字。</strong></p>
<h3 id="浮点数的表示">浮点数的表示</h3>
<p><strong>浮点数</strong>（Floating Point），用科学计数法来表示实数。</p>
<p>因为这个数对应的小数点的位置是“浮动”的，它才被称为浮点数。随着指数位 e 的值的不同，小数点的位置也在变动。而BCD 编码的实数，小数点固定在某一位的方式称为<strong>定点数</strong>。</p>
<p><strong>IEEE</strong>标准定义了，用32 比特表示单精度的浮点数即 float 或者 float32 类型，用 64 比特表示双精度的浮点数即double 或者 float64 类型。</p>
<p>浮点数的组成分成三部分</p>
<p>单精度的 32 个比特如下，双精度则每部分bit增加一倍</p>
<figure data-type="image" tabindex="3"><img src="https://Joshua-Chang.github.io/post-images/1615571233192.jpg" alt="" loading="lazy"></figure>
<ol>
<li>第一部分是一个<strong>符号位</strong> S，用来表示是正数还是负数。浮点数都是有符号的。负数1正数0</li>
<li>接下来的8 bit组成<strong>指数位</strong> e。8bit能够表示的整数是 0～255，用 1～254 映射到 -126～127 这 254 个有正有负的数上。e作为指数可正可负，可以同时表示很大或很小的数。0和255单独表示。</li>
<li>最后是一个 23 bit组成的<strong>有效数位</strong>f</li>
</ol>
<p>最终浮点数表示为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>s</mi></msup><mo>∗</mo><mn>1.</mn><mi>f</mi><mo>∗</mo><msup><mn>2</mn><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">(-1)^s*1.f*2^e
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>在e=0且f=0时表示浮点数的0。当e=255且f=0时，s为0表示无穷大，s为1表示无穷小。</p>
<p>浮点数无论是表示还是计算其实都是近似计算，比如0.3、0.9难以用指数绝对表达。</p>
<h3 id="浮点数的二进制转化">浮点数的二进制转化</h3>
<p>浮点数二进制：<strong>符号位 s+ 指数位 e+ 有效位数 f</strong></p>
<h4 id="二进制小数转十进制小数">二进制小数转十进制小数</h4>
<p>0.1001</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>1</mn><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>2</mn><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>3</mn><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>4</mn><mo>=</mo><mn>0.5625</mn></mrow><annotation encoding="application/x-tex">1×2^−1+0×2^−2+0×2^−3+1×2^−4=0.5625
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.821331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">6</span><span class="mord">2</span><span class="mord">5</span></span></span></span></span></p>
<h4 id="十进制小数转二进制小数">十进制小数转二进制小数</h4>
<p>和整数的二进制表示采用“除以 2，然后看余数”的方式相反。</p>
<p>乘以 2，看是否超过 1。如果超过 1，我们就记下 1，并把结果减去 1；减去1的结果继续乘以2，进一步循环操作。</p>
<blockquote>
<p><img src="https://Joshua-Chang.github.io/post-images/1615571288146.jpg" alt="" loading="lazy"><br>
以0.1为例，0.000110011。这里的“0011”会无限循环下去。</p>
</blockquote>
<h4 id="例子">例子</h4>
<p><strong>十进制9.1的的二进制表示</strong></p>
<p>1001.000110011…</p>
<p>用科学记数法1.001000110011…×2^3</p>
<p>符号位 s = 0,有效位 f=00100011001100110011001共23位，指数 e=3</p>
<blockquote>
<p>因为指数位有正又有负，指数位在 127 之前代表负数，之后代表正数，那 3 其实对应的是加上 127 的偏移量 130，转化成二进制就是 10000010。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://Joshua-Chang.github.io/post-images/1615571313898.jpg" alt="" loading="lazy"></figure>
<p>把“s+e+f”拼在一起，浮点数 9.1 的二进制表示为</p>
<p>01000<strong>0010</strong> 0010 <strong>0011001100110011</strong> <strong>001</strong></p>
<p>换算成十进制是 9.09999942779541015625</p>
<h3 id="浮点数的加法和精度损失">浮点数的加法和精度损失</h3>
<p>十进制的数值，转化成 IEEE-754 标准下的浮点数在做加法。</p>
<p>浮点数的加法是<strong>先对齐、再计算</strong>。</p>
<p>两个浮点数的指数位可能是不一样的，所以我们要把两个的指数位，变成一样的，然后只去计算有效位的加法。</p>
<h4 id="例子-2">例子</h4>
<p>0.5，表示成浮点数，指数位是 -1，有效位是 00…（后面全是 0，记住 f 前默认有一个 1）</p>
<p>0.125 表示成浮点数，对应的指数位是 -3，有效位也还是 00…（后面全是 0，记住 f 前默认有一个 1）</p>
<ol>
<li>指数位对齐：把指数位都统一成两个其中较大的 -1，0.125 的有效位 1.00…也要对应右移两位变成0.01。</li>
<li>然后计算两者相加的有效位 1.0+0.01=1.01</li>
<li>得到结果浮点数，符号位是0，指数位是 -1，有效位是1.01</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://Joshua-Chang.github.io/post-images/1615571340870.jpg" alt="" loading="lazy"></figure>
<h4 id="丢失精度">丢失精度</h4>
<p>浮点数的加法过程中，需要先对齐，其中指数位较小的数，需要在有效位进行右移，在右移的过程中，最右侧的有效位就被丢弃掉了。导致对应的指数位较小的数，在加法发生之前，就<strong>丢失精度</strong>。</p>
<p>两个相加数的指数位差的越大，位移的位数越大，可能丢失的精度也就越大。（丢失的有效位都是 0例外）</p>
<p>在32位浮点数中，有效位长度一共只有 23 位，指数位较小的数右移 24 位之后，所有的有效位就都丢失了。</p>
<p>因此32位浮点数实际计算中，只要两个数差出 2^24，那这两个数相加之后，结果完全不会变化。</p>
<h4 id="kahan-summation-算法">Kahan Summation 算法</h4>
<p>在一些“积少成多”的计算过程中，比如在机器学习中，我们经常要计算海量样本计算出来的梯度或者 loss，于是会出现几亿个浮点数的相加。每个浮点数可能都差不多大，但是随着累积值的越来越大，就会出现“大数吃小数”的情况。</p>
<p>Kahan累加算法：在每次的计算过程中，都用一次减法，把当前加法计算中损失的精度记录下来。然后在后面的循环中，把这个精度损失放在要加的小数上，再做一次运算。</p>
<pre><code class="language-java">public class KahanSummation {
  public static void main(String[] args) {
    float sum = 0.0f;
    float c = 0.0f;
    for (int i = 0; i &lt; 20000000; i++) {
    	float x = 1.0f;
    	float y = x - c;
    	float t = sum + y;
    	c = (t-sum)-y;
    	sum = t;    	
    }
    System.out.println(&quot;sum is &quot; + sum);   
  }	
}
</code></pre>
<p>一般情况下，在实践应用中，对于需要精确数值的，比如银行存款、电商交易，我们都会使用定点数或者整数类型。比如在 MySQL 里的 decimal(12,2)，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理02指令和运算 上]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/">
        </link>
        <updated>2021-03-11T09:41:24.000Z</updated>
        <summary type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
<!-- more -->
<p>不同的 CPU 能够听懂的语言不太一样，即计算机指令集Instruction Set<br>
<img src="https://Joshua-Chang.github.io/post-images/1615480260058.png" style="zoom:25%;" /></p>
<h2 id="指令和机器码">指令和机器码</h2>
<ol>
<li>
<p>把高级语言程序翻译成汇编语言（ASM，Assembly Language）程序，的过程叫编译（Compile）成汇编代码</p>
</li>
<li>
<p>再用汇编器（Assembler）翻译成机器码（Machine Code），CPU 能够真正认识的计算机指令<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460135310.png" style="zoom: 33%;" /><br>
<img src="https://Joshua-Chang.github.io/post-images/1615460148801.jpg" alt="" loading="lazy"></p>
</li>
</ol>
<blockquote>
<p>e.g.<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460725402.jpg" alt="" loading="lazy"><br>
MIPS 的指令是一个 32 位的整数，高 6 位叫操作码（Opcode），分别是 R、I 和 J，代表这条指令具体的操作类别。rt、rt、rd均为寄存器地址。<br>
R 指令是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。</p>
<p>I 指令，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。</p>
<p>J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。</p>
<p><code>add $t0,$s2,$s1</code>为例 s1 17    s2 18      t0 8<br>
<img src="https://Joshua-Chang.github.io/post-images/1615461145867.jpg" alt="" loading="lazy"><br>
<img src="https://Joshua-Chang.github.io/post-images/1615461154758.png" style="zoom: 15%;" /></p>
</blockquote>
<p>除了 C 这样的编译型的语言之外，Python 这样的解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java 这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译(JIT)成为机器码来最终执行。</p>
<h2 id="指令跳转">指令跳转</h2>
<blockquote>
<p>CPU 其实就是由一堆寄存器组成的。而寄存器是由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。</p>
<p>N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。</p>
</blockquote>
<h3 id="cpu-里面的寄存器">CPU 里面的寄存器：</h3>
<p>一个是<strong>PC 寄存器</strong>（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。它就是用来存放下一条需要执行的计算机指令的内存地址。</p>
<p>第二个是<strong>指令寄存器</strong>（Instruction Register），用来存放当前正在执行的指令。</p>
<p>第三个是<strong>条件码寄存器</strong>（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。<strong>零标志条件码</strong>（对应的条件码是 ZF，Zero Flag 不等为0）、<strong>进位标志</strong>（CF，Carry Flag A&gt;B 为0）、<strong>符号标志</strong>（SF，Sign Flag正数为0）以及<strong>溢出标志</strong>（OF，Overflow Flag）</p>
<p>其他用来存储数据和内存地址的寄存器：通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等，通用寄存器（既可以存放数据，又能存放地址）</p>
<p>一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令，读取到指令寄存器里面执行，然后顺序读取下一条指令。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472744523.jpg" alt="" loading="lazy"></p>
<h3 id="ifelse">if…else</h3>
<pre><code class="language-c">#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
}
</code></pre>
<pre><code class="language-shell">$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
</code></pre>
<p><strong>汇编代码</strong></p>
<p>r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令</p>
<p>cmp 指令比较了前后两个操作数的值： 操作对象1 - 操作对象2 但不保存结果，只是根据结果修改相应的标志位。</p>
<ol>
<li>DWORD PTR 代表操作的数据类型是 32 位的整数，[rbp-0x4] 则是一个寄存器的地址。</li>
<li>第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示</li>
</ol>
<p>cmp 指令的比较结果，会存入到<strong>条件码寄存器</strong>当中去，<strong>零标志条件码</strong>ZF 相等为1，不等为0</p>
<p>cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令</p>
<p>jne 指令： jump not equal 查看零标志位ZF不等于0，则跳转到4a（当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址）</p>
<p>CPU 再把 4a 地址里的指令加载到指令寄存器中来执行，mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。</p>
<p>mov 指令的第一个操作数 eax，代表累加寄存器，这条指令其实没有实际的作用，它的作用是一个占位符。</p>
<p>if 条件满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令，跳转的地址就是51。</p>
<p>main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。</p>
<pre><code class="language-shell"> if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0 //只比较，结果存入标识位
  3f:   75 09                   jne    4a &lt;main+0x4a&gt; //标识位ZF不等于0则执行
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 &lt;main+0x51&gt;
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615472764389.jpg" alt="" loading="lazy"></figure>
<h3 id="forwhile">for/while</h3>
<p>对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。</p>
<p>jle 跳转的地址，是在这条指令之前的地址 14。往前跳转使得，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472775030.jpg" alt="" loading="lazy"></p>
<p>除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。</p>
<h2 id="函数调用">函数调用</h2>
<blockquote>
<p>函数调用和 if…else 和 for/while 循环有点像。都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。</p>
<p>区别是，if…else 和 for/while 的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令。</p>
<p>而函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行 call 之后的指令。</p>
<p>把被调用函数的指令直接插入在调用处的方法不太好。那就把后面要跳回来执行的指令地址给记录下来。</p>
</blockquote>
<p>我们在内存里面开辟一段空间，用栈这个<strong>后进先出</strong>（LIFO，Last In First Out）的数据结构。</p>
<p>每次程序调用函数之前，都把函数调用完成后的返回地址、参数数据等开辟一块内存空间，即<strong>栈帧</strong>（Stack Frame）。<strong>压栈</strong>。如果函数执行完了，这就<strong>出栈</strong>。栈底的内存地址是在一开始就固定的，而一层层压栈之后，栈顶的内存地址是在逐渐变小。</p>
<p>指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。</p>
<p>call 的同时进行了一次 push把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。</p>
<pre><code class="language-c">// function_example.c
#include &lt;stdio.h&gt;
int static add(int a, int b)
{
    return a+b;
}
int main()
{
    int x = 5;
    int y = 10;
    int u = add(x, y);
}
</code></pre>
<pre><code class="language-shell">int static add(int a, int b)
{
   0:   55                      push   rbp //压栈register base pointer原栈帧指针
   1:   48 89 e5                mov    rbp,rsp //register stack pointer当前栈指针
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
}
  12:   5d                      pop    rbp //将当前的栈顶出栈
  13:   c3                      ret //出栈 到call调用时PC里的下一条地址  
0000000000000014 &lt;main&gt;:
int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);
  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 &lt;add&gt;//跳转后的程序地址 PC里的下一条地址等信息压栈
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    
</code></pre>
<h3 id="stack-overflow">stack overflow</h3>
<p>通过引入栈，函数调用只需要通过维持 rbp 和 rsp，这两个维护栈顶所在地址的寄存器，就能管理好不同函数之间的跳转。但函数调用层数太多，我们往栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误。（如：函数调用自己，并且不设任何终止条件）</p>
<p>除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来 stack overflow。</p>
<h3 id="函数内联inline">函数内联inline</h3>
<p>只要在 GCC 编译的时候，加上对应的一个让编译器自动优化的参数 -O，编译器就会在可行的情况下，进行这样的指令替换。或者在定义函数的地方，加上 inline 的关键字，来提示编译器对函数进行内联。</p>
<p>内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。</p>
<p>没有调用其他函数，只会被调用的函数，我们一般称之为<strong>叶子函数（或叶子过程）</strong></p>
<h2 id="elf和静态链接">ELF和静态链接</h2>
<blockquote>
<p><strong>C 语言代码 - 汇编代码 - 机器码</strong></p>
<p>这个描述把过程大大简化了。</p>
<p>通过 objdump 命令查看它们的汇编代码，发现两个程序的地址都是从 0 开始的，如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？</p>
</blockquote>
<pre><code class="language-c">// add_lib.c
int add(int a, int b)
{
    return a+b;
}
</code></pre>
<pre><code class="language-c">// link_example.c
#include &lt;stdio.h&gt;
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf(&quot;c = %d\n&quot;, c);
}
</code></pre>
<pre><code class="language-shell">$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
</code></pre>
<p>add_lib.o 以及 link_example.o 并不是一个<strong>可执行文件</strong>（Executable Program），而是<strong>目标文件</strong>（Object File）。</p>
<p>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</p>
<pre><code class="language-shell">$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
</code></pre>
<p>“<strong>C 语言代码 - 汇编代码 - 机器码</strong>” 这个过程，在我们的计算机上进行的时候是由两部分组成的。</p>
<p>第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p>
<p>第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615482190792.jpg" style="zoom: 25%;" /></p>
<h3 id="elf-格式和链接">ELF 格式和链接</h3>
<p>可执行代码 通过objdump命令dump 出来的内容，不仅有编译成的汇编指令，还保留了很多别的数据。因为在 Linux 下，可执行文件和目标文件所使用的都是一种叫<strong>ELF</strong>（Execuatable and Linkable File Format）的文件格式，中文名字叫<strong>可执行与可链接文件格式</strong>。</p>
<p>ELF文件有三类:可重定向文件、可执行文件、共享目标文件。代码经过预处理、编译、汇编后形成可重定向文件，可重定向文件经过链接后生成可执行文件。</p>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等<br>
<img src="https://Joshua-Chang.github.io/post-images/1615482163121.jpg" alt="" loading="lazy"><br>
除了这些基本属性之外，大部分程序还有这么一些 Section：</p>
<ol>
<li>首先是.text Section，也叫作<strong>代码段</strong>或者指令段（Code Section），用来保存程序的代码和指令；</li>
<li>接着是.data Section，也叫作<strong>数据段</strong>（Data Section），用来保存程序里面设置好的初始化数据信息；</li>
<li>然后就是.rel.text Secion，叫作<strong>重定位表</strong>（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</li>
<li>最后是.symtab Section，叫作<strong>符号表</strong>（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</li>
</ol>
<h3 id="链接过程">链接过程</h3>
<img src="https://Joshua-Chang.github.io/post-images/1615482146761.jpg" style="zoom:50%;" />
<blockquote>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。因此可执行文件里面的函数调用的地址都是正确的。</p>
</blockquote>
<h3 id="动态链接">动态链接</h3>
<p>在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的<strong>共享库</strong>（Shared Libraries）</p>
<blockquote>
<p>Windows 下，.dll 文件，Dynamic-Link Libary（DLL，动态链接库）。</p>
<p>Linux 下，这些共享库文件就是.so 文件，Shared Object（一般我们也称之为动态链接库）。</p>
<p>“动态链接”、“共享”</p>
</blockquote>
<p>在程序运行的时候共享代码，这些机器码必须是“<strong>地址无关</strong>”的。编译出来的共享库文件的指令代码，是地址无关码（Position-Independent Code）。动态代码库内部变量和函数调用要使用<strong>相对地址</strong>（Relative Address）<br>
<img src="https://Joshua-Chang.github.io/post-images/1615535954056.jpg" alt="" loading="lazy"><br>
虽然共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。</p>
<h4 id="plt-got">PLT GOT</h4>
<pre><code class="language-c">// lib.c
#include &lt;stdio.h&gt;
void show_me_the_money(int money)
{
    printf(&quot;Show me USD %d from lib.c \n&quot;, money);
}
// show_me_poor.c
#include &quot;lib.h&quot;
int main()
{
    int money = 5;
    show_me_the_money(money);
}
</code></pre>
<pre><code class="language-shell">$ gcc lib.c -fPIC -shared -o lib.so
$ gcc -o show_me_poor show_me_poor.c ./lib.so
</code></pre>
<pre><code class="language-shell">……
0000000000400540 &lt;show_me_the_money@plt-0x10&gt;:
  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;//全局偏移表GOT
  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]
 
0000000000400550 &lt;show_me_the_money@plt&gt;:
  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;
  400556:       68 00 00 00 00          push   0x0
  40055b:       e9 e0 ff ff ff          jmp    400540 &lt;_init+0x28&gt;
……
0000000000400676 &lt;main&gt;:
....
  40068a:       e8 c1 fe ff ff          call   400550 &lt;show_me_the_money@plt&gt;
....//从PLT（程序链接表Procedure Link Table）里找要调用的函数,地址 400550 
……
</code></pre>
<p>在动态链接对应的共享库时，在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。</strong><br>
<img src="https://Joshua-Chang.github.io/post-images/1615535922650.jpg" alt="" loading="lazy"><br>
不同的进程，调用同样的动态库，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。</p>
<h3 id="延伸">延伸</h3>
<p>Windows 的可执行文件格式是一种叫作<strong>PE</strong>（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式，Linux 的Wine/ 微软的WSL，也就是 Windows Subsystem for Linux可以兼容</p>
<h2 id="程序装载">程序装载</h2>
<blockquote>
<p>在运行这些可执行文件的时候，我们其实是通过一个装载器，解析 ELF 或者 PE 格式的可执行文件。装载器会把对应的指令和数据加载到内存里面来，实际上装载器需要满足两个要求。</p>
<p><strong>第一，可执行程序加载后占用的内存空间应该是连续的</strong>。PC程序计数器是顺序地一条一条指令执行下去</p>
<p>**第二，我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。**因为我们现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</p>
</blockquote>
<h3 id="虚拟内存">虚拟内存</h3>
<p>在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。</p>
<p>指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，叫<strong>物理内存地址</strong>（Physical Memory Address）<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484615617.png" alt="" loading="lazy"></p>
<h3 id="内存分段">内存分段</h3>
<p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）**。**这里的段，就是指系统分配出来的那个连续的内存空间。</p>
<p>缺点第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484604209.png" alt="" loading="lazy"><br>
解决的办法叫<strong>内存交换</strong>（Memory Swapping），即把不足够连续的程序占用的内存写到硬盘上，再从硬盘上读回来到内存里面，不过读回来的时候，我们不再把它加载到原来的位置，而是放在连续的位置。</p>
<h3 id="内存分页">内存分页</h3>
<p>硬盘的访问速度要比内存慢很多，因此简单的内存交换并不高效。</p>
<p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。</p>
<p>对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（Page）。从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484579925.png" alt="" loading="lazy"><br>
即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来更加高效。</p>
<p>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。</p>
<blockquote>
<p>在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。可以运行那些远大于我们实际物理内存的程序</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理01计算机的基本组成]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/">
        </link>
        <updated>2021-03-11T06:46:55.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615446914479.jpg" alt="" loading="lazy"></figure>
<h1 id="冯诺依曼体系结构">冯·诺依曼体系结构</h1>
<p>也叫<strong>存储程序计算机</strong> : 即“<strong>可编程</strong>” 、“<strong>可存储</strong>”计算机</p>
<p><strong>First Draft</strong>里面说了一台计算机应该有哪些部分组成。</p>
<p>首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。</p>
<p>所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。</p>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615448091025.jpg" alt="" loading="lazy"></figure>
<h1 id="计算机性能">计算机性能</h1>
<h2 id="什么是性能时间的倒数">什么是性能：时间的倒数</h2>
<p>第一个是<strong>响应时间</strong>（Response time）或者叫执行时间（Execution time）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”</p>
<p>第二个是<strong>吞吐率</strong>（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。</p>
<p>我们一般把性能，定义成响应时间的倒数，也就是：</p>
<p>性能 = 1/ 响应时间</p>
<h2 id="计算机的计时单位cpu-时钟">计算机的计时单位：CPU 时钟</h2>
<p><strong>首先，自然时间不“准”</strong></p>
<figure data-type="image" tabindex="3"><img src="https://Joshua-Chang.github.io/post-images/1615451589290.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>Wall Clock Time 或者 Elapsed Time，我们自然统计时间，就是在运行程序期间，挂在墙上的钟走掉的时间。</p>
<p>P2/P3，CPU 在各个程序之间进行切换、从网络、硬盘去读取数据的时间</p>
<p><strong>程序实际花费的 CPU 执行时间（CPU Time），就是 user time （在用户态运行指令的时间）加上 sys （在操作系统内核里运行指令的时间）time</strong>。</p>
</blockquote>
<p><strong>其次， CPU 执行时间也受到影响</strong>。 CPU 可能满载/降频运行，还会受到主板、内存这些其他相关硬件的影响。</p>
<p>**结果，**程序的 CPU 执行时间 =CPU 时钟周期数（CPU Cycles）×时钟周期时间 （Clock Cycle）</p>
<blockquote>
<p>在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。</p>
<p>在2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。超频，就相当于把 CPU 内部的钟给调快了</p>
</blockquote>
<p>CPU 时钟周期数（CPU Cycles）=指令数×<strong>每条指令的平均时钟周期数</strong>（Cycles Per Instruction，简称 CPI）</p>
<p><strong>程序的 CPU 执行时间 = 指令数×CPI×Clock Cycle Time</strong>  性能提升从这三方面</p>
<h1 id="计算机功耗">计算机功耗</h1>
<h2 id="功耗">功耗</h2>
<blockquote>
<p>CPU，一般都被叫作<strong>超大规模集成电路</strong>（Very-Large-Scale Integration，VLSI）。这些电路，实际上都是一个个晶体管组合而成的。CPU 在计算，其实就是让晶体管里面的“开关”不断地去“打开”和“关闭”，来组合完成各种运算和功能。</p>
</blockquote>
<p>想要计算得快：都会增加功耗，带来耗电和散热的问题。</p>
<ol>
<li><strong>增加密度</strong>（在 CPU 里，同样的面积里面，多放一些晶体管）；</li>
<li><strong>提升主频</strong>（让晶体管“打开”和“关闭”得更快一点）。</li>
</ol>
<p>在 CPU 里面，能够放下的晶体管数量和晶体管的“开关”频率也都是有限的。一个 CPU 的功率，可以用这样一个公式来表示：</p>
<p>功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量</p>
<p>要提升性能，同样的面积下，我们想要增加晶体管数量，就要把晶体管造得小一点。这个就是提升“制程”。</p>
<p>功耗和电压的平方是成正比的，</p>
<h2 id="并行优化">并行优化</h2>
<p>通过多核提升“吞吐率”而不是“响应时间”</p>
<p><strong>阿姆达尔定律</strong></p>
<p>优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间</p>
<h2 id="其他优化">其他优化</h2>
<ol>
<li><strong>加速大概率事件</strong>。cpu-&gt;gpu-&gt;tpu深度学习</li>
<li><strong>通过流水线提高性能</strong>。</li>
<li><strong>通过预测提高性能</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetPack Compose 01]]></title>
        <id>https://Joshua-Chang.github.io/post/jetpack-compose-01/</id>
        <link href="https://Joshua-Chang.github.io/post/jetpack-compose-01/">
        </link>
        <updated>2021-02-28T08:27:34.000Z</updated>
        <content type="html"><![CDATA[<p>@Composable/<em>标记组合函数，可提供其他函数使用</em>/</p>
<pre><code class="language-java">@Composable
fun MyApp(content: @Composable () -&gt; Unit) {/*也可以 组合函数为参数*/
MyTheme{
        Surface(color = Color.Yellow) {
            content()
        }
    }
}
</code></pre>
<p>@Preview/<em>只能用与无参函数</em>/</p>
<h2 id="foundation包">foundation包</h2>
<pre><code class="language-java">@Composable
fun NewsStory() {
    MaterialTheme/*遵循 MaterialTheme板式*/ {
        val typography = MaterialTheme.typography/*版式即TextStyle*/
        //val image= ImageBitmap.imageResource(R.drawable.header)/*弃用*/
        val image2 = painterResource(R.drawable.header)/*BitmapPainter or VectorPainter*/
        Column(modifier = Modifier.padding(16.dp)) {
            val modifier = Modifier
                /*即preferredHeight期望高度，可能改变。不变用requiredHeight，范围用heightIn*/
                .height(180.dp)
                .fillMaxWidth()/*可设置百分比，默认1。具体用width，或size同时设置*/
                .clip(RoundedCornerShape(4.dp))/*Material Design包*/
            Image(
                painter = image2,
                contentDescription = &quot;image&quot;,
                modifier = modifier,/*ScaleType*/
                contentScale = ContentScale.Crop
            )
            Spacer(modifier = Modifier.height(16.dp))/*间隔*/
            Text(
                text = &quot;A day wandering through the sandhill &quot; +
                        &quot;in Shark Fin Cove, and a few of the &quot; +
                        &quot;sights I saw&quot;,
                style = typography.h6/*定义好的TextStyle*/,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            Text(text = &quot;Davenport,California&quot;,style = typography.body2)
            Text(text = &quot;December 2018&quot;,style = typography.body2)
        }
    }
}
</code></pre>
<h2 id="重组">重组</h2>
<p>重组是指在输入更改时，再次调用可组合函数的过程。</p>
<ul>
<li>在命令式界面模型中，如需更改某个微件，您可以在该微件上调用 setter 以更改其内部状态。</li>
<li>在声明式Compose 中，您可以使用新数据再次调用可组合函数。</li>
</ul>
<p>这样做会导致函数进行重组 -- 系统会根据需要，使用新数据重新绘制函数发出的微件。不依赖于该数据的其他函数跳过，不会进行重组。</p>
<p>在 Compose 中编程时，有许多事项需要注意：</p>
<ul>
<li>
<p>可组合函数可以按任何顺序执行、可以并行执行。且重组会跳过尽可能多的可组合函数和 lambda。</p>
<p>因此每个可重组函数应保持独立，且不应有附带效应。</p>
</li>
<li>
<p>重组是乐观的操作，可能会被取消。</p>
</li>
<li>
<p>可组合函数可能会像动画的每一帧一样非常频繁地运行。</p>
</li>
</ul>
<pre><code class="language-java">@Composable
@Deprecated(&quot;Example with bug&quot;)
fun ListWithBug(myList: List&lt;String&gt;) {
    var items = 0
    Row(horizontalArrangement = Arrangement.SpaceBetween) {
        Column {
            for (item in myList) {
                Text(&quot;Item: $item&quot;)
                items++ // Avoid! Side-effect of the column recomposing.
            }
        }
        Text(&quot;Count: $items&quot;)
    }
}
</code></pre>
<pre><code class="language-java">/**
 * Display a list of names the user can click with a header
 */
@Composable
fun NamePicker(
    header: String,
    names: List&lt;String&gt;,
    onNameClicked: (String) -&gt; Unit
) {
    Column {
        // this will recompose when [header] changes, but not when [names] changes
        Text(header, style = MaterialTheme.typography.h5)
        Divider()

        // LazyColumnFor is the Compose version of a RecyclerView.
        // The lambda passed is similar to a RecyclerView.ViewHolder.
        LazyColumnFor(names) { name -&gt;
            // When an item's [name] updates, the adapter for that item
            // will recompose. This will not recompose when [header] changes
            NamePickerItem(name, onNameClicked)
        }
    }
}

/**
 * Display a single name the user can click.
 */
@Composable
private fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) {
    Text(name, Modifier.clickable(onClick = { onClicked(name) }))
}
</code></pre>
<h2 id="state">State</h2>
<pre><code class="language-java">fun MyScreenContent() {
    val countState = remember {
        mutableStateOf(0)
    }
    Column {
        Counter()
        Counter2(count = countState.value,updateCount = {newCount-&gt;
            countState.value=newCount
        })
    }
}

@Composable
fun Counter() {
    val count = remember {
        mutableStateOf(0)
    }
    Button(onClick = { count.value++ }) {
        Text(text = &quot;${count.value} times&quot;)
    }
}
@Composable
fun Counter2(count:Int,updateCount:(Int)-&gt;Unit) {
    Button(onClick = { updateCount(count+1) }) {
        Text(text = &quot;$count times&quot;)
    }
}
</code></pre>
<h2 id="lazycolumn">LazyColumn</h2>
<pre><code class="language-java">@Composable
fun NameList(names: List&lt;String&gt;, modifier: Modifier = Modifier) {
    LazyColumn(modifier = modifier) {
        items(items = names) { name -&gt;
            Greeting(name = name)
            Divider(color = Color.Black)
        }
    }
}
Column(modifier = Modifier.fillMaxHeight()) {
    NameList(names, Modifier.weight(1f))
    Counter2(count = countState.value, updateCount = { newCount -&gt;
        countState.value = newCount
    })
}
</code></pre>
<pre><code class="language-java">@Composable
fun Greeting(name: String) {
    /*by委托：将set/get委托出去*/
    var isSelected by /*Boolean*/remember { mutableStateOf(false) }
    val backgroundColor by /*委托State&lt;Color&gt;*/animateColorAsState(if (isSelected) Color.Red else Color.Transparent)
    Text(text = &quot;hello $name&quot;,
        modifier = Modifier
            .padding(24.dp)
            .background(color = backgroundColor)
            .clickable(onClick = { isSelected = !isSelected })
    )
}
</code></pre>
]]></content>
    </entry>
</feed>