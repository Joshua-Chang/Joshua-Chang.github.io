<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Joshua-Chang.github.io</id>
    <title>Joshua-Chang`Blog</title>
    <updated>2021-03-12T17:56:20.738Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Joshua-Chang.github.io"/>
    <link rel="self" href="https://Joshua-Chang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Joshua-Chang.github.io/images/avatar.png</logo>
    <icon>https://Joshua-Chang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Joshua-Chang`Blog</rights>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理05处理器设计 下]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-05-chu-li-qi-she-ji-xia/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-05-chu-li-qi-she-ji-xia/">
        </link>
        <updated>2021-03-12T17:53:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615571610811.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理04处理器设计 上]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-04-chu-li-qi-she-ji-shang/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-04-chu-li-qi-she-ji-shang/">
        </link>
        <updated>2021-03-12T17:52:40.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615571610811.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理03指令和运算 下]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan-xia/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan-xia/">
        </link>
        <updated>2021-03-12T08:00:23.000Z</updated>
        <summary type="html"><![CDATA[<p>程序 = 算法 + 数据结构</p>
<p>算法：各种计算机指令</p>
<p>数据结构：二进制数据</p>
]]></summary>
        <content type="html"><![CDATA[<p>程序 = 算法 + 数据结构</p>
<p>算法：各种计算机指令</p>
<p>数据结构：二进制数据</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615480260058.png" alt="" loading="lazy"></figure>
<h2 id="二进制">二进制</h2>
<p>二进制转十进制：从 0 开始，从右到左的第 N 位✖️2 的 N 次方，然后相加。</p>
<p>十进制转二进制：<strong>短除法</strong>，递归除以 2 的余数，从右往左填入，直到商0。</p>
<p>负数：一个 4 位的二进制数，补码最左侧的一位，当成正负号，0 为正数，1 为负数。这一位并非单独的符号位。在计算整个二进制值的时候，在左侧最高位前面加个正负号。 十进制−5，用4 位的二进制补码数值 1011。-2<sup>3+2</sup>1+2^0。首位前加负号：-8+2+1=-5。</p>
<h3 id="字符串">字符串</h3>
<p>最早计算机只需要使用英文字符，加上数字和一些特殊符号，然后用 8 位的二进制就能表示，即<strong>ASCII 码</strong>（American Standard Code for Information Interchange，美国信息交换标准代码）。ASCII 码就好比一个字典，用 8 位二进制中的 128 个不同的数，映射成 128 个不同的字符。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548790038.png" style="zoom: 33%;" /></p>
<blockquote>
<p>小写字母 a 在 ASCII 里面，就是第 97 个，8位二进制的 0110 0001，十六进制61</p>
<p>大写字母 A 在 ASCII 里面，就是第 65 个，8位二进制的 0100 0001，十六进制41</p>
<p>单个数字不再用整数表示法，反而用8位二进制，字符串数字9，第57个，用8位二进制0011 1001 ，十六进制39</p>
<p>字符串 数字15 不用 0000 1111 这 8 位来表示，而用两个 8 位来表示，即用两个字符 1 和 5 连续在一起，也就是 0011 0001 和 0011 0101。</p>
</blockquote>
<p>因此在存储数据的时候，采用二进制序列化这样的方式，而不是 CSV 或者 JSON，这样的文本格式。<strong>不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。</strong></p>
<p>随着越来越多的不同国家的人都用上了计算机，ASCII 码128 个字符不够用。于是出现了不同的的<strong>字符集</strong>（Charset）和<strong>字符编码</strong>（Character Encoding）。</p>
<p>其中Unicode字符集，包含了 150 种语言的 14 万个不同的字符。</p>
<p>字符编码则是对于字符集里的字符，用二进制表示出来的一个字典。Unicode，可以用 UTF-8、UTF-16，UTF-32、GB2312等来进行编码，存储成二进制。解码和展示时使用不同的编码方式，就会出现乱码。</p>
<p><strong>ASCII 码</strong>是对有128个字符的“小字符集”的编码。编码的目的就是把文字二进制存储。</p>
<h2 id="理解电路">理解电路</h2>
<p>我们通过电路的“开”和“关”，来表示“1”和“0”，晶体管在不同的情况下，表现为导电的“1”和绝缘的“0”的状态。</p>
<p>一方面，我们可以通过继电器或者中继（Relay），进行长距离的信号传输。另一方面，我们也可以通过设置不同的线路和开关状态，实现更多不同的信号表示和处理方式，这些线路的连接方式就是我们在数字电路中所说的门电路。</p>
<blockquote>
<p>“与（AND）”：提供串联的两个开关，只有两个开关都打开，电路才接通</p>
<p>“或（OR）”：两条线路上各有一个开关，任何一个开关打开了，电路都接通</p>
<p>“非（NOT）”：数字电路中使用<strong>反向器</strong>（Inverter）</p>
</blockquote>
<p><strong>门电路</strong>是我们创建 CPU 和内存的基本逻辑单元。各种对于计算机二进制的“0”和“1”的门电路操作，叫作组合逻辑电路。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548823929.jpg" alt="" loading="lazy"></p>
<h2 id="加法器">加法器</h2>
<p><strong>bit</strong> （缩写b）位。是计算机存储数据的最小单位，只有0和1两种值。</p>
<p><strong>byte</strong>（缩写B）字节。是8个bit组成了信息的最小单位，也就是字节。来源于<strong>ASCII码</strong>有128个字符，需用8位表示。</p>
<p>二进制，从右往左数，第一列是个位，第二列是“二位”，对应的再往左，就应该分别是四位、八位。</p>
<h3 id="异或门">异或门</h3>
<p>四种个位数相加</p>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615548862709.jpg" alt="" loading="lazy"></figure>
<p>输入：4 种组合00、01、10、11。</p>
<p>输出：00/11 情况下输出0，10/01 情况下输出1</p>
<p>这种输入输出的对应关系即“异或门（XOR / ^）”。虽然在逻辑运算里面没有出现的形式，但作为一个基本电路。<strong>异或门就是一个最简单的整数加法所需要的基本门电路</strong>。</p>
<h3 id="半加器">半加器</h3>
<p>输入的是 11 的情况下，还需向更左侧进位。对应一个与门：即当且仅当加数和被加数都是 1 的时候，才进位 1。</p>
<p>通过一个<strong>异或门</strong>计算出个位，通过一个<strong>与门</strong>计算出是否进位，就通过电路算出了一个一位数的加法。<strong>我们把两个门电路打包，给它取一个名字，就叫作半加器</strong>（Half Adder）。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548907425.jpg" alt="" loading="lazy"></p>
<h3 id="全加器">全加器</h3>
<p>半加器不能计算“二位”，因为“二位”是加数、被加数、进位信号 三个数相加。<strong>我们用两个半加器和一个或门，就能组合成一个全加器</strong>。（此处的二位与非个位的其他位原理相同）</p>
<p>第一个半加器，个位的加法，得到是否进位 X 和对应的二个数加和后的结果 Y；</p>
<p>然后把结果 Y和右侧个位数相加后的进位信息 ，连接到第二个半加器上；</p>
<p>就产生一个是否进位的信号 V 和对应的加和后的结果 W 即二位的结果；</p>
<figure data-type="image" tabindex="3"><img src="https://Joshua-Chang.github.io/post-images/1615548945005.jpg" alt="" loading="lazy"></figure>
<p>最后把两个半加器的进位信息，输入或门连接起来。即两次加法中，任何一个需要进位，都向左侧进位。</p>
<p>（即使三个 bit 相加，即使 3 个 bit 都是 1，也最多会进一位）</p>
<p>有了全加器，对两个 8 bit 数相加变得容易，只要把 8 个全加器串联起来即可。个位的全加器的进位信号作为二位全加器的输入信号，二位全加器的进位信号再作为四位的全加器的进位信号。同理可扩展到 16 位、32 位，乃至 64 位。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615548959815.jpg" alt="" loading="lazy"></p>
<p>对于这个8位串联全加器：</p>
<p>在最右侧个位，我们只需要用一个半加器，或者让全加器的进位输入始终是 0。</p>
<p>在最左侧的一位输出的进位信号，并不表示再进一位，而表示加法是否溢出。</p>
<p><strong>分层</strong><br>
<img src="https://Joshua-Chang.github.io/post-images/1615548968172.jpg" style="zoom: 25%;" /></p>
<p>在上面的一层，我们只需要考虑怎么用下一层的组件搭建出自己的功能，而不需要下沉到更低层的其他组件。就像你之前并没有深入学习过计算机组成原理，一样可以直接通过高级语言撰写代码，实现功能。</p>
<p>在硬件层面，通过门电路、半加器、全加器一层层搭出了加法器这样的功能组件。这些用来做算术逻辑计算的组件叫作 ALU，也就是算术逻辑单元。</p>
<p>当进一步打造强大的 CPU 时，我们不再关注最细颗粒的门电路，只需要把门电路组合而成的 ALU，当成一个能够完成基础计算的黑盒子就可以了。</p>
<h2 id="乘法器">乘法器</h2>
<p>实际的乘法，就退化成了位移和加法。</p>
<p>13×9 被乘数 13 表示成二进制是 1101，乘数 9 在二进制里面是 1001。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615563769473.jpg" alt="" loading="lazy"></p>
<p>实际上，像 13×9 这样两个四位数的乘法，不需要把四次单位乘法的结果，用四组独立的开关单独都记录下来，然后再把这四个数加起来。</p>
<p>先拿乘数最右侧的个位乘以被乘数，然后把结果写入用来存放计算结果的开关里面，然后，把被乘数左移一位，把乘数右移一位，仍然用乘数去乘以被乘数，然后把结果加到刚才的结果上。反复重复这一步骤，直到不能再左移和右移位置。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615563804280.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>这里的控制测试，其实就是通过一个时钟信号，来控制左移、右移以及重新计算乘法和加法的时机。</p>
</blockquote>
<p>把乘法展开，变成了“<strong>加法 + 位移</strong>”来实现。 4 位数要进行 4 组“位移 + 加法”的操作。而且这 4 组操作还不能同时进行。因为<strong>下一组的加法要依赖上一组的加法后的计算结果，下一组的位移也要依赖上一组的位移的结果。这样，整个算法是“顺序”的，每一组加法或者位移的运算都需要一定的时间</strong>。</p>
<p>一个顺序乘法器硬件进行计算的时间复杂度是 O(N)。这里的 N，就是乘法的数里面的<strong>位数</strong>。</p>
<h3 id="电路并行">电路并行</h3>
<p>目前的乘法实现就像是单败淘汰赛</p>
<img src="https://Joshua-Chang.github.io/post-images/1615563936931.jpg" style="zoom:25%;" />
<p>我们 CPU 的硬件上，用更多的晶体管开关，来放下中间计算结果。把 O(https://Joshua-Chang.github.io/post-images/1615563995243.jpg&quot; style=&quot;zoom:25%;&quot; /&gt;</p>
<p>加法器中每一个全加器，都要等待上一个全加器，这个等待的时间叫作<strong>门延迟</strong>（Gate Delay）。每通过一个门电路，计作1“T”。全加器就已经有了 3T 的延迟（进位需要经过 3 个门电路），而 4 位整数，最高位的计算需要等待前面三个全加器的进位结果，即等 9T 延迟。</p>
<p>除了门延迟外，还有<strong>时钟频率</strong>，在上面的顺序乘法计算里面，如果我们想要用更少的电路，计算的中间结果需要保存在寄存器里面，然后等待下一个时钟周期的到来，控制测试信号才能进行下一次移位和加法。</p>
<p>因为电路是天然并行的，一个输入信号，可以同时传播到所有接通的线路当中。下图展示了加法器。如果完全展开电路，高位的进位和计算结果，可以和低位的计算结果同时获得。</p>
<blockquote>
<img src="https://Joshua-Chang.github.io/post-images/1615564005050.jpg" style="zoom:25%;" />
C4 是前 4 位的计算结果是否进位的门电路表示。因此一个 4 位整数最高位是否进位，展开门电路图，你会发现，我们只需要 3T 的延迟就可以拿到是否进位的计算结果。
</blockquote>
<p>电路天然的并行性。电路只要接通，输入的信号自动传播到了所有接通的线路里面，这其实也是硬件和软件最大的不同。</p>
<p>无论是把对应的门电路逻辑进行完全展开以减少门延迟，还是通过并行计算多个位的乘法，都把一个计算的电路变复杂了。而电路变复杂了，也就意味着晶体管变多了。通过更多的晶体管，就可以拿到更低的门延迟，以及用更少的时钟周期完成一个计算指令。</p>
<p>是用更少更简单的电路，但是需要更长的门延迟和时钟周期；还是用更复杂的电路，但是更短的门延迟和时钟周期来计算一个复杂的指令，就是RISC 和 CISC 的区别。</p>
<h2 id="浮点数和定点数">浮点数和定点数</h2>
<p>计算机通常用 16或32 个比特（bit）4/8byte来表示一个数，只能表示 2 的 32 次方个不同的数，差不多是 40 亿个。</p>
<p>实数集合是无限多的，让这 40 亿个数映射到实数集合上的哪些数呢？</p>
<h3 id="定点数的表示">定点数的表示</h3>
<p>每4bit来表示 0～9 的整数，32bit即可表示8个这样的正数，把最右边的 2 个 0～9 的整数，当成小数部分；把左边 6 个 0～9 的整数，当成整数部分。这样用 32 个bit，表示从 0 到 999999.99 共 1 亿个实数这种直观的表示法叫<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E7%A2%BC%E5%8D%81%E9%80%B2%E6%95%B8"><strong>BCD 编码</strong></a>（Binary-Coded Decimal），用于超市、银行这样需要用小数记录金额。</p>
<p><strong>第一，这样的表示方式有点“浪费”</strong>：本来可以表示2^32约40亿个数，结果才表示了1亿个。</p>
<p><strong>第二，这样的表示方式没办法同时表示很大的数字和很小的数字。</strong></p>
<h3 id="浮点数的表示">浮点数的表示</h3>
<p><strong>浮点数</strong>（Floating Point），用科学计数法来表示实数。</p>
<p>因为这个数对应的小数点的位置是“浮动”的，它才被称为浮点数。随着指数位 e 的值的不同，小数点的位置也在变动。而BCD 编码的实数，小数点固定在某一位的方式称为<strong>定点数</strong>。</p>
<p><strong>IEEE</strong>标准定义了，用32 比特表示单精度的浮点数即 float 或者 float32 类型，用 64 比特表示双精度的浮点数即double 或者 float64 类型。</p>
<p>浮点数的组成分成三部分</p>
<p>单精度的 32 个比特如下，双精度则每部分bit增加一倍</p>
<figure data-type="image" tabindex="4"><img src="https://Joshua-Chang.github.io/post-images/1615571233192.jpg" alt="" loading="lazy"></figure>
<ol>
<li>第一部分是一个<strong>符号位</strong> S，用来表示是正数还是负数。浮点数都是有符号的。负数1正数0</li>
<li>接下来的8 bit组成<strong>指数位</strong> e。8bit能够表示的整数是 0～255，用 1～254 映射到 -126～127 这 254 个有正有负的数上。e作为指数可正可负，可以同时表示很大或很小的数。0和255单独表示。</li>
<li>最后是一个 23 bit组成的<strong>有效数位</strong>f</li>
</ol>
<p>最终浮点数表示为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>s</mi></msup><mo>∗</mo><mn>1.</mn><mi>f</mi><mo>∗</mo><msup><mn>2</mn><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">(-1)^s*1.f*2^e
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>在e=0且f=0时表示浮点数的0。当e=255且f=0时，s为0表示无穷大，s为1表示无穷小。</p>
<p>浮点数无论是表示还是计算其实都是近似计算，比如0.3、0.9难以用指数绝对表达。</p>
<h3 id="浮点数的二进制转化">浮点数的二进制转化</h3>
<p>浮点数二进制：<strong>符号位 s+ 指数位 e+ 有效位数 f</strong></p>
<h4 id="二进制小数转十进制小数">二进制小数转十进制小数</h4>
<p>0.1001</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>1</mn><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>2</mn><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>3</mn><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi mathvariant="normal">−</mi></msup><mn>4</mn><mo>=</mo><mn>0.5625</mn></mrow><annotation encoding="application/x-tex">1×2^−1+0×2^−2+0×2^−3+1×2^−4=0.5625
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.904661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.821331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">−</span></span></span></span></span></span></span></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">6</span><span class="mord">2</span><span class="mord">5</span></span></span></span></span></p>
<h4 id="十进制小数转二进制小数">十进制小数转二进制小数</h4>
<p>和整数的二进制表示采用“除以 2，然后看余数”的方式相反。</p>
<p>乘以 2，看是否超过 1。如果超过 1，我们就记下 1，并把结果减去 1；减去1的结果继续乘以2，进一步循环操作。</p>
<blockquote>
<p><img src="https://Joshua-Chang.github.io/post-images/1615571288146.jpg" alt="" loading="lazy"><br>
以0.1为例，0.000110011。这里的“0011”会无限循环下去。</p>
</blockquote>
<h4 id="例子">例子</h4>
<p><strong>十进制9.1的的二进制表示</strong></p>
<p>1001.000110011…</p>
<p>用科学记数法1.001000110011…×2^3</p>
<p>符号位 s = 0,有效位 f=00100011001100110011001共23位，指数 e=3</p>
<blockquote>
<p>因为指数位有正又有负，指数位在 127 之前代表负数，之后代表正数，那 3 其实对应的是加上 127 的偏移量 130，转化成二进制就是 10000010。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://Joshua-Chang.github.io/post-images/1615571313898.jpg" alt="" loading="lazy"></figure>
<p>把“s+e+f”拼在一起，浮点数 9.1 的二进制表示为</p>
<p>01000<strong>0010</strong> 0010 <strong>0011001100110011</strong> <strong>001</strong></p>
<p>换算成十进制是 9.09999942779541015625</p>
<h3 id="浮点数的加法和精度损失">浮点数的加法和精度损失</h3>
<p>十进制的数值，转化成 IEEE-754 标准下的浮点数在做加法。</p>
<p>浮点数的加法是<strong>先对齐、再计算</strong>。</p>
<p>两个浮点数的指数位可能是不一样的，所以我们要把两个的指数位，变成一样的，然后只去计算有效位的加法。</p>
<h4 id="例子-2">例子</h4>
<p>0.5，表示成浮点数，指数位是 -1，有效位是 00…（后面全是 0，记住 f 前默认有一个 1）</p>
<p>0.125 表示成浮点数，对应的指数位是 -3，有效位也还是 00…（后面全是 0，记住 f 前默认有一个 1）</p>
<ol>
<li>指数位对齐：把指数位都统一成两个其中较大的 -1，0.125 的有效位 1.00…也要对应右移两位变成0.01。</li>
<li>然后计算两者相加的有效位 1.0+0.01=1.01</li>
<li>得到结果浮点数，符号位是0，指数位是 -1，有效位是1.01</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://Joshua-Chang.github.io/post-images/1615571340870.jpg" alt="" loading="lazy"></figure>
<h4 id="丢失精度">丢失精度</h4>
<p>浮点数的加法过程中，需要先对齐，其中指数位较小的数，需要在有效位进行右移，在右移的过程中，最右侧的有效位就被丢弃掉了。导致对应的指数位较小的数，在加法发生之前，就<strong>丢失精度</strong>。</p>
<p>两个相加数的指数位差的越大，位移的位数越大，可能丢失的精度也就越大。（丢失的有效位都是 0例外）</p>
<p>在32位浮点数中，有效位长度一共只有 23 位，指数位较小的数右移 24 位之后，所有的有效位就都丢失了。</p>
<p>因此32位浮点数实际计算中，只要两个数差出 2^24，那这两个数相加之后，结果完全不会变化。</p>
<h4 id="kahan-summation-算法">Kahan Summation 算法</h4>
<p>在一些“积少成多”的计算过程中，比如在机器学习中，我们经常要计算海量样本计算出来的梯度或者 loss，于是会出现几亿个浮点数的相加。每个浮点数可能都差不多大，但是随着累积值的越来越大，就会出现“大数吃小数”的情况。</p>
<p>Kahan累加算法：在每次的计算过程中，都用一次减法，把当前加法计算中损失的精度记录下来。然后在后面的循环中，把这个精度损失放在要加的小数上，再做一次运算。</p>
<pre><code class="language-java">public class KahanSummation {
  public static void main(String[] args) {
    float sum = 0.0f;
    float c = 0.0f;
    for (int i = 0; i &lt; 20000000; i++) {
    	float x = 1.0f;
    	float y = x - c;
    	float t = sum + y;
    	c = (t-sum)-y;
    	sum = t;    	
    }
    System.out.println(&quot;sum is &quot; + sum);   
  }	
}
</code></pre>
<p>一般情况下，在实践应用中，对于需要精确数值的，比如银行存款、电商交易，我们都会使用定点数或者整数类型。比如在 MySQL 里的 decimal(12,2)，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理02指令和运算 上]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/">
        </link>
        <updated>2021-03-11T09:41:24.000Z</updated>
        <summary type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
<!-- more -->
<p>不同的 CPU 能够听懂的语言不太一样，即计算机指令集Instruction Set<br>
<img src="https://Joshua-Chang.github.io/post-images/1615480260058.png" alt="" loading="lazy"></p>
<h2 id="指令和机器码">指令和机器码</h2>
<ol>
<li>
<p>把高级语言程序翻译成汇编语言（ASM，Assembly Language）程序，的过程叫编译（Compile）成汇编代码</p>
</li>
<li>
<p>再用汇编器（Assembler）翻译成机器码（Machine Code），CPU 能够真正认识的计算机指令<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460135310.png" alt="" loading="lazy"><br>
<img src="https://Joshua-Chang.github.io/post-images/1615460148801.jpg" alt="" loading="lazy"></p>
</li>
</ol>
<blockquote>
<p>e.g.<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460725402.jpg" alt="" loading="lazy"><br>
MIPS 的指令是一个 32 位的整数，高 6 位叫操作码（Opcode），分别是 R、I 和 J，代表这条指令具体的操作类别。rt、rt、rd均为寄存器地址。<br>
R 指令是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。</p>
<p>I 指令，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。</p>
<p>J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。</p>
<p><code>add $t0,$s2,$s1</code>为例 s1 17    s2 18      t0 8<br>
<img src="https://Joshua-Chang.github.io/post-images/1615461145867.jpg" alt="" loading="lazy"><br>
<img src="https://Joshua-Chang.github.io/post-images/1615461154758.png" alt="" loading="lazy"></p>
</blockquote>
<p>除了 C 这样的编译型的语言之外，Python 这样的解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java 这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译(JIT)成为机器码来最终执行。</p>
<h2 id="指令跳转">指令跳转</h2>
<blockquote>
<p>CPU 其实就是由一堆寄存器组成的。而寄存器是由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。</p>
<p>N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。</p>
</blockquote>
<h3 id="cpu-里面的寄存器">CPU 里面的寄存器：</h3>
<p>一个是<strong>PC 寄存器</strong>（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。它就是用来存放下一条需要执行的计算机指令的内存地址。</p>
<p>第二个是<strong>指令寄存器</strong>（Instruction Register），用来存放当前正在执行的指令。</p>
<p>第三个是<strong>条件码寄存器</strong>（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。<strong>零标志条件码</strong>（对应的条件码是 ZF，Zero Flag 不等为0）、<strong>进位标志</strong>（CF，Carry Flag A&gt;B 为0）、<strong>符号标志</strong>（SF，Sign Flag正数为0）以及<strong>溢出标志</strong>（OF，Overflow Flag）</p>
<p>其他用来存储数据和内存地址的寄存器：通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等，通用寄存器（既可以存放数据，又能存放地址）</p>
<p>一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令，读取到指令寄存器里面执行，然后顺序读取下一条指令。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472744523.jpg" alt="" loading="lazy"></p>
<h3 id="ifelse">if…else</h3>
<pre><code class="language-c">#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
}
</code></pre>
<pre><code class="language-shell">$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
</code></pre>
<p><strong>汇编代码</strong></p>
<p>r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令</p>
<p>cmp 指令比较了前后两个操作数的值： 操作对象1 - 操作对象2 但不保存结果，只是根据结果修改相应的标志位。</p>
<ol>
<li>DWORD PTR 代表操作的数据类型是 32 位的整数，[rbp-0x4] 则是一个寄存器的地址。</li>
<li>第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示</li>
</ol>
<p>cmp 指令的比较结果，会存入到<strong>条件码寄存器</strong>当中去，<strong>零标志条件码</strong>ZF 相等为1，不等为0</p>
<p>cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令</p>
<p>jne 指令： jump not equal 查看零标志位ZF不等于0，则跳转到4a（当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址）</p>
<p>CPU 再把 4a 地址里的指令加载到指令寄存器中来执行，mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。</p>
<p>mov 指令的第一个操作数 eax，代表累加寄存器，这条指令其实没有实际的作用，它的作用是一个占位符。</p>
<p>if 条件满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令，跳转的地址就是51。</p>
<p>main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。</p>
<pre><code class="language-shell"> if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0 //只比较，结果存入标识位
  3f:   75 09                   jne    4a &lt;main+0x4a&gt; //标识位ZF不等于0则执行
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 &lt;main+0x51&gt;
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615472764389.jpg" alt="" loading="lazy"></figure>
<h3 id="forwhile">for/while</h3>
<p>对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。</p>
<p>jle 跳转的地址，是在这条指令之前的地址 14。往前跳转使得，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472775030.jpg" alt="" loading="lazy"></p>
<p>除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。</p>
<h2 id="函数调用">函数调用</h2>
<blockquote>
<p>函数调用和 if…else 和 for/while 循环有点像。都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。</p>
<p>区别是，if…else 和 for/while 的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令。</p>
<p>而函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行 call 之后的指令。</p>
<p>把被调用函数的指令直接插入在调用处的方法不太好。那就把后面要跳回来执行的指令地址给记录下来。</p>
</blockquote>
<p>我们在内存里面开辟一段空间，用栈这个<strong>后进先出</strong>（LIFO，Last In First Out）的数据结构。</p>
<p>每次程序调用函数之前，都把函数调用完成后的返回地址、参数数据等开辟一块内存空间，即<strong>栈帧</strong>（Stack Frame）。<strong>压栈</strong>。如果函数执行完了，这就<strong>出栈</strong>。栈底的内存地址是在一开始就固定的，而一层层压栈之后，栈顶的内存地址是在逐渐变小。</p>
<p>指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。</p>
<p>call 的同时进行了一次 push把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。</p>
<pre><code class="language-c">// function_example.c
#include &lt;stdio.h&gt;
int static add(int a, int b)
{
    return a+b;
}
int main()
{
    int x = 5;
    int y = 10;
    int u = add(x, y);
}
</code></pre>
<pre><code class="language-shell">int static add(int a, int b)
{
   0:   55                      push   rbp //压栈register base pointer原栈帧指针
   1:   48 89 e5                mov    rbp,rsp //register stack pointer当前栈指针
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
}
  12:   5d                      pop    rbp //将当前的栈顶出栈
  13:   c3                      ret //出栈 到call调用时PC里的下一条地址  
0000000000000014 &lt;main&gt;:
int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);
  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 &lt;add&gt;//跳转后的程序地址 PC里的下一条地址等信息压栈
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    
</code></pre>
<h3 id="stack-overflow">stack overflow</h3>
<p>通过引入栈，函数调用只需要通过维持 rbp 和 rsp，这两个维护栈顶所在地址的寄存器，就能管理好不同函数之间的跳转。但函数调用层数太多，我们往栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误。（如：函数调用自己，并且不设任何终止条件）</p>
<p>除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来 stack overflow。</p>
<h3 id="函数内联inline">函数内联inline</h3>
<p>只要在 GCC 编译的时候，加上对应的一个让编译器自动优化的参数 -O，编译器就会在可行的情况下，进行这样的指令替换。或者在定义函数的地方，加上 inline 的关键字，来提示编译器对函数进行内联。</p>
<p>内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。</p>
<p>没有调用其他函数，只会被调用的函数，我们一般称之为<strong>叶子函数（或叶子过程）</strong></p>
<h2 id="elf和静态链接">ELF和静态链接</h2>
<blockquote>
<p><strong>C 语言代码 - 汇编代码 - 机器码</strong></p>
<p>这个描述把过程大大简化了。</p>
<p>通过 objdump 命令查看它们的汇编代码，发现两个程序的地址都是从 0 开始的，如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？</p>
</blockquote>
<pre><code class="language-c">// add_lib.c
int add(int a, int b)
{
    return a+b;
}
</code></pre>
<pre><code class="language-c">// link_example.c
#include &lt;stdio.h&gt;
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf(&quot;c = %d\n&quot;, c);
}
</code></pre>
<pre><code class="language-shell">$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
</code></pre>
<p>add_lib.o 以及 link_example.o 并不是一个<strong>可执行文件</strong>（Executable Program），而是<strong>目标文件</strong>（Object File）。</p>
<p>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</p>
<pre><code class="language-shell">$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
</code></pre>
<p>“<strong>C 语言代码 - 汇编代码 - 机器码</strong>” 这个过程，在我们的计算机上进行的时候是由两部分组成的。</p>
<p>第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p>
<p>第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615482190792.jpg" alt="" loading="lazy"></p>
<h3 id="elf-格式和链接">ELF 格式和链接</h3>
<p>可执行代码 通过objdump命令dump 出来的内容，不仅有编译成的汇编指令，还保留了很多别的数据。因为在 Linux 下，可执行文件和目标文件所使用的都是一种叫<strong>ELF</strong>（Execuatable and Linkable File Format）的文件格式，中文名字叫<strong>可执行与可链接文件格式</strong>。</p>
<p>ELF文件有三类:可重定向文件、可执行文件、共享目标文件。代码经过预处理、编译、汇编后形成可重定向文件，可重定向文件经过链接后生成可执行文件。</p>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等<br>
<img src="https://Joshua-Chang.github.io/post-images/1615482163121.jpg" alt="" loading="lazy"><br>
除了这些基本属性之外，大部分程序还有这么一些 Section：</p>
<ol>
<li>首先是.text Section，也叫作<strong>代码段</strong>或者指令段（Code Section），用来保存程序的代码和指令；</li>
<li>接着是.data Section，也叫作<strong>数据段</strong>（Data Section），用来保存程序里面设置好的初始化数据信息；</li>
<li>然后就是.rel.text Secion，叫作<strong>重定位表</strong>（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</li>
<li>最后是.symtab Section，叫作<strong>符号表</strong>（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</li>
</ol>
<h3 id="链接过程">链接过程</h3>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615482146761.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。因此可执行文件里面的函数调用的地址都是正确的。</p>
</blockquote>
<h3 id="动态链接">动态链接</h3>
<p>在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的<strong>共享库</strong>（Shared Libraries）</p>
<blockquote>
<p>Windows 下，.dll 文件，Dynamic-Link Libary（DLL，动态链接库）。</p>
<p>Linux 下，这些共享库文件就是.so 文件，Shared Object（一般我们也称之为动态链接库）。</p>
<p>“动态链接”、“共享”</p>
</blockquote>
<p>在程序运行的时候共享代码，这些机器码必须是“<strong>地址无关</strong>”的。编译出来的共享库文件的指令代码，是地址无关码（Position-Independent Code）。动态代码库内部变量和函数调用要使用<strong>相对地址</strong>（Relative Address）<br>
<img src="https://Joshua-Chang.github.io/post-images/1615535954056.jpg" alt="" loading="lazy"><br>
虽然共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。</p>
<h4 id="plt-got">PLT GOT</h4>
<pre><code class="language-c">// lib.c
#include &lt;stdio.h&gt;
void show_me_the_money(int money)
{
    printf(&quot;Show me USD %d from lib.c \n&quot;, money);
}
// show_me_poor.c
#include &quot;lib.h&quot;
int main()
{
    int money = 5;
    show_me_the_money(money);
}
</code></pre>
<pre><code class="language-shell">$ gcc lib.c -fPIC -shared -o lib.so
$ gcc -o show_me_poor show_me_poor.c ./lib.so
</code></pre>
<pre><code class="language-shell">……
0000000000400540 &lt;show_me_the_money@plt-0x10&gt;:
  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;//全局偏移表GOT
  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]
 
0000000000400550 &lt;show_me_the_money@plt&gt;:
  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;
  400556:       68 00 00 00 00          push   0x0
  40055b:       e9 e0 ff ff ff          jmp    400540 &lt;_init+0x28&gt;
……
0000000000400676 &lt;main&gt;:
....
  40068a:       e8 c1 fe ff ff          call   400550 &lt;show_me_the_money@plt&gt;
....//从PLT（程序链接表Procedure Link Table）里找要调用的函数,地址 400550 
……
</code></pre>
<p>在动态链接对应的共享库时，在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。</strong><br>
<img src="https://Joshua-Chang.github.io/post-images/1615535922650.jpg" alt="" loading="lazy"><br>
不同的进程，调用同样的动态库，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。</p>
<h3 id="延伸">延伸</h3>
<p>Windows 的可执行文件格式是一种叫作<strong>PE</strong>（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式，Linux 的Wine/ 微软的WSL，也就是 Windows Subsystem for Linux可以兼容</p>
<h2 id="程序装载">程序装载</h2>
<blockquote>
<p>在运行这些可执行文件的时候，我们其实是通过一个装载器，解析 ELF 或者 PE 格式的可执行文件。装载器会把对应的指令和数据加载到内存里面来，实际上装载器需要满足两个要求。</p>
<p><strong>第一，可执行程序加载后占用的内存空间应该是连续的</strong>。PC程序计数器是顺序地一条一条指令执行下去</p>
<p>**第二，我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。**因为我们现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</p>
</blockquote>
<h3 id="虚拟内存">虚拟内存</h3>
<p>在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。</p>
<p>指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，叫<strong>物理内存地址</strong>（Physical Memory Address）<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484615617.png" alt="" loading="lazy"></p>
<h3 id="内存分段">内存分段</h3>
<p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）**。**这里的段，就是指系统分配出来的那个连续的内存空间。</p>
<p>缺点第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484604209.png" alt="" loading="lazy"><br>
解决的办法叫<strong>内存交换</strong>（Memory Swapping），即把不足够连续的程序占用的内存写到硬盘上，再从硬盘上读回来到内存里面，不过读回来的时候，我们不再把它加载到原来的位置，而是放在连续的位置。</p>
<h3 id="内存分页">内存分页</h3>
<p>硬盘的访问速度要比内存慢很多，因此简单的内存交换并不高效。</p>
<p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。</p>
<p>对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（Page）。从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615484579925.png" alt="" loading="lazy"><br>
即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来更加高效。</p>
<p>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。</p>
<blockquote>
<p>在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。可以运行那些远大于我们实际物理内存的程序</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理01计算机的基本组成]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/">
        </link>
        <updated>2021-03-11T06:46:55.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615446914479.jpg" alt="" loading="lazy"></figure>
<h1 id="冯诺依曼体系结构">冯·诺依曼体系结构</h1>
<p>也叫<strong>存储程序计算机</strong> : 即“<strong>可编程</strong>” 、“<strong>可存储</strong>”计算机</p>
<p><strong>First Draft</strong>里面说了一台计算机应该有哪些部分组成。</p>
<p>首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。</p>
<p>所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。</p>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615448091025.jpg" alt="" loading="lazy"></figure>
<h1 id="计算机性能">计算机性能</h1>
<h2 id="什么是性能时间的倒数">什么是性能：时间的倒数</h2>
<p>第一个是<strong>响应时间</strong>（Response time）或者叫执行时间（Execution time）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”</p>
<p>第二个是<strong>吞吐率</strong>（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。</p>
<p>我们一般把性能，定义成响应时间的倒数，也就是：</p>
<p>性能 = 1/ 响应时间</p>
<h2 id="计算机的计时单位cpu-时钟">计算机的计时单位：CPU 时钟</h2>
<p><strong>首先，自然时间不“准”</strong></p>
<figure data-type="image" tabindex="3"><img src="https://Joshua-Chang.github.io/post-images/1615451589290.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>Wall Clock Time 或者 Elapsed Time，我们自然统计时间，就是在运行程序期间，挂在墙上的钟走掉的时间。</p>
<p>P2/P3，CPU 在各个程序之间进行切换、从网络、硬盘去读取数据的时间</p>
<p><strong>程序实际花费的 CPU 执行时间（CPU Time），就是 user time （在用户态运行指令的时间）加上 sys （在操作系统内核里运行指令的时间）time</strong>。</p>
</blockquote>
<p><strong>其次， CPU 执行时间也受到影响</strong>。 CPU 可能满载/降频运行，还会受到主板、内存这些其他相关硬件的影响。</p>
<p>**结果，**程序的 CPU 执行时间 =CPU 时钟周期数（CPU Cycles）×时钟周期时间 （Clock Cycle）</p>
<blockquote>
<p>在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。</p>
<p>在2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。超频，就相当于把 CPU 内部的钟给调快了</p>
</blockquote>
<p>CPU 时钟周期数（CPU Cycles）=指令数×<strong>每条指令的平均时钟周期数</strong>（Cycles Per Instruction，简称 CPI）</p>
<p><strong>程序的 CPU 执行时间 = 指令数×CPI×Clock Cycle Time</strong>  性能提升从这三方面</p>
<h1 id="计算机功耗">计算机功耗</h1>
<h2 id="功耗">功耗</h2>
<blockquote>
<p>CPU，一般都被叫作<strong>超大规模集成电路</strong>（Very-Large-Scale Integration，VLSI）。这些电路，实际上都是一个个晶体管组合而成的。CPU 在计算，其实就是让晶体管里面的“开关”不断地去“打开”和“关闭”，来组合完成各种运算和功能。</p>
</blockquote>
<p>想要计算得快：都会增加功耗，带来耗电和散热的问题。</p>
<ol>
<li><strong>增加密度</strong>（在 CPU 里，同样的面积里面，多放一些晶体管）；</li>
<li><strong>提升主频</strong>（让晶体管“打开”和“关闭”得更快一点）。</li>
</ol>
<p>在 CPU 里面，能够放下的晶体管数量和晶体管的“开关”频率也都是有限的。一个 CPU 的功率，可以用这样一个公式来表示：</p>
<p>功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量</p>
<p>要提升性能，同样的面积下，我们想要增加晶体管数量，就要把晶体管造得小一点。这个就是提升“制程”。</p>
<p>功耗和电压的平方是成正比的，</p>
<h2 id="并行优化">并行优化</h2>
<p>通过多核提升“吞吐率”而不是“响应时间”</p>
<p><strong>阿姆达尔定律</strong></p>
<p>优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间</p>
<h2 id="其他优化">其他优化</h2>
<ol>
<li><strong>加速大概率事件</strong>。cpu-&gt;gpu-&gt;tpu深度学习</li>
<li><strong>通过流水线提高性能</strong>。</li>
<li><strong>通过预测提高性能</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetPack Compose 01]]></title>
        <id>https://Joshua-Chang.github.io/post/jetpack-compose-01/</id>
        <link href="https://Joshua-Chang.github.io/post/jetpack-compose-01/">
        </link>
        <updated>2021-02-28T08:27:34.000Z</updated>
        <content type="html"><![CDATA[<p>@Composable/<em>标记组合函数，可提供其他函数使用</em>/</p>
<pre><code class="language-kotlin">@Composable
fun MyApp(content: @Composable () -&gt; Unit) {/*也可以 组合函数为参数*/
MyTheme{
        Surface(color = Color.Yellow) {
            content()
        }
    }
}
</code></pre>
<p>@Preview/<em>只能用与无参函数</em>/</p>
<h2 id="foundation包">foundation包</h2>
<pre><code class="language-kotlin">@Composable
fun NewsStory() {
    MaterialTheme/*遵循 MaterialTheme板式*/ {
        val typography = MaterialTheme.typography/*版式即TextStyle*/
        //val image= ImageBitmap.imageResource(R.drawable.header)/*弃用*/
        val image2 = painterResource(R.drawable.header)/*BitmapPainter or VectorPainter*/
        Column(modifier = Modifier.padding(16.dp)) {
            val modifier = Modifier
                /*即preferredHeight期望高度，可能改变。不变用requiredHeight，范围用heightIn*/
                .height(180.dp)
                .fillMaxWidth()/*可设置百分比，默认1。具体用width，或size同时设置*/
                .clip(RoundedCornerShape(4.dp))/*Material Design包*/
            Image(
                painter = image2,
                contentDescription = &quot;image&quot;,
                modifier = modifier,/*ScaleType*/
                contentScale = ContentScale.Crop
            )
            Spacer(modifier = Modifier.height(16.dp))/*间隔*/
            Text(
                text = &quot;A day wandering through the sandhill &quot; +
                        &quot;in Shark Fin Cove, and a few of the &quot; +
                        &quot;sights I saw&quot;,
                style = typography.h6/*定义好的TextStyle*/,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            Text(text = &quot;Davenport,California&quot;,style = typography.body2)
            Text(text = &quot;December 2018&quot;,style = typography.body2)
        }
    }
}
</code></pre>
<h2 id="重组">重组</h2>
<p>重组是指在输入更改时，再次调用可组合函数的过程。</p>
<ul>
<li>在命令式界面模型中，如需更改某个微件，您可以在该微件上调用 setter 以更改其内部状态。</li>
<li>在声明式Compose 中，您可以使用新数据再次调用可组合函数。</li>
</ul>
<p>这样做会导致函数进行重组 -- 系统会根据需要，使用新数据重新绘制函数发出的微件。不依赖于该数据的其他函数跳过，不会进行重组。</p>
<p>在 Compose 中编程时，有许多事项需要注意：</p>
<ul>
<li>
<p>可组合函数可以按任何顺序执行、可以并行执行。且重组会跳过尽可能多的可组合函数和 lambda。</p>
<p>因此每个可重组函数应保持独立，且不应有附带效应。</p>
</li>
<li>
<p>重组是乐观的操作，可能会被取消。</p>
</li>
<li>
<p>可组合函数可能会像动画的每一帧一样非常频繁地运行。</p>
</li>
</ul>
<pre><code class="language-kotlin">@Composable
@Deprecated(&quot;Example with bug&quot;)
fun ListWithBug(myList: List&lt;String&gt;) {
    var items = 0
    Row(horizontalArrangement = Arrangement.SpaceBetween) {
        Column {
            for (item in myList) {
                Text(&quot;Item: $item&quot;)
                items++ // Avoid! Side-effect of the column recomposing.
            }
        }
        Text(&quot;Count: $items&quot;)
    }
}
</code></pre>
<pre><code class="language-kotlin">/**
 * Display a list of names the user can click with a header
 */
@Composable
fun NamePicker(
    header: String,
    names: List&lt;String&gt;,
    onNameClicked: (String) -&gt; Unit
) {
    Column {
        // this will recompose when [header] changes, but not when [names] changes
        Text(header, style = MaterialTheme.typography.h5)
        Divider()

        // LazyColumnFor is the Compose version of a RecyclerView.
        // The lambda passed is similar to a RecyclerView.ViewHolder.
        LazyColumnFor(names) { name -&gt;
            // When an item's [name] updates, the adapter for that item
            // will recompose. This will not recompose when [header] changes
            NamePickerItem(name, onNameClicked)
        }
    }
}

/**
 * Display a single name the user can click.
 */
@Composable
private fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) {
    Text(name, Modifier.clickable(onClick = { onClicked(name) }))
}
</code></pre>
<h2 id="state">State</h2>
<pre><code class="language-kotlin">fun MyScreenContent() {
    val countState = remember {
        mutableStateOf(0)
    }
    Column {
        Counter()
        Counter2(count = countState.value,updateCount = {newCount-&gt;
            countState.value=newCount
        })
    }
}

@Composable
fun Counter() {
    val count = remember {
        mutableStateOf(0)
    }
    Button(onClick = { count.value++ }) {
        Text(text = &quot;${count.value} times&quot;)
    }
}
@Composable
fun Counter2(count:Int,updateCount:(Int)-&gt;Unit) {
    Button(onClick = { updateCount(count+1) }) {
        Text(text = &quot;$count times&quot;)
    }
}
</code></pre>
<h2 id="lazycolumn">LazyColumn</h2>
<pre><code class="language-kotlin">@Composable
fun NameList(names: List&lt;String&gt;, modifier: Modifier = Modifier) {
    LazyColumn(modifier = modifier) {
        items(items = names) { name -&gt;
            Greeting(name = name)
            Divider(color = Color.Black)
        }
    }
}
Column(modifier = Modifier.fillMaxHeight()) {
    NameList(names, Modifier.weight(1f))
    Counter2(count = countState.value, updateCount = { newCount -&gt;
        countState.value = newCount
    })
}
</code></pre>
<pre><code class="language-kotlin">@Composable
fun Greeting(name: String) {
    /*by委托：将set/get委托出去*/
    var isSelected by /*Boolean*/remember { mutableStateOf(false) }
    val backgroundColor by /*委托State&lt;Color&gt;*/animateColorAsState(if (isSelected) Color.Red else Color.Transparent)
    Text(text = &quot;hello $name&quot;,
        modifier = Modifier
            .padding(24.dp)
            .background(color = backgroundColor)
            .clickable(onClick = { isSelected = !isSelected })
    )
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Navigator源码分析]]></title>
        <id>https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/</id>
        <link href="https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/">
        </link>
        <updated>2020-12-14T16:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="讨论案例">讨论案例</h3>
<pre><code class="language-xml">activity_main.xml

&lt;fragment
    android:id=&quot;@+id/nav_host_fragment&quot;
    android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:defaultNavHost=&quot;true&quot;
    app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt;

mobile_navigation.xml

&lt;navigation
    android:id=&quot;@+id/mobile_navigation&quot;
    app:startDestination=&quot;@id/navigation_home&quot;&gt;
    &lt;fragment
        android:id=&quot;@+id/navigation_home&quot;
        android:name=&quot;org.devio.as.hi.hirouter.ui.home.HomeFragment&quot;
        tools:layout=&quot;@layout/fragment_home&quot;&gt;
        &lt;argument
            android:name=&quot;name&quot;
            app:argType=&quot;string&quot;
            app:nullable=&quot;true&quot; /&gt;
        &lt;action
            android:id=&quot;@+id/action_navigation_home_to_navigation_notifications&quot;
            app:destination=&quot;@id/navigation_notifications&quot;
            app:launchSingleTop=&quot;true&quot;
            app:popUpTo=&quot;@id/navigation_notifications&quot; /&gt;
        &lt;deepLink
            android:id=&quot;@+id/deepLink&quot;
            app:uri=&quot;www.imooc.com&quot; /&gt;
    &lt;/fragment&gt;
&lt;/navigation&gt;
</code></pre>
<h3 id="navhostfragmentoninflate">NavHostFragment.onInflate:</h3>
<p>去查找声明在NavHostFragment的xml布局文件中的，defaultNavHost、navGraph属性,得到mGraphId</p>
<pre><code class="language-kotlin">onInflate：任何能在xml布局文件中声明的组建，当它们被从xml解析完成，被创建成功后都会调用此方法
activity和dialog是不可以的，因为他们不能在xml布局文件中直接声明
    @CallSuper
    @Override
    public void onInflate(@NonNull Context context, @NonNull AttributeSet attrs,
            @Nullable Bundle savedInstanceState) {
        super.onInflate(context, attrs, savedInstanceState);

        final TypedArray navHost = context.obtainStyledAttributes(attrs, R.styleable.NavHost);
        final int graphId = navHost.getResourceId(R.styleable.NavHost_navGraph, 0);
        if (graphId != 0) {
            mGraphId = graphId;
        }
        navHost.recycle();

        final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.NavHostFragment);
        final boolean defaultHost = a.getBoolean(R.styleable.NavHostFragment_defaultNavHost, false);
        if (defaultHost) {
            mDefaultNavHost = true;
        }
        a.recycle();
    }
</code></pre>
<h3 id="navhostfragmentoncreate">NavHostFragment.onCreate:</h3>
<ul>
<li>往NavigatorProvider内addNavigator：</li>
</ul>
<p>构造NavHostController方法内，先添加不可或缺的ActivityNavigator、和NavGraphNavigator （<navigation/>startDestination）</p>
<p>onCreateNavController方法内，添加DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转</p>
<ul>
<li>配置回退栈</li>
<li>NavController.setGraph(mGraphId)。把声明在NavHostFragment的app:navGraph的id，交给NavController处理（和fragmentController设计原因一样，隔离作用）</li>
</ul>
<pre><code class="language-kotlin">NavHostFragment:
@CallSuper
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final Context context = requireContext();
		//构建NavController对象 内部立即注册两个Navigator：start、activity的
    mNavController = new NavHostController(context);//继承自NavController
		//设置回退栈
    mNavController.setOnBackPressedDispatcher(requireActivity().getOnBackPressedDispatcher());
	  //...
		//通过controller得到Provider，并对其注册DialogFragmentNavigator，FragmentNavigator。以支持dialog、fragment类型的导航跳转
    onCreateNavController(mNavController);
    //。。。

        //把声明在NavHostFragment的xml布局文件中的资源id
				//app:navGraph=&quot;@navigation/mobile_navigation&quot;（navGraph属性）
				//交给NavController处理（和fragmentController设计原因一样，隔离作用）
        mNavController.setGraph(mGraphId);
}
//通过controller得到Provider（存储一个个navigator对象），
//并注册DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转
protected void onCreateNavController(@NonNull NavController navController) {
        navController.getNavigatorProvider().addNavigator(
                new DialogFragmentNavigator(requireContext(), getChildFragmentManager()));
        navController.getNavigatorProvider().addNavigator(createFragmentNavigator());
    }

//立即注册两个Navigator
NavController：
public NavController(@NonNull Context context) {
//....路由首页和activity都是不可或缺的，但fragmentNavigator未必，所以这里注册了两个
//mobile_navigation.xml资源文件加载完，用来启动其中的startDestination对应的页面的
        mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider));
//能给activity提供路由服务的navigator
        mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));
    }
//设置dispatcher后将mOnBackPressedCallback加入callback
void setOnBackPressedDispatcher(@NonNull OnBackPressedDispatcher dispatcher) {
	      //...
        dispatcher.addCallback(mLifecycleOwner, mOnBackPressedCallback);
    }

private final OnBackPressedCallback mOnBackPressedCallback =
            new OnBackPressedCallback(false) {
        @Override
        public void handleOnBackPressed() {
            popBackStack();//回退栈
        }
    };
</code></pre>
<h3 id="navinflaterinflate">NavInflater().inflate</h3>
<p>解析路由资源文件返回NavGraph对象：由路由资源xml定义的节点名，得到相应类型的Navigator，在去创建相应类型的Destination节点。</p>
<p><navigation/>特殊：会得到NavGraphNavigator类型的navigator，并创建出NavGraph类型的节点。</p>
<p>NavGraph是特殊的Destination节点：</p>
<ul>
<li>成员：含app:startDestination的id，和SparseArrayCompat<NavDestination>的路由节点集合</li>
<li>自己可以嵌套自己，即mobile_navigation.xml内的<navigation/>标签内还可以有<navigation/>形成一个个的路由组，且每组以各自的app:startDestination为起始点</li>
<li>NavInflater().inflate时遇到NavGraph类型的节点，递归调用inflate，将自节点加入其路由节点集合</li>
</ul>
<p>onGraphCreated：路由文件解析/节点创建完毕，开始路由跳转流程NavController.navigate</p>
<pre><code class="language-kotlin">NavController：
		@CallSuper
    public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) {
        setGraph(getNavInflater().inflate(graphResId)/*得到NavGraph*/, startDestinationArgs);
    }

		public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) {
        if (mGraph != null) {
            // Pop everything from the old graph off the back stack
            popBackStackInternal(mGraph.getId(), true);
        }
        mGraph = graph;//将得到的NavGraph保存起来
				//第一阶段：路由文件解析节点创建流程完毕
        onGraphCreated(startDestinationArgs);
				//内部会调用navigate(mGraph, startDestinationArgs, null, null);启动第一个路由节点//第二阶段路由跳转流程开始					
  }

NavInflater：
//layoutInflater专门解析布局资源文件，NavInflater专门解析路由资源文件，返回NavGraph对象
public NavGraph inflate(@NavigationRes int graphResId) {
      //。。。路由xml文件（app:navGraph=&quot;@navigation/mobile_navigation&quot;）的解析
			//生产路由节点对象
			NavDestination destination = inflate(res, parser, attrs, graphResId);
			if (!(destination instanceof NavGraph)) {//如果返回结果不是NavGraph类型则会抛出异常。即mobile_navigation.xml根结点必须&lt;navigation/&gt;标签
                throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot;
                        + &quot; did not inflate into a NavGraph&quot;);
            }
            return (NavGraph) destination;
    }

private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser,
            @NonNull AttributeSet attrs, int graphResId)
            throws XmlPullParserException, IOException {
//根据mobile_navigation.xml中的定义的节点类型，
//特殊：mobile_navigation.xml中的第一个节点为navigation解析出NavGraphNavigator类型的navigator导航
//正常：后边的节点为activity/fragment等，解析出fragmentnavigator/activitynavigator等类型的navigator
        Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName());
//使用navigator创建Destination节点（ADestination/FDestination等），以activityNavigator为例
//使用NavGraphNavigator创建出NavGraph
        final NavDestination dest = navigator.createDestination();
        dest.onInflate(mContext, attrs);//NavDestination节点（具体是子类activity或fragment）解析填充
				//...
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
              // ....
            } else if (dest instanceof NavGraph) {//如果节点是NavGraph则递归调用自己，继续解析并加入到NavGraph的节点集合中
                ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId));
            }
        }
        return dest;
}

ActivityNavigator：
public Destination createDestination() {
        return new Destination(this);//传入navigator自己
    }
ActivityNavigator$Destination
public static class Destination extends NavDestination{
	super(activityNavigator);//调父类NavDestination
}

NavDestination节点:的构造需要创建NavDestination的Navigator，或navigatorName
//无论是activity还是fragment类型的节点，
//创建时都需要把创建他的Navigator传递进来，以便正确的跳转
//从而把Destination节点和创建他的Navigator导航 关联起来
public NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) {}
public NavDestination(@NonNull String navigatorName) {}

NavGraphNavigator：特殊Navigator
public NavGraph createDestination() {
        return new NavGraph(this);
    }
NavGraph：特殊Destination节点，自己可以嵌套自己，
即mobile_navigation.xml内的&lt;navigation/&gt;标签内还可以有&lt;navigation/&gt;
形成一个个的路由组，且每组以各自的app:startDestination为起始点
例子：电商交易支付完成后，将一组都关闭

NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; {
    final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;();//路由节点的集合
    private int mStartDestId;//该集合的启动ID app:startDestination=&quot;@id/navigation_home&quot;
    private String mStartDestIdName;
}
</code></pre>
<h3 id="navcontrollernavigate">NavController.navigate</h3>
<p>第二阶段路由跳转流程开始</p>
<p>根据NavGraph这一特殊节点的name，得到NavGraphNavigator对象</p>
<pre><code class="language-kotlin">private void navigate(@NonNull NavDestination node, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    //...
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            node.getNavigatorName());//根据NavGraph的name，找创建该节点的到navigator对象 即NavGraphNavigator对象
    Bundle finalArgs = node.addInDefaultArgs(args);
    NavDestination newDest = navigator.navigate(node, finalArgs,//然后发起真正的路由
            navOptions, navigatorExtras);
    mBackStack.add(entry);//把路由节点添加到回退栈
}
</code></pre>
<h3 id="navgraphnavigatornavigate">NavGraphNavigator.navigate</h3>
<p>找到<navigator/>内 的startDestination节点</p>
<p>根据startDestination节点的name，在NavigatorProvider里找到创建他的具体的f/a/dialog等类型的Navigator</p>
<p>再让具体f/a/dialog等类型的Navigator去处理路由</p>
<pre><code class="language-kotlin">NavGraphNavigator：
public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) {
    int startId = destination.getStartDestination();//app:startDestination的id

		//根据app:startDestination的id找到相应的startDestination节点
    NavDestination startDestination = destination.findNode(startId, false);
	
		//根据startDestination节点的name属性，找到创建他的具体navigator
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            startDestination.getNavigatorName());//此时的navigator可能是f/a/dialog等类型的Navigator
		//再将路由操作委托给f/a/dialog等类型的Navigator
    return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args),
            navOptions, navigatorExtras);
}

1、activityNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
				//构造intent
        Intent intent = new Intent(destination.getIntent());
        if (args != null) {
            intent.putExtras(args);//添加args
            //。。。
        }
				//配置启动模式
        if (!(mContext instanceof Activity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) {
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        }

				//进出动画等。。。

				mContext.startActivity(intent);//通过startActivity完成路由
    }

2、fragmentNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();//根据destination节点得到类名
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = instantiateFragment(mContext, mFragmentManager,
                className, args);//根据类名反射得到fragment实例
        frag.setArguments(args);//设置args
        final FragmentTransaction ft = mFragmentManager.beginTransaction();//开启事务
				
        //进出动画等。。。

        ft.replace(mContainerId, frag);
				//此处使用的是replace，因此使用Navigator路由时切换fragment时，声明周期重新执行
    }

3、dialogFragmentNavigator
public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = mFragmentManager.getFragmentFactory().instantiate(
                mContext.getClassLoader(), className);//反射
        if (!DialogFragment.class.isAssignableFrom(frag.getClass())) {//类型判断：是否时dialogFragment类型的
            throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName()
                    + &quot; is not an instance of DialogFragment&quot;);
        }
        final DialogFragment dialogFragment = (DialogFragment) frag;//上文以确定为dialogFragment
        dialogFragment.setArguments(args);//添加args
        dialogFragment.getLifecycle().addObserver(mObserver);

				//show出dialogFragment
        dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++);
        return destination;
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1607965068319.png" alt="" loading="lazy"></figure>
<h3 id="缺点">缺点：</h3>
<ol>
<li>节点必须在路由文件mobile_navigation.xml中定义</li>
<li>fragment类型节点的路由操作，是使用replace，会导致fragment页面声明周期重启，数据的重新加载</li>
<li>不支持路由过程的拦截监听</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update MacOS to Mojave Vim: Caught deadly signal SEGV]]></title>
        <id>https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/</id>
        <link href="https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/">
        </link>
        <updated>2018-10-24T03:51:37.000Z</updated>
        <content type="html"><![CDATA[<h5 id="极有可能是youcompleteme或者powerline等插件的问题">极有可能是<em>YouCompleteMe</em>或者<em>Powerline</em>等插件的问题</h5>
<pre><code class="language-bash">Vim: Caught deadly signal SEGV

Error detected while processing function &lt;SNR&gt;78_PollServerReady[7]..&lt;SNR&gt;78_Pyeval:Vim: Finished.

line    4:
Exception MemoryError: MemoryError() in &lt;module 'threading' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'&gt; ignored
[1]    72868 segmentation fault  vim Test.java
</code></pre>
<h5 id="解决">解决：</h5>
<pre><code class="language-bash">brew install vim --with-lua --with-override-system-vi
</code></pre>
<p>and restart shell , fixed</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App使用统计与静默拍摄]]></title>
        <id>https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/</id>
        <link href="https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/">
        </link>
        <updated>2018-10-03T10:29:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="app使用统计">App使用统计</h3>
<p>监控或统计手机内的app使用情况可以从两个思路考虑</p>
<ul>
<li>
<p>统计每个app的使用时长</p>
<p>UsageStatsManager这一统计管理类，可以查出每个app简单的最近开启时间、某时限内的使用时长等信息。更复杂的手机亮屏次数，开启<!--more-->应用次数可以使用UsageStatsService或者过滤包名的形式统计。</p>
</li>
<li>
<p>统计每个Android系统耗电情况的每个app占比</p>
<p>在做电量优化的时候经常会通过adb使用Battery-Historian分析电量报告，所以由此灵感，具体的实现还需要头脑风暴一下。</p>
</li>
</ul>
<h5 id="对app使用时常统计的简单实现">对app使用时常统计的简单实现</h5>
<ol>
<li>
<p>开启ACTION_USAGE_ACCESS_SETTINGS权限</p>
<figure data-type="image" tabindex="1"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2lhoyj308r0fkt9b.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>得到使用分析管理UsageStatsManager并根据时限查询统计状态</p>
<pre><code class="language-java">UsageStatsManager manager = (UsageStatsManager) getApplicationContext().getSystemService(USAGE_STATS_SERVICE);
List&lt;UsageStats&gt; stats = manager.queryUsageStats(UsageStatsManager.INTERVAL_MONTHLY, beginCal.getTimeInMillis(), endCal.getTimeInMillis());
</code></pre>
</li>
<li>
<p>根据UsageStats查询每个app的统计信息</p>
<pre><code class="language-java">for (UsageStats us : stats) {
    try {
        PackageManager pm = getApplicationContext().getPackageManager();
        ApplicationInfo applicationInfo = pm.getApplicationInfo(us.getPackageName(), PackageManager.GET_META_DATA);
        if ((applicationInfo.flags &amp; applicationInfo.FLAG_SYSTEM) &lt;= 0) {
            sb.append(pm.getApplicationLabel(applicationInfo)+&quot; 使用时长：&quot;+formatTime(us.getTotalTimeInForeground())+&quot;\n&quot;);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2tdo9j308r0fkabf.jpg" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="静默后台拍摄">静默后台拍摄</h3>
<h5 id="静默拍摄的简单思路">静默拍摄的简单思路</h5>
<ul>
<li>
<p>将SurfaceView或TextureView这一采集呈现的layout参数设为最小。（不能设置visibility：gone 不会采集到图像），可见现在采集时没有采集预览，但采集到的bitmap可以成功设置。</p>
<figure data-type="image" tabindex="3"><img src="https://thumbs.gfycat.com/DenseFailingGroundhog-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
<li>
<p>再将SurfaceView所在的Activity主题透明化</p>
<p>可见此时的采集效果从UI上看静默进行。”拍摄“按键只是方便展示效果，如果使用Service去掉用则</p>
<p>真正实现了后台静默采集的效果，至于采集到bitmap可以储存也可以直接用三方sdk做一些图像分析。</p>
<figure data-type="image" tabindex="4"><img src="https://thumbs.gfycat.com/SpryBeautifulChafer-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开发一个IntelliJ IDEA插件]]></title>
        <id>https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/</id>
        <link href="https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/">
        </link>
        <updated>2017-12-26T16:03:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="灵感">灵感</h3>
<p>IDEA和AS中的大小写切换快捷键，一直是比较良心的。</p>
<p>在声明一些常量时极其省事，但常量由多个单词组成时，还要手动的加上下划线又及其麻烦。</p>
<h3 id="思路">思路</h3>
<p>开发一个插件，把符合驼峰命名的多单词组成名字，分别加上下划线。反之，把由下划线拼成的名字变成驼峰<!--more--></p>
<p>命名。</p>
<h3 id="eg">e.g.</h3>
<ul>
<li>
<p>light_dialog_type --&gt; lightDialogType</p>
</li>
<li>
<p>anApplePie --&gt; an_apple_pie</p>
</li>
<li>
<p>homeActivityTimer --&gt;home_activity_timer --&gt; HOME_ACTIVITY_TIMER</p>
</li>
</ul>
<h3 id="实现">实现</h3>
<ol>
<li>新建一个IntelliJ Platform Plugin项目，创建相应的action复写actionPerformed()</li>
<li>得到AS/IDEA选中的常量名</li>
</ol>
<pre><code class="language-java">       //获取Editor和Project对象
        Editor editor = e.getData(PlatformDataKeys.EDITOR);
        Project project = e.getData(PlatformDataKeys.PROJECT);
        if (editor == null || project == null)
            return;

        //获取SelectionModel和Document对象
        SelectionModel selectionModel = editor.getSelectionModel();
        Document document = editor.getDocument();

        selectionModel.selectWordAtCaret(false);
        //拿到选中部分字符串
        String selectedText = selectionModel.getSelectedText();

        //得到选中字符串的起始和结束位置
        int startOffset = selectionModel.getSelectionStart();
        int endOffset = selectionModel.getSelectionEnd();
</code></pre>
<ol start="3">
<li>新线程中去执行驼峰命名与下划线的转换操作</li>
</ol>
<pre><code class="language-java">        //对文档进行操作部分代码，需要放入Runnable接口中实现，由IDEA在内部将其通过一个新线程执行
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                if (isLine(selectedText)) {
                    document.replaceString(startOffset, endOffset, lineToHump(selectedText));
                }else {
                    String temp=null;
                    if (selectedText.charAt(0) == 'm' &amp;&amp; selectedText.charAt(1) &lt;= 'Z' &amp;&amp; selectedText.charAt(1) &gt;= 'A') {//情况一：把mActivityInstance这种变为ActivityInstance
                        temp = selectedText.substring(1);
                    }
                    String result = temp != null ? temp : selectedText;
                    result=humpToLine(result);
                    if (result.charAt(0)=='_') {
                        result=result.substring(1);
                    }
                    document.replaceString(startOffset, endOffset, result);
                }
            }
        };
</code></pre>
<ol start="4">
<li>加入任务，由IDEA调度执行这个任务</li>
</ol>
<pre><code class="language-java">WriteCommandAction.runWriteCommandAction(project, runnable);
</code></pre>
<ol start="5">
<li>其他：转换方法都是些常用算法不做赘述；Action的update方法看需求情况编写。</li>
</ol>
<h3 id="完工">完工</h3>
<p>发布在JetBrains给提提意见：<a href="https://plugins.jetbrains.com/plugin/11121-underline-camel-toggle-case">Underline Camel Toggle Case</a> 或在AS/IDEA的plugin中搜索</p>
]]></content>
    </entry>
</feed>