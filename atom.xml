<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Joshua-Chang.github.io</id>
    <title>Joshua-Chang`Blog</title>
    <updated>2021-03-11T14:53:59.549Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Joshua-Chang.github.io"/>
    <link rel="self" href="https://Joshua-Chang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Joshua-Chang.github.io/images/avatar.png</logo>
    <icon>https://Joshua-Chang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Joshua-Chang`Blog</rights>
    <entry>
        <title type="html"><![CDATA[ 计算机组成原理02指令和运算]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-02-zhi-ling-he-yun-suan/">
        </link>
        <updated>2021-03-11T09:41:24.000Z</updated>
        <summary type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从硬件角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑<br>
从软件角度讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
<!-- more -->
<p>不同的 CPU 能够听懂的语言不太一样，即计算机指令集Instruction Set</p>
<h2 id="指令和机器码">指令和机器码</h2>
<ol>
<li>
<p>把高级语言程序翻译成汇编语言（ASM，Assembly Language）程序，的过程叫编译（Compile）成汇编代码</p>
</li>
<li>
<p>再用汇编器（Assembler）翻译成机器码（Machine Code），CPU 能够真正认识的计算机指令<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460135310.png" alt="" loading="lazy"><br>
<img src="https://Joshua-Chang.github.io/post-images/1615460148801.jpg" alt="" loading="lazy"></p>
</li>
</ol>
<blockquote>
<p>e.g.<br>
<img src="https://Joshua-Chang.github.io/post-images/1615460725402.jpg" alt="" loading="lazy"><br>
MIPS 的指令是一个 32 位的整数，高 6 位叫操作码（Opcode），分别是 R、I 和 J，代表这条指令具体的操作类别。rt、rt、rd均为寄存器地址。<br>
R 指令是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。</p>
<p>I 指令，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。</p>
<p>J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。</p>
<p><code>add $t0,$s2,$s1</code>为例 s1 17    s2 18      t0 8<br>
<img src="https://Joshua-Chang.github.io/post-images/1615461145867.jpg" alt="" loading="lazy"><br>
<img src="https://Joshua-Chang.github.io/post-images/1615461154758.png" alt="" loading="lazy"></p>
</blockquote>
<p>除了 C 这样的编译型的语言之外，Python 这样的解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java 这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译(JIT)成为机器码来最终执行。</p>
<h2 id="指令跳转">指令跳转</h2>
<blockquote>
<p>CPU 其实就是由一堆寄存器组成的。而寄存器是由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。</p>
<p>N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。</p>
</blockquote>
<h3 id="cpu-里面的寄存器">CPU 里面的寄存器：</h3>
<p>一个是<strong>PC 寄存器</strong>（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。它就是用来存放下一条需要执行的计算机指令的内存地址。</p>
<p>第二个是<strong>指令寄存器</strong>（Instruction Register），用来存放当前正在执行的指令。</p>
<p>第三个是<strong>条件码寄存器</strong>（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。<strong>零标志条件码</strong>（对应的条件码是 ZF，Zero Flag 不等为0）、<strong>进位标志</strong>（CF，Carry Flag A&gt;B 为0）、<strong>符号标志</strong>（SF，Sign Flag正数为0）以及<strong>溢出标志</strong>（OF，Overflow Flag）</p>
<p>其他用来存储数据和内存地址的寄存器：通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等，通用寄存器（既可以存放数据，又能存放地址）</p>
<p>一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令，读取到指令寄存器里面执行，然后顺序读取下一条指令。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472744523.jpg" alt="" loading="lazy"></p>
<h3 id="ifelse">if…else</h3>
<pre><code class="language-c">#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
}
</code></pre>
<pre><code class="language-shell">$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
</code></pre>
<p><strong>汇编代码</strong></p>
<p>r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令</p>
<p>cmp 指令比较了前后两个操作数的值： 操作对象1 - 操作对象2 但不保存结果，只是根据结果修改相应的标志位。</p>
<ol>
<li>DWORD PTR 代表操作的数据类型是 32 位的整数，[rbp-0x4] 则是一个寄存器的地址。</li>
<li>第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示</li>
</ol>
<p>cmp 指令的比较结果，会存入到<strong>条件码寄存器</strong>当中去，<strong>零标志条件码</strong>ZF 相等为1，不等为0</p>
<p>cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令</p>
<p>jne 指令： jump not equal 查看零标志位ZF不等于0，则跳转到4a（当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址）</p>
<p>CPU 再把 4a 地址里的指令加载到指令寄存器中来执行，mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。</p>
<p>mov 指令的第一个操作数 eax，代表累加寄存器，这条指令其实没有实际的作用，它的作用是一个占位符。</p>
<p>if 条件满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令，跳转的地址就是51。</p>
<p>main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。</p>
<pre><code class="language-shell"> if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0 //只比较，结果存入标识位
  3f:   75 09                   jne    4a &lt;main+0x4a&gt; //标识位ZF不等于0则执行
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 &lt;main+0x51&gt;
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615472764389.jpg" alt="" loading="lazy"></figure>
<h3 id="forwhile">for/while</h3>
<p>对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。</p>
<p>jle 跳转的地址，是在这条指令之前的地址 14。往前跳转使得，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。<br>
<img src="https://Joshua-Chang.github.io/post-images/1615472775030.jpg" alt="" loading="lazy"></p>
<p>除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。</p>
<h2 id="函数调用">函数调用</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理01计算机的基本组成]]></title>
        <id>https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/</id>
        <link href="https://Joshua-Chang.github.io/post/ji-suan-ji-zu-cheng-yuan-li-01/">
        </link>
        <updated>2021-03-11T06:46:55.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1615446914479.jpg" alt="" loading="lazy"></figure>
<h1 id="冯诺依曼体系结构">冯·诺依曼体系结构</h1>
<p>也叫<strong>存储程序计算机</strong> : 即“<strong>可编程</strong>” 、“<strong>可存储</strong>”计算机</p>
<p><strong>First Draft</strong>里面说了一台计算机应该有哪些部分组成。</p>
<p>首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。</p>
<p>所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。</p>
<figure data-type="image" tabindex="2"><img src="https://Joshua-Chang.github.io/post-images/1615448091025.jpg" alt="" loading="lazy"></figure>
<h1 id="计算机性能">计算机性能</h1>
<h2 id="什么是性能时间的倒数">什么是性能：时间的倒数</h2>
<p>第一个是<strong>响应时间</strong>（Response time）或者叫执行时间（Execution time）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”</p>
<p>第二个是<strong>吞吐率</strong>（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。</p>
<p>我们一般把性能，定义成响应时间的倒数，也就是：</p>
<p>性能 = 1/ 响应时间</p>
<h2 id="计算机的计时单位cpu-时钟">计算机的计时单位：CPU 时钟</h2>
<p><strong>首先，自然时间不“准”</strong></p>
<figure data-type="image" tabindex="3"><img src="https://Joshua-Chang.github.io/post-images/1615451589290.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>Wall Clock Time 或者 Elapsed Time，我们自然统计时间，就是在运行程序期间，挂在墙上的钟走掉的时间。</p>
<p>P2/P3，CPU 在各个程序之间进行切换、从网络、硬盘去读取数据的时间</p>
<p><strong>程序实际花费的 CPU 执行时间（CPU Time），就是 user time （在用户态运行指令的时间）加上 sys （在操作系统内核里运行指令的时间）time</strong>。</p>
</blockquote>
<p><strong>其次， CPU 执行时间也受到影响</strong>。 CPU 可能满载/降频运行，还会受到主板、内存这些其他相关硬件的影响。</p>
<p>**结果，**程序的 CPU 执行时间 =CPU 时钟周期数（CPU Cycles）×时钟周期时间 （Clock Cycle）</p>
<blockquote>
<p>在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。</p>
<p>在2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。超频，就相当于把 CPU 内部的钟给调快了</p>
</blockquote>
<p>CPU 时钟周期数（CPU Cycles）=指令数×<strong>每条指令的平均时钟周期数</strong>（Cycles Per Instruction，简称 CPI）</p>
<p><strong>程序的 CPU 执行时间 = 指令数×CPI×Clock Cycle Time</strong>  性能提升从这三方面</p>
<h1 id="计算机功耗">计算机功耗</h1>
<h2 id="功耗">功耗</h2>
<blockquote>
<p>CPU，一般都被叫作<strong>超大规模集成电路</strong>（Very-Large-Scale Integration，VLSI）。这些电路，实际上都是一个个晶体管组合而成的。CPU 在计算，其实就是让晶体管里面的“开关”不断地去“打开”和“关闭”，来组合完成各种运算和功能。</p>
</blockquote>
<p>想要计算得快：都会增加功耗，带来耗电和散热的问题。</p>
<ol>
<li><strong>增加密度</strong>（在 CPU 里，同样的面积里面，多放一些晶体管）；</li>
<li><strong>提升主频</strong>（让晶体管“打开”和“关闭”得更快一点）。</li>
</ol>
<p>在 CPU 里面，能够放下的晶体管数量和晶体管的“开关”频率也都是有限的。一个 CPU 的功率，可以用这样一个公式来表示：</p>
<p>功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量</p>
<p>要提升性能，同样的面积下，我们想要增加晶体管数量，就要把晶体管造得小一点。这个就是提升“制程”。</p>
<p>功耗和电压的平方是成正比的，</p>
<h2 id="并行优化">并行优化</h2>
<p>通过多核提升“吞吐率”而不是“响应时间”</p>
<p><strong>阿姆达尔定律</strong></p>
<p>优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间</p>
<h2 id="其他优化">其他优化</h2>
<ol>
<li><strong>加速大概率事件</strong>。cpu-&gt;gpu-&gt;tpu深度学习</li>
<li><strong>通过流水线提高性能</strong>。</li>
<li><strong>通过预测提高性能</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetPack Compose 01]]></title>
        <id>https://Joshua-Chang.github.io/post/jetpack-compose-01/</id>
        <link href="https://Joshua-Chang.github.io/post/jetpack-compose-01/">
        </link>
        <updated>2021-02-28T08:27:34.000Z</updated>
        <content type="html"><![CDATA[<p>@Composable/<em>标记组合函数，可提供其他函数使用</em>/</p>
<pre><code class="language-kotlin">@Composable
fun MyApp(content: @Composable () -&gt; Unit) {/*也可以 组合函数为参数*/
MyTheme{
        Surface(color = Color.Yellow) {
            content()
        }
    }
}
</code></pre>
<p>@Preview/<em>只能用与无参函数</em>/</p>
<h2 id="foundation包">foundation包</h2>
<pre><code class="language-kotlin">@Composable
fun NewsStory() {
    MaterialTheme/*遵循 MaterialTheme板式*/ {
        val typography = MaterialTheme.typography/*版式即TextStyle*/
        //val image= ImageBitmap.imageResource(R.drawable.header)/*弃用*/
        val image2 = painterResource(R.drawable.header)/*BitmapPainter or VectorPainter*/
        Column(modifier = Modifier.padding(16.dp)) {
            val modifier = Modifier
                /*即preferredHeight期望高度，可能改变。不变用requiredHeight，范围用heightIn*/
                .height(180.dp)
                .fillMaxWidth()/*可设置百分比，默认1。具体用width，或size同时设置*/
                .clip(RoundedCornerShape(4.dp))/*Material Design包*/
            Image(
                painter = image2,
                contentDescription = &quot;image&quot;,
                modifier = modifier,/*ScaleType*/
                contentScale = ContentScale.Crop
            )
            Spacer(modifier = Modifier.height(16.dp))/*间隔*/
            Text(
                text = &quot;A day wandering through the sandhill &quot; +
                        &quot;in Shark Fin Cove, and a few of the &quot; +
                        &quot;sights I saw&quot;,
                style = typography.h6/*定义好的TextStyle*/,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            Text(text = &quot;Davenport,California&quot;,style = typography.body2)
            Text(text = &quot;December 2018&quot;,style = typography.body2)
        }
    }
}
</code></pre>
<h2 id="重组">重组</h2>
<p>重组是指在输入更改时，再次调用可组合函数的过程。</p>
<ul>
<li>在命令式界面模型中，如需更改某个微件，您可以在该微件上调用 setter 以更改其内部状态。</li>
<li>在声明式Compose 中，您可以使用新数据再次调用可组合函数。</li>
</ul>
<p>这样做会导致函数进行重组 -- 系统会根据需要，使用新数据重新绘制函数发出的微件。不依赖于该数据的其他函数跳过，不会进行重组。</p>
<p>在 Compose 中编程时，有许多事项需要注意：</p>
<ul>
<li>
<p>可组合函数可以按任何顺序执行、可以并行执行。且重组会跳过尽可能多的可组合函数和 lambda。</p>
<p>因此每个可重组函数应保持独立，且不应有附带效应。</p>
</li>
<li>
<p>重组是乐观的操作，可能会被取消。</p>
</li>
<li>
<p>可组合函数可能会像动画的每一帧一样非常频繁地运行。</p>
</li>
</ul>
<pre><code class="language-kotlin">@Composable
@Deprecated(&quot;Example with bug&quot;)
fun ListWithBug(myList: List&lt;String&gt;) {
    var items = 0
    Row(horizontalArrangement = Arrangement.SpaceBetween) {
        Column {
            for (item in myList) {
                Text(&quot;Item: $item&quot;)
                items++ // Avoid! Side-effect of the column recomposing.
            }
        }
        Text(&quot;Count: $items&quot;)
    }
}
</code></pre>
<pre><code class="language-kotlin">/**
 * Display a list of names the user can click with a header
 */
@Composable
fun NamePicker(
    header: String,
    names: List&lt;String&gt;,
    onNameClicked: (String) -&gt; Unit
) {
    Column {
        // this will recompose when [header] changes, but not when [names] changes
        Text(header, style = MaterialTheme.typography.h5)
        Divider()

        // LazyColumnFor is the Compose version of a RecyclerView.
        // The lambda passed is similar to a RecyclerView.ViewHolder.
        LazyColumnFor(names) { name -&gt;
            // When an item's [name] updates, the adapter for that item
            // will recompose. This will not recompose when [header] changes
            NamePickerItem(name, onNameClicked)
        }
    }
}

/**
 * Display a single name the user can click.
 */
@Composable
private fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) {
    Text(name, Modifier.clickable(onClick = { onClicked(name) }))
}
</code></pre>
<h2 id="state">State</h2>
<pre><code class="language-kotlin">fun MyScreenContent() {
    val countState = remember {
        mutableStateOf(0)
    }
    Column {
        Counter()
        Counter2(count = countState.value,updateCount = {newCount-&gt;
            countState.value=newCount
        })
    }
}

@Composable
fun Counter() {
    val count = remember {
        mutableStateOf(0)
    }
    Button(onClick = { count.value++ }) {
        Text(text = &quot;${count.value} times&quot;)
    }
}
@Composable
fun Counter2(count:Int,updateCount:(Int)-&gt;Unit) {
    Button(onClick = { updateCount(count+1) }) {
        Text(text = &quot;$count times&quot;)
    }
}
</code></pre>
<h2 id="lazycolumn">LazyColumn</h2>
<pre><code class="language-kotlin">@Composable
fun NameList(names: List&lt;String&gt;, modifier: Modifier = Modifier) {
    LazyColumn(modifier = modifier) {
        items(items = names) { name -&gt;
            Greeting(name = name)
            Divider(color = Color.Black)
        }
    }
}
Column(modifier = Modifier.fillMaxHeight()) {
    NameList(names, Modifier.weight(1f))
    Counter2(count = countState.value, updateCount = { newCount -&gt;
        countState.value = newCount
    })
}
</code></pre>
<pre><code class="language-kotlin">@Composable
fun Greeting(name: String) {
    /*by委托：将set/get委托出去*/
    var isSelected by /*Boolean*/remember { mutableStateOf(false) }
    val backgroundColor by /*委托State&lt;Color&gt;*/animateColorAsState(if (isSelected) Color.Red else Color.Transparent)
    Text(text = &quot;hello $name&quot;,
        modifier = Modifier
            .padding(24.dp)
            .background(color = backgroundColor)
            .clickable(onClick = { isSelected = !isSelected })
    )
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Navigator源码分析]]></title>
        <id>https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/</id>
        <link href="https://Joshua-Chang.github.io/post/navigator-yuan-ma-fen-xi/">
        </link>
        <updated>2020-12-14T16:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="讨论案例">讨论案例</h3>
<pre><code class="language-xml">activity_main.xml

&lt;fragment
    android:id=&quot;@+id/nav_host_fragment&quot;
    android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:defaultNavHost=&quot;true&quot;
    app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt;

mobile_navigation.xml

&lt;navigation
    android:id=&quot;@+id/mobile_navigation&quot;
    app:startDestination=&quot;@id/navigation_home&quot;&gt;
    &lt;fragment
        android:id=&quot;@+id/navigation_home&quot;
        android:name=&quot;org.devio.as.hi.hirouter.ui.home.HomeFragment&quot;
        tools:layout=&quot;@layout/fragment_home&quot;&gt;
        &lt;argument
            android:name=&quot;name&quot;
            app:argType=&quot;string&quot;
            app:nullable=&quot;true&quot; /&gt;
        &lt;action
            android:id=&quot;@+id/action_navigation_home_to_navigation_notifications&quot;
            app:destination=&quot;@id/navigation_notifications&quot;
            app:launchSingleTop=&quot;true&quot;
            app:popUpTo=&quot;@id/navigation_notifications&quot; /&gt;
        &lt;deepLink
            android:id=&quot;@+id/deepLink&quot;
            app:uri=&quot;www.imooc.com&quot; /&gt;
    &lt;/fragment&gt;
&lt;/navigation&gt;
</code></pre>
<h3 id="navhostfragmentoninflate">NavHostFragment.onInflate:</h3>
<p>去查找声明在NavHostFragment的xml布局文件中的，defaultNavHost、navGraph属性,得到mGraphId</p>
<pre><code class="language-kotlin">onInflate：任何能在xml布局文件中声明的组建，当它们被从xml解析完成，被创建成功后都会调用此方法
activity和dialog是不可以的，因为他们不能在xml布局文件中直接声明
    @CallSuper
    @Override
    public void onInflate(@NonNull Context context, @NonNull AttributeSet attrs,
            @Nullable Bundle savedInstanceState) {
        super.onInflate(context, attrs, savedInstanceState);

        final TypedArray navHost = context.obtainStyledAttributes(attrs, R.styleable.NavHost);
        final int graphId = navHost.getResourceId(R.styleable.NavHost_navGraph, 0);
        if (graphId != 0) {
            mGraphId = graphId;
        }
        navHost.recycle();

        final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.NavHostFragment);
        final boolean defaultHost = a.getBoolean(R.styleable.NavHostFragment_defaultNavHost, false);
        if (defaultHost) {
            mDefaultNavHost = true;
        }
        a.recycle();
    }
</code></pre>
<h3 id="navhostfragmentoncreate">NavHostFragment.onCreate:</h3>
<ul>
<li>往NavigatorProvider内addNavigator：</li>
</ul>
<p>构造NavHostController方法内，先添加不可或缺的ActivityNavigator、和NavGraphNavigator （<navigation/>startDestination）</p>
<p>onCreateNavController方法内，添加DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转</p>
<ul>
<li>配置回退栈</li>
<li>NavController.setGraph(mGraphId)。把声明在NavHostFragment的app:navGraph的id，交给NavController处理（和fragmentController设计原因一样，隔离作用）</li>
</ul>
<pre><code class="language-kotlin">NavHostFragment:
@CallSuper
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final Context context = requireContext();
		//构建NavController对象 内部立即注册两个Navigator：start、activity的
    mNavController = new NavHostController(context);//继承自NavController
		//设置回退栈
    mNavController.setOnBackPressedDispatcher(requireActivity().getOnBackPressedDispatcher());
	  //...
		//通过controller得到Provider，并对其注册DialogFragmentNavigator，FragmentNavigator。以支持dialog、fragment类型的导航跳转
    onCreateNavController(mNavController);
    //。。。

        //把声明在NavHostFragment的xml布局文件中的资源id
				//app:navGraph=&quot;@navigation/mobile_navigation&quot;（navGraph属性）
				//交给NavController处理（和fragmentController设计原因一样，隔离作用）
        mNavController.setGraph(mGraphId);
}
//通过controller得到Provider（存储一个个navigator对象），
//并注册DialogFragmentNavigator，FragmentNavigator，以支持dialog、fragment类型的导航跳转
protected void onCreateNavController(@NonNull NavController navController) {
        navController.getNavigatorProvider().addNavigator(
                new DialogFragmentNavigator(requireContext(), getChildFragmentManager()));
        navController.getNavigatorProvider().addNavigator(createFragmentNavigator());
    }

//立即注册两个Navigator
NavController：
public NavController(@NonNull Context context) {
//....路由首页和activity都是不可或缺的，但fragmentNavigator未必，所以这里注册了两个
//mobile_navigation.xml资源文件加载完，用来启动其中的startDestination对应的页面的
        mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider));
//能给activity提供路由服务的navigator
        mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));
    }
//设置dispatcher后将mOnBackPressedCallback加入callback
void setOnBackPressedDispatcher(@NonNull OnBackPressedDispatcher dispatcher) {
	      //...
        dispatcher.addCallback(mLifecycleOwner, mOnBackPressedCallback);
    }

private final OnBackPressedCallback mOnBackPressedCallback =
            new OnBackPressedCallback(false) {
        @Override
        public void handleOnBackPressed() {
            popBackStack();//回退栈
        }
    };
</code></pre>
<h3 id="navinflaterinflate">NavInflater().inflate</h3>
<p>解析路由资源文件返回NavGraph对象：由路由资源xml定义的节点名，得到相应类型的Navigator，在去创建相应类型的Destination节点。</p>
<p><navigation/>特殊：会得到NavGraphNavigator类型的navigator，并创建出NavGraph类型的节点。</p>
<p>NavGraph是特殊的Destination节点：</p>
<ul>
<li>成员：含app:startDestination的id，和SparseArrayCompat<NavDestination>的路由节点集合</li>
<li>自己可以嵌套自己，即mobile_navigation.xml内的<navigation/>标签内还可以有<navigation/>形成一个个的路由组，且每组以各自的app:startDestination为起始点</li>
<li>NavInflater().inflate时遇到NavGraph类型的节点，递归调用inflate，将自节点加入其路由节点集合</li>
</ul>
<p>onGraphCreated：路由文件解析/节点创建完毕，开始路由跳转流程NavController.navigate</p>
<pre><code class="language-kotlin">NavController：
		@CallSuper
    public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) {
        setGraph(getNavInflater().inflate(graphResId)/*得到NavGraph*/, startDestinationArgs);
    }

		public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) {
        if (mGraph != null) {
            // Pop everything from the old graph off the back stack
            popBackStackInternal(mGraph.getId(), true);
        }
        mGraph = graph;//将得到的NavGraph保存起来
				//第一阶段：路由文件解析节点创建流程完毕
        onGraphCreated(startDestinationArgs);
				//内部会调用navigate(mGraph, startDestinationArgs, null, null);启动第一个路由节点//第二阶段路由跳转流程开始					
  }

NavInflater：
//layoutInflater专门解析布局资源文件，NavInflater专门解析路由资源文件，返回NavGraph对象
public NavGraph inflate(@NavigationRes int graphResId) {
      //。。。路由xml文件（app:navGraph=&quot;@navigation/mobile_navigation&quot;）的解析
			//生产路由节点对象
			NavDestination destination = inflate(res, parser, attrs, graphResId);
			if (!(destination instanceof NavGraph)) {//如果返回结果不是NavGraph类型则会抛出异常。即mobile_navigation.xml根结点必须&lt;navigation/&gt;标签
                throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot;
                        + &quot; did not inflate into a NavGraph&quot;);
            }
            return (NavGraph) destination;
    }

private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser,
            @NonNull AttributeSet attrs, int graphResId)
            throws XmlPullParserException, IOException {
//根据mobile_navigation.xml中的定义的节点类型，
//特殊：mobile_navigation.xml中的第一个节点为navigation解析出NavGraphNavigator类型的navigator导航
//正常：后边的节点为activity/fragment等，解析出fragmentnavigator/activitynavigator等类型的navigator
        Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName());
//使用navigator创建Destination节点（ADestination/FDestination等），以activityNavigator为例
//使用NavGraphNavigator创建出NavGraph
        final NavDestination dest = navigator.createDestination();
        dest.onInflate(mContext, attrs);//NavDestination节点（具体是子类activity或fragment）解析填充
				//...
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
              // ....
            } else if (dest instanceof NavGraph) {//如果节点是NavGraph则递归调用自己，继续解析并加入到NavGraph的节点集合中
                ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId));
            }
        }
        return dest;
}

ActivityNavigator：
public Destination createDestination() {
        return new Destination(this);//传入navigator自己
    }
ActivityNavigator$Destination
public static class Destination extends NavDestination{
	super(activityNavigator);//调父类NavDestination
}

NavDestination节点:的构造需要创建NavDestination的Navigator，或navigatorName
//无论是activity还是fragment类型的节点，
//创建时都需要把创建他的Navigator传递进来，以便正确的跳转
//从而把Destination节点和创建他的Navigator导航 关联起来
public NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) {}
public NavDestination(@NonNull String navigatorName) {}

NavGraphNavigator：特殊Navigator
public NavGraph createDestination() {
        return new NavGraph(this);
    }
NavGraph：特殊Destination节点，自己可以嵌套自己，
即mobile_navigation.xml内的&lt;navigation/&gt;标签内还可以有&lt;navigation/&gt;
形成一个个的路由组，且每组以各自的app:startDestination为起始点
例子：电商交易支付完成后，将一组都关闭

NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; {
    final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;();//路由节点的集合
    private int mStartDestId;//该集合的启动ID app:startDestination=&quot;@id/navigation_home&quot;
    private String mStartDestIdName;
}
</code></pre>
<h3 id="navcontrollernavigate">NavController.navigate</h3>
<p>第二阶段路由跳转流程开始</p>
<p>根据NavGraph这一特殊节点的name，得到NavGraphNavigator对象</p>
<pre><code class="language-kotlin">private void navigate(@NonNull NavDestination node, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    //...
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            node.getNavigatorName());//根据NavGraph的name，找创建该节点的到navigator对象 即NavGraphNavigator对象
    Bundle finalArgs = node.addInDefaultArgs(args);
    NavDestination newDest = navigator.navigate(node, finalArgs,//然后发起真正的路由
            navOptions, navigatorExtras);
    mBackStack.add(entry);//把路由节点添加到回退栈
}
</code></pre>
<h3 id="navgraphnavigatornavigate">NavGraphNavigator.navigate</h3>
<p>找到<navigator/>内 的startDestination节点</p>
<p>根据startDestination节点的name，在NavigatorProvider里找到创建他的具体的f/a/dialog等类型的Navigator</p>
<p>再让具体f/a/dialog等类型的Navigator去处理路由</p>
<pre><code class="language-kotlin">NavGraphNavigator：
public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args,
        @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) {
    int startId = destination.getStartDestination();//app:startDestination的id

		//根据app:startDestination的id找到相应的startDestination节点
    NavDestination startDestination = destination.findNode(startId, false);
	
		//根据startDestination节点的name属性，找到创建他的具体navigator
    Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
            startDestination.getNavigatorName());//此时的navigator可能是f/a/dialog等类型的Navigator
		//再将路由操作委托给f/a/dialog等类型的Navigator
    return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args),
            navOptions, navigatorExtras);
}

1、activityNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
				//构造intent
        Intent intent = new Intent(destination.getIntent());
        if (args != null) {
            intent.putExtras(args);//添加args
            //。。。
        }
				//配置启动模式
        if (!(mContext instanceof Activity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) {
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        }

				//进出动画等。。。

				mContext.startActivity(intent);//通过startActivity完成路由
    }

2、fragmentNavigator

public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();//根据destination节点得到类名
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = instantiateFragment(mContext, mFragmentManager,
                className, args);//根据类名反射得到fragment实例
        frag.setArguments(args);//设置args
        final FragmentTransaction ft = mFragmentManager.beginTransaction();//开启事务
				
        //进出动画等。。。

        ft.replace(mContainerId, frag);
				//此处使用的是replace，因此使用Navigator路由时切换fragment时，声明周期重新执行
    }

3、dialogFragmentNavigator
public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String className = destination.getClassName();
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = mFragmentManager.getFragmentFactory().instantiate(
                mContext.getClassLoader(), className);//反射
        if (!DialogFragment.class.isAssignableFrom(frag.getClass())) {//类型判断：是否时dialogFragment类型的
            throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName()
                    + &quot; is not an instance of DialogFragment&quot;);
        }
        final DialogFragment dialogFragment = (DialogFragment) frag;//上文以确定为dialogFragment
        dialogFragment.setArguments(args);//添加args
        dialogFragment.getLifecycle().addObserver(mObserver);

				//show出dialogFragment
        dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++);
        return destination;
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Joshua-Chang.github.io/post-images/1607965068319.png" alt="" loading="lazy"></figure>
<h3 id="缺点">缺点：</h3>
<ol>
<li>节点必须在路由文件mobile_navigation.xml中定义</li>
<li>fragment类型节点的路由操作，是使用replace，会导致fragment页面声明周期重启，数据的重新加载</li>
<li>不支持路由过程的拦截监听</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update MacOS to Mojave Vim: Caught deadly signal SEGV]]></title>
        <id>https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/</id>
        <link href="https://Joshua-Chang.github.io/post/Update-MacOS-to-Mojave-Vim-Caught-deadly-signal-SEGVE/">
        </link>
        <updated>2018-10-24T03:51:37.000Z</updated>
        <content type="html"><![CDATA[<h5 id="极有可能是youcompleteme或者powerline等插件的问题">极有可能是<em>YouCompleteMe</em>或者<em>Powerline</em>等插件的问题</h5>
<pre><code class="language-bash">Vim: Caught deadly signal SEGV

Error detected while processing function &lt;SNR&gt;78_PollServerReady[7]..&lt;SNR&gt;78_Pyeval:Vim: Finished.

line    4:
Exception MemoryError: MemoryError() in &lt;module 'threading' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'&gt; ignored
[1]    72868 segmentation fault  vim Test.java
</code></pre>
<h5 id="解决">解决：</h5>
<pre><code class="language-bash">brew install vim --with-lua --with-override-system-vi
</code></pre>
<p>and restart shell , fixed</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App使用统计与静默拍摄]]></title>
        <id>https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/</id>
        <link href="https://Joshua-Chang.github.io/post/App时常统计与静默拍摄/">
        </link>
        <updated>2018-10-03T10:29:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="app使用统计">App使用统计</h3>
<p>监控或统计手机内的app使用情况可以从两个思路考虑</p>
<ul>
<li>
<p>统计每个app的使用时长</p>
<p>UsageStatsManager这一统计管理类，可以查出每个app简单的最近开启时间、某时限内的使用时长等信息。更复杂的手机亮屏次数，开启<!--more-->应用次数可以使用UsageStatsService或者过滤包名的形式统计。</p>
</li>
<li>
<p>统计每个Android系统耗电情况的每个app占比</p>
<p>在做电量优化的时候经常会通过adb使用Battery-Historian分析电量报告，所以由此灵感，具体的实现还需要头脑风暴一下。</p>
</li>
</ul>
<h5 id="对app使用时常统计的简单实现">对app使用时常统计的简单实现</h5>
<ol>
<li>
<p>开启ACTION_USAGE_ACCESS_SETTINGS权限</p>
<figure data-type="image" tabindex="1"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2lhoyj308r0fkt9b.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>得到使用分析管理UsageStatsManager并根据时限查询统计状态</p>
<pre><code class="language-java">UsageStatsManager manager = (UsageStatsManager) getApplicationContext().getSystemService(USAGE_STATS_SERVICE);
List&lt;UsageStats&gt; stats = manager.queryUsageStats(UsageStatsManager.INTERVAL_MONTHLY, beginCal.getTimeInMillis(), endCal.getTimeInMillis());
</code></pre>
</li>
<li>
<p>根据UsageStats查询每个app的统计信息</p>
<pre><code class="language-java">for (UsageStats us : stats) {
    try {
        PackageManager pm = getApplicationContext().getPackageManager();
        ApplicationInfo applicationInfo = pm.getApplicationInfo(us.getPackageName(), PackageManager.GET_META_DATA);
        if ((applicationInfo.flags &amp; applicationInfo.FLAG_SYSTEM) &lt;= 0) {
            sb.append(pm.getApplicationLabel(applicationInfo)+&quot; 使用时长：&quot;+formatTime(us.getTotalTimeInForeground())+&quot;\n&quot;);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvv9r2tdo9j308r0fkabf.jpg" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="静默后台拍摄">静默后台拍摄</h3>
<h5 id="静默拍摄的简单思路">静默拍摄的简单思路</h5>
<ul>
<li>
<p>将SurfaceView或TextureView这一采集呈现的layout参数设为最小。（不能设置visibility：gone 不会采集到图像），可见现在采集时没有采集预览，但采集到的bitmap可以成功设置。</p>
<figure data-type="image" tabindex="3"><img src="https://thumbs.gfycat.com/DenseFailingGroundhog-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
<li>
<p>再将SurfaceView所在的Activity主题透明化</p>
<p>可见此时的采集效果从UI上看静默进行。”拍摄“按键只是方便展示效果，如果使用Service去掉用则</p>
<p>真正实现了后台静默采集的效果，至于采集到bitmap可以储存也可以直接用三方sdk做一些图像分析。</p>
<figure data-type="image" tabindex="4"><img src="https://thumbs.gfycat.com/SpryBeautifulChafer-size_restricted.gif" alt="" loading="lazy"></figure>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开发一个IntelliJ IDEA插件]]></title>
        <id>https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/</id>
        <link href="https://Joshua-Chang.github.io/post/开发一个IntelliJ-IDEA插件/">
        </link>
        <updated>2017-12-26T16:03:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="灵感">灵感</h3>
<p>IDEA和AS中的大小写切换快捷键，一直是比较良心的。</p>
<p>在声明一些常量时极其省事，但常量由多个单词组成时，还要手动的加上下划线又及其麻烦。</p>
<h3 id="思路">思路</h3>
<p>开发一个插件，把符合驼峰命名的多单词组成名字，分别加上下划线。反之，把由下划线拼成的名字变成驼峰<!--more--></p>
<p>命名。</p>
<h3 id="eg">e.g.</h3>
<ul>
<li>
<p>light_dialog_type --&gt; lightDialogType</p>
</li>
<li>
<p>anApplePie --&gt; an_apple_pie</p>
</li>
<li>
<p>homeActivityTimer --&gt;home_activity_timer --&gt; HOME_ACTIVITY_TIMER</p>
</li>
</ul>
<h3 id="实现">实现</h3>
<ol>
<li>新建一个IntelliJ Platform Plugin项目，创建相应的action复写actionPerformed()</li>
<li>得到AS/IDEA选中的常量名</li>
</ol>
<pre><code class="language-java">       //获取Editor和Project对象
        Editor editor = e.getData(PlatformDataKeys.EDITOR);
        Project project = e.getData(PlatformDataKeys.PROJECT);
        if (editor == null || project == null)
            return;

        //获取SelectionModel和Document对象
        SelectionModel selectionModel = editor.getSelectionModel();
        Document document = editor.getDocument();

        selectionModel.selectWordAtCaret(false);
        //拿到选中部分字符串
        String selectedText = selectionModel.getSelectedText();

        //得到选中字符串的起始和结束位置
        int startOffset = selectionModel.getSelectionStart();
        int endOffset = selectionModel.getSelectionEnd();
</code></pre>
<ol start="3">
<li>新线程中去执行驼峰命名与下划线的转换操作</li>
</ol>
<pre><code class="language-java">        //对文档进行操作部分代码，需要放入Runnable接口中实现，由IDEA在内部将其通过一个新线程执行
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                if (isLine(selectedText)) {
                    document.replaceString(startOffset, endOffset, lineToHump(selectedText));
                }else {
                    String temp=null;
                    if (selectedText.charAt(0) == 'm' &amp;&amp; selectedText.charAt(1) &lt;= 'Z' &amp;&amp; selectedText.charAt(1) &gt;= 'A') {//情况一：把mActivityInstance这种变为ActivityInstance
                        temp = selectedText.substring(1);
                    }
                    String result = temp != null ? temp : selectedText;
                    result=humpToLine(result);
                    if (result.charAt(0)=='_') {
                        result=result.substring(1);
                    }
                    document.replaceString(startOffset, endOffset, result);
                }
            }
        };
</code></pre>
<ol start="4">
<li>加入任务，由IDEA调度执行这个任务</li>
</ol>
<pre><code class="language-java">WriteCommandAction.runWriteCommandAction(project, runnable);
</code></pre>
<ol start="5">
<li>其他：转换方法都是些常用算法不做赘述；Action的update方法看需求情况编写。</li>
</ol>
<h3 id="完工">完工</h3>
<p>发布在JetBrains给提提意见：<a href="https://plugins.jetbrains.com/plugin/11121-underline-camel-toggle-case">Underline Camel Toggle Case</a> 或在AS/IDEA的plugin中搜索</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[View滑动的几种方式]]></title>
        <id>https://Joshua-Chang.github.io/post/View滑动的几种方式/</id>
        <link href="https://Joshua-Chang.github.io/post/View滑动的几种方式/">
        </link>
        <updated>2017-09-28T06:27:58.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="view的滑动">View的滑动</h3>
<p>实现View滑动大概有：layout()、offsetLeftAndRight()／offsetTopAndBottom()、LayoutParams、动画、scollTo与scollBy和Scroller等几种方法。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="view的滑动">View的滑动</h3>
<p>实现View滑动大概有：layout()、offsetLeftAndRight()／offsetTopAndBottom()、LayoutParams、动画、scollTo与scollBy和Scroller等几种方法。</p>
<!--more-->
<h3 id="layout">layout()</h3>
<pre><code class="language-java">layout(getLeft()+offsetX, getTop()+offsetY,getRight()+offsetX , getBottom()+offsetY);
</code></pre>
<h3 id="offset">offset</h3>
<pre><code class="language-java">offsetLeftAndRight(offsetX);
offsetTopAndBottom(offsetY);
</code></pre>
<h3 id="layoutparams">LayoutParams</h3>
<pre><code class="language-java">ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
layoutParams.leftMargin = getLeft() + offsetX;
layoutParams.topMargin = getTop() + offsetY;
setLayoutParams(layoutParams);
</code></pre>
<h3 id="scollby">scollBy</h3>
<p>反向移动父布局画布</p>
<pre><code class="language-java">((View)getParent()).scrollBy(-offsetX,-offsetY);
</code></pre>
<h3 id="scroller">Scroller</h3>
<ul>
<li>初始化Scroller</li>
</ul>
<pre><code class="language-java">public CustomView(Context context, AttributeSet attrs) {
      super(context, attrs);
      mScroller = new Scroller(context);
  }
</code></pre>
<ul>
<li>
<p>复写computeScroll()  在绘制View的时候在draw()中调用该方法</p>
<p>调用父类的scrollTo()方法并通过Scroller来不断获取当前的滚动值，并调用invalidate()不断重绘，重绘就会调用computeScroll()方法，连贯成移动</p>
</li>
</ul>
<pre><code class="language-java">@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
         //通过不断的重绘不断的调用computeScroll方法
         invalidate();
    }  
}
</code></pre>
<ul>
<li>startScroll()</li>
</ul>
<pre><code class="language-java">public void smoothScrollTo(int destX,int destY){
      int scrollX=getScrollX();
      int delta=destX-scrollX;
      //1000秒内滑向destX
      mScroller.startScroll(scrollX,0,delta,0,2000);
      invalidate();
  }
</code></pre>
<ul>
<li>外部调用</li>
</ul>
<pre><code class="language-java">mCustomView.smoothScrollTo(-400,0);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TabLayout indicator宽度工具类]]></title>
        <id>https://Joshua-Chang.github.io/post/TabLayout-indicator宽度工具类/</id>
        <link href="https://Joshua-Chang.github.io/post/TabLayout-indicator宽度工具类/">
        </link>
        <updated>2017-09-22T13:35:36.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="宽度工具类">宽度工具类</h4>
<p>一劳永逸之法</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="宽度工具类">宽度工具类</h4>
<p>一劳永逸之法</p>
<!--more-->
<pre><code class="language-java">public void reflex(final TabLayout tabLayout){
    //了解源码得知 线的宽度是根据 tabView的宽度来设置的
    tabLayout.post(new Runnable() {
        @Override
        public void run() {
            try {
                //拿到tabLayout的mTabStrip属性
                LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0);

                int dp10 = dp2px(tabLayout.getContext(), 10);

                for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) {
                    View tabView = mTabStrip.getChildAt(i);

                    //拿到tabView的mTextView属性  tab的字数不固定一定用反射取mTextView
                    Field mTextViewField = tabView.getClass().getDeclaredField(&quot;mTextView&quot;);
                    mTextViewField.setAccessible(true);

                    TextView mTextView = (TextView) mTextViewField.get(tabView);

                    tabView.setPadding(0, 0, 0, 0);

                    //因为我想要的效果是   字多宽线就多宽，所以测量mTextView的宽度
                    int width = 0;
                    width = mTextView.getWidth();
                    if (width == 0) {
                        mTextView.measure(0, 0);
                        width = mTextView.getMeasuredWidth();
                    }

                    //设置tab左右间距为10dp  注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的
                    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();
                    params.width = width ;
                    params.leftMargin = dp10;
                    params.rightMargin = dp10;
                    tabView.setLayoutParams(params);

                    tabView.invalidate();
                }

            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    });

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IPC机制之Messenger]]></title>
        <id>https://Joshua-Chang.github.io/post/IPC机制之Messenger/</id>
        <link href="https://Joshua-Chang.github.io/post/IPC机制之Messenger/">
        </link>
        <updated>2017-06-02T02:42:31.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，通过Messenger可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据就可以轻松实现数据在进程间传递了。</p>
<p>在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。</p>
<p>Messenger的使用很简单，由于它一次处理一个请求，因此在服务端不用考虑线程同步的问题。Messenger实现进程间通信大致可以分为以下几步，分为服务端和客户端。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，通过Messenger可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据就可以轻松实现数据在进程间传递了。</p>
<p>在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。</p>
<p>Messenger的使用很简单，由于它一次处理一个请求，因此在服务端不用考虑线程同步的问题。Messenger实现进程间通信大致可以分为以下几步，分为服务端和客户端。</p>
<!--more-->
<h4 id="服务端进程">服务端进程</h4>
<p>服务端新建一个Service来处理客户端发起的请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<p>如果需要客服端能够回应客户端，那么和服务端一样，在客户端还需要创建一个新的Messenger,并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<pre><code class="language-java">public class MyService extends Service {
    public static final int MSG_FROM_SERVICE=2;
    public MyService() {}
    public static class MessagerHandler extends Handler{
        @Override
        public void handleMessage(Message msg) {
            if (msg.what==MainActivity.MSG_FROM_CLIENT){
                Log.e(&quot;xxx&quot;,&quot;msg from client: &quot;+msg.getData().getString(&quot;msg&quot;));

                Messenger mReplyTo = msg.replyTo;
                Message mMessage=Message.obtain(null,MSG_FROM_SERVICE);
                Bundle mBundle=new Bundle();
                mBundle.putString(&quot;reply&quot;,&quot;Hi,service received succeed&quot;);
                mMessage.setData(mBundle);
                try {
                    mReplyTo.send(mMessage);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }
    }
  //1.创建Messenger（需要handler）对象
    private Messenger mMessenger=new Messenger(new MessagerHandler());
    @Override
    public IBinder onBind(Intent intent) {
      //2.在Service的onBind中返回这个Messenger对象底层的Binder 供客户端使用
        return mMessenger.getBinder();
    }
}
</code></pre>
<h4 id="客户端进程">客户端进程</h4>
<p>客户端进程中首先要绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送类型为Message的消息了，message内可以存入Bundle。</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    public static final int MSG_FROM_CLIENT=1;

    private ServiceConnection mServiceConnection=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
          //2.绑定成功后,根据上文返回的IBinder对象创建一个Messenger
            Messenger mMessenger=new Messenger(service);
            Message mMessage = Message.obtain(null, MSG_FROM_CLIENT);
            Bundle mBundle=new Bundle();
            mBundle.putString(&quot;msg&quot;,&quot;hello,this msg from client&quot;);
            mMessage.setData(mBundle);

            mMessage.replyTo=mReplyMessenger;
            try {
                mMessenger.send(mMessage);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };
    private static class ReceiveHandler extends Handler{
        @Override
        public void handleMessage(Message msg) {
            if (msg.what==MyService.MSG_FROM_SERVICE){
                Log.e(&quot;xxx&quot;,&quot;msg from service: &quot;+msg.getData().getString(&quot;reply&quot;));
            }
        }
    }
    private Messenger mReplyMessenger=new Messenger(new ReceiveHandler());

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      //1.绑定服务端的Service
        Intent mIntent=new Intent(this,MyService.class);
        bindService(mIntent,mServiceConnection,BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        unbindService(mServiceConnection);
        super.onDestroy();
    }
}
</code></pre>
<h4 id="extra">Extra</h4>
<p>注册service时为新的全局进程</p>
<pre><code class="language-xml">&lt;service
    android:name=&quot;.MyService&quot;
    android:process=&quot;com.coolapk.developer_verify_package&quot;&gt;
&lt;/service&gt;
</code></pre>
]]></content>
    </entry>
</feed>