<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>算法思想 | Joshua-Chang`Blog</title>
<link rel="shortcut icon" href="https://Joshua-Chang.github.io/favicon.ico?v=1628149621140">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Joshua-Chang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="算法思想 | Joshua-Chang`Blog - Atom Feed" href="https://Joshua-Chang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>



    <meta name="description" content="贪心算法、分治算法、回溯算法、动态规划是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。
贪心算法
贪心算法（greedy algorithm）有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和..." />
    <meta name="keywords" content="数据结构,算法" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    
      <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/styles/rainbow.min.css">
      
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Joshua-Chang.github.io">
  <img class="avatar" src="https://Joshua-Chang.github.io/images/avatar.png?v=1628149621140" alt="">
  </a>
  <h1 class="site-title">
    Joshua-Chang`Blog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              算法思想
            </h2>
            <div class="post-info">
              <span>
                2021-03-13
              </span>
              <span>
                36 min read
              </span>
              
                <a href="https://Joshua-Chang.github.io/tag/BErOFr5XG/" class="post-tag">
                  # 数据结构
                </a>
              
                <a href="https://Joshua-Chang.github.io/tag/adLQuSjePQ/" class="post-tag">
                  # 算法
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://static001.geekbang.org/resource/image/6d/77/6deb3d0f336ca51f3b7f3eff5d0f4477.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>贪心算法、分治算法、回溯算法、动态规划是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p>
<h1 id="贪心算法">贪心算法</h1>
<p>贪心算法（greedy algorithm）有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。</p>
<p>贪心算法解决问题的步骤：</p>
<p>针对一组数据，定义了**限制值和期望值，**希望从中选出几个数据，在满足限制值的情况下，期望值最大。比如背包重量不超过 100kg，并且总价值最大。</p>
<ol>
<li><strong>当我们看到这类问题的时候，首先要联想到贪心算法。</strong></li>
<li><strong>再尝试看下这个问题是否可以用贪心算法解决</strong></li>
<li><strong>最后举几个例子看下贪心算法产生的结果是否是最优的</strong></li>
</ol>
<h2 id="分糖果">分糖果</h2>
<p>有 m 个糖果和 n 个孩子。糖果少，孩子多（m&lt;n），每个糖果的大小不等，且孩子对糖果大小要求不同，如何分配才能让更多孩子满足?</p>
<p>每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果</p>
<h2 id="钱币找零">钱币找零</h2>
<p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p>
<h2 id="区间覆盖">区间覆盖</h2>
<p>假设有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>
<p>假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上。按照起始端点从小到大的顺序对这 n 个区间排序。</p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p>
<h2 id="霍夫曼编码">霍夫曼编码</h2>
<p>假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>
<p>假设经过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。</p>
<p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，<strong>根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率</strong>。</p>
<p>由于霍夫曼编码是不等长的，解压缩时每次应该读取几位呢？</p>
<p>为了避免解压缩过程中的歧义，霍夫曼编码要求<strong>各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p>
<p>根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p>
<img src="https://static001.geekbang.org/resource/image/83/45/83921e609c8a4dc81ca5b90c8b4cd745.jpg" alt="  " style="zoom:50%;" />
<p>如何给不同频率的字符选择不同长度的编码呢？</p>
<p>首先，把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>
<p>然后，给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/7b/7a/7b6a08e7df45eac66820b959c64f877a.jpg" alt="  " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/cc/ed/ccf15d048be005924a409574dce143ed.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1 id="分治算法">分治算法</h1>
<p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p>
<p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>分治算法一般都比较适合用递归来实现：</p>
<ul>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题。</li>
</ul>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li>原问题与分解成的小问题具有<strong>相同的模式；</strong></li>
<li>原问题分解成的<strong>子问题可以独立求解</strong>，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>
<li>具有<strong>分解终止条件</strong>，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个<strong>合并操作的复杂度不能太高</strong>，否则就起不到减小算法总体复杂度的效果了。</li>
</ul>
<p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢</strong>？</p>
<p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p>
<p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。这样操作的时间复杂度是 O(n^2)。</p>
<p>用分治算法。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>
<p>借助归并排序算法，快速计算出两个子问题 A1 与 A2 之间的逆序对个数。归并排序算法中将两个有序的小数组，合并成一个有序的数组，每次合并操作，都计算逆序对个数然后求和就是整个数组的逆序对个数。</p>
<p><strong>分治算法解决海量数据处理问题</strong></p>
<h1 id="回溯算法">回溯算法</h1>
<p>很多经典的问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p>
<p>深度优先搜索算法利用的是回溯算法思想；实际开发中，正则表达式匹配、编译原理中的语法分析等也用到回溯思想。</p>
<p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>
<p>大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p>
<h2 id="八皇后">八皇后</h2>
<p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p>
<p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/a0/f5/a0e3994319732ca77c81e0f92cc77ff5.jpg" alt="  " loading="lazy"></figure>
<p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p>
<p>回溯法的搜索空间是多大呢？以 4×4 的棋盘为例，第一行显然有四个位置可以放置皇后，而第一行的皇后使得第二行至少有两个格子处于它的攻击范围之内，因此第二行至多有 4-2=2 个可用位置，以此类推，第三行至多有一个位置，第四行也至多有一个位置。因此搜索空间为 4×2×1×1 = 8 ，较之以前的确小了不少。</p>
<p>这样推导到更通俗的情况，对于 N×N 的棋盘，回溯法的搜索空间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>×</mo><mo>…</mo><mo>×</mo><mn>1</mn><mo>=</mo><mi>O</mi><mo>(</mo><mi>N</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">N×(N-2)×(N-4)×…×1 = O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 。对于开头提到的八皇后问题，时间复杂度就从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>8</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">8^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>降到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">8!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mclose">!</span></span></span></span></p>
<h2 id="0-1背包">0-1背包</h2>
<p>有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
<blockquote>
<p>0-1 背包问题有很多变体，经典解法是动态规划，不过用回溯算法虽然不够高效，但很简单。</p>
</blockquote>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>	种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。不过，如何才能不重复地穷举出这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种装法呢？</p>
<p>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。还可以加入一些<strong>搜索剪枝</strong>的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，就停止继续探测剩下的物品。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式里最重要的一种算法思想就是回溯</p>
<p>通配符：“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符</p>
<p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>
<p>依次考察正则表达式中的每个字符，当是非通配符时，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>
<p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>
<h1 id="动态规划">动态规划</h1>
<p>动态规划（Dynamic Programming）比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。它的主要学习难点跟递归类似，就是求解问题的过程不太符合人类常规的思维方式。</p>
<h2 id="动态规划问题模型及演化过程">动态规划问题模型及演化过程</h2>
<h3 id="0-1背包问题">0-1背包问题</h3>
<p>对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少？</p>
<p>假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3</p>
<p>回溯的解决方法，就是穷举搜索所有可能的装法，然后找出满足条件的最大值。</p>
<p>回溯求解过程，用递归树画出来如图。递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p>
<img src="https://static001.geekbang.org/resource/image/42/ea/42ca6cec4ad034fc3e5c0605fbacecea.jpg" style="zoom:50%;" />
<p>递归树中，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。可以利用缓存避免冗余计算。</p>
<p>动态规划求解：</p>
<p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p>
<p>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量）。于是，我们就成功避免了每层状态个数的指数级增长。</p>
<p>二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。</p>
<p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 <code>states[0][0]=true</code> 和 <code>states[0][2]=true</code> 来表示这两种状态。</p>
<p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 <code>states[1][0]=true</code>，<code>states[1][2]=true</code>，<code>states[1][4]=true</code> 来表示这三种状态。</p>
<p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/bb/7e/bbbb934247219db8299bd46dba9dd47e.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p>
<p>这个问题用回溯算法解决这个问题的时间复杂度 O(2^n)，是指数级的。用动态规划的时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。但需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。</p>
<p>动态规划是一种空间换时间的解决思路，可以通过其他办法降低空间消耗。实际上只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作， 要注意for 循环重复计算的问题。</p>
<h3 id="0-1-背包问题升级版">0-1 背包问题升级版</h3>
<p>背包问题，只涉及背包重量和物品重量。现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p>
<p>问题依旧可以用回溯算法来解决，穷举搜索所有可能的装法，然后找出满足条件的最大值。</p>
<p>照例画出递归树。在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p>
<img src="https://static001.geekbang.org/resource/image/bf/3f/bf0aa18f367db1b8dfd392906cb5693f.jpg" style="zoom:50%;" />
<p>在递归树中，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。如有节点f(2,2,4) 和 f(2,2,3)的 i 和 cw 是完全相同的，在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p>
<p>还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p>
<p>我们用一个二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。时间复杂度是 <code>O(n*w)</code>，空间复杂度也是 <code>O(n*w)</code></p>
<p>大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。动态规划算法，在执行效率方面，要高很多。但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p>
<p>四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性。</p>
<h2 id="适合解决的问题的特征">适合解决的问题的特征</h2>
<p>动态规划作为一个非常成熟的算法思想，很多人对动态规划能解决的问题有什么规律，已经做了全面的总结：<strong>“一个模型三个特征”</strong></p>
<p>一个模型是指：“<strong>多阶段决策最优解模型</strong>”</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p><strong>三个特征</strong>”分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</p>
<ol>
<li>
<p>最优子结构</p>
<p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p>
</li>
<li>
<p>无后效性</p>
<p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p>
</li>
<li>
<p>重复子问题</p>
<p>这个概念比较好理解。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>
</li>
</ol>
<h3 id="一个模型三个特征实例剖析">“一个模型三个特征”实例剖析</h3>
<p>假设我们有一个 n 乘以 n 的矩阵 <code>w[n][n]</code>。矩阵存储的都是正整数。</p>
<p>棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>
<p><strong>一个模型</strong>：从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步（向右向下各n-1），也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p>
<p><strong>三个特征</strong>：</p>
<p>用回溯算法来解决这个问题。画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在<strong>重复子问题。</strong></p>
<p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“<strong>无后效性</strong>”这一特征。</p>
<p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“<strong>最优子结构</strong>”。</p>
<pre><code class="language-java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
</code></pre>
<h2 id="动态规划解题思路">动态规划解题思路</h2>
<p>两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。</p>
<p>状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。</p>
<p>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p>
<p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p>
<h3 id="状态转移表法">状态转移表法</h3>
<p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用**回溯加“备忘录”**的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p>
<p>先画出一个状态表。状态表一般都是二维的，可以想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p>
<p>高维状态转移表不好画图表示，且人脑确实很不擅长思考高维的东西。所以当问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，便不适合用状态转移表法来解决了。</p>
<p>矩阵最短路径的问题解法：</p>
<p>从起点到终点，有很多种不同的走法。先用回溯算法穷举所有走法，然后对比找出一个最短走法。</p>
<p>接下来，画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了。既然存在重复子问题，用动态规划来解决。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/2c/e2/2c3ec820fa8f8cc7df838c0304b030e2.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/b3/ca/b3f0de1c81533a0d24c43426eaf09aca.jpg" alt=" " loading="lazy"><br /><img src="https://static001.geekbang.org/resource/image/05/7d/05a48baf7fb4d251bf5078840079107d.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充。然后将上面的过程，翻译成代码。</p>
<h3 id="状态转移方程法">状态转移方程法</h3>
<p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p>
<p><strong>状态转移方程是解决动态规划的关键</strong></p>
<pre><code class="language-java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
</code></pre>
<h2 id="四种算法思想各自特点及适用场景">四种算法思想各自特点及适用场景</h2>
<p>基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p>
<p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p>
<p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p>
<h1 id="b树">B+树</h1>
<p><strong>数据库索引是如何实现的呢？</strong></p>
<ul>
<li>根据某个值查找数据，比如 select * from user where id=1234；</li>
<li>根据区间值来查找某些数据，比如 select * from user where id &gt; 1234 and id &lt; 2345。</li>
</ul>
<p><strong>散列表</strong>。散列表的查询时间复杂度是 O(1)。但是不支持按照区间快速查找数据。</p>
<p><strong>平衡二叉查找树</strong>。查询时间复杂度是 O(logn)。且对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p>
<p><strong>跳表</strong>。是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)，也支持按照区间快速地查找数据。</p>
<h3 id="改造二叉查找树">改造二叉查找树</h3>
<p>让二叉查找树支持按照区间来查找数据，改造：树中的节点并不存储数据本身，而是只是作为索引。同时把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。</p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg" alt="  " loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol>
<li>
<p>要求某个区间的数据。只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p>
</li>
<li>
<p>为了节省内存，将索引存储在硬盘中，但查找索引时，需要磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数，构建成 m 叉树来降低树高度，从而减少IO次数。</p>
<p>操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，在选择 m 大小的时候，要尽量让<strong>每个节点的大小等于一个页的大小</strong>。读取一个节点，只需要一次磁盘 IO 操作。</p>
</li>
<li>
<p>B+ 树来的m 值是根据页的大小事先计算好的，因此在插入、删除操作时，会打破m个子节点，从而影响IO效率（节点不再是页大小，IO次数增多）。因此需要节点分裂、合并等整理操作来让节点满足页大小。</p>
<p>插入时超出个m个节点时，只需要将这个节点分裂成两个节点，若导致其父节点的子节点个数就有可能超过 m 个，将父节点也分裂成两个节点。从下往上级联反应，一直影响到根节点。</p>
<p>删除时会导致子节点变少，在 B+ 树中，有个阈值为 m/2，若某个节点的子节点个数小于 m/2，就将它跟相邻的兄弟节点合并。（若合并之后结点的子节点个数有超过 m。继续借助插入数据时候的处理方法，再分裂节点。）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt="  " loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg" alt="     " loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>总结B+ 树的特点：</p>
<ul>
<li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；(例外：根节点的子节点个数可以不超过 m/2)</li>
<li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li>
<li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li>
<li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li>
</ul>
<blockquote>
<p>除了 B+ 树，还有 B 树、B- 树，实际上，B- 树就是 B 树，英文翻译都是 B-Tree，这里的“-”并不是相对 B+ 树中的“+”，而只是一个连接符。</p>
<p>说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：</p>
<ul>
<li>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；</li>
<li>B 树中的叶子节点并不需要链表来串联。</li>
</ul>
<p>也就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。</p>
</blockquote>
<h1 id="位图与filter">位图与Filter</h1>
<p><strong>布隆过滤器</strong>（Bloom Filter）是filter中的一种。</p>
<p>Filter和Cache都是加快数据访问的缓存思想。二者是互补的。</p>
<p>cache 是在访问数据时，cache中存在则取出，不在则去下层找。</p>
<p>filter 是在访问数据时，filter的关键是<strong>判断元素在与不在</strong>，</p>
<p>Bloom Filter判断一个元素在集合中有一定的错误率，但是判断一个元素不在集合中就绝对不在集合中。</p>
<p><strong>我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</strong></p>
<p><strong>位图</strong>（BitMap）一种比较“特殊”的散列表。比如 Java 中的 BitSet 类就是一个位图</p>
<blockquote>
<p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p>
<p>当我们查询某个整数 K 是否在这 1 千万个整数中的时候，我们只需要将对应的数组值 array[K] 取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p>
<p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p>
</blockquote>
<p>同样的例子，数据个数是 1 千万，数据的范围是 1 到 10 亿时。使用<strong>布隆过滤器</strong>（Bloom Filter）的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。哈希函数可能会存在冲突。</p>
<p>我们使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>X</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>X</mi><mn>3</mn></msub><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><msub><mi>X</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">X_1，X_2，X_3，…，X_K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​。我们把这 K 个数字作为位图中的下标，将对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>1</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mn>3</mn></msub><mo>]</mo><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>X</mi><mi>K</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">BitMap[X_1]，BitMap[X_2]，BitMap[X_3]，…，BitMap[X_K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>​ 都设置成 true，也就是说，我们用 K 个<strong>二进制位</strong>，来表示一个数字的存在。</p>
<p>当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mn>3</mn></msub><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><msub><mi>Y</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">Y_1，Y_2，Y_3，…，Y_K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</p>
<p><strong>步隆过滤器是通过K个函数，对一个元素求得K个二进制位，表示该元素是否在集合里。</strong></p>
<table>
<thead>
<tr>
<th><img src="https://static001.geekbang.org/resource/image/94/ae/94630c1c3b7657f560a1825bd9d02cae.jpg" alt="" loading="lazy"></th>
<th><img src="https://static001.geekbang.org/resource/image/d0/1a/d0a3326ef0037f64102163209301aa1a.jpg" alt="" loading="lazy"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>但是，这种处理方式容易误判。布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p>
<p>布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能。</p>
<p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，我们就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，如果我们要判断某个数据是否在布隆过滤器中已经存在，我们就需要查看多个位图，相应的执行效率就降低了一些。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a>
<ul>
<li><a href="#%E5%88%86%E7%B3%96%E6%9E%9C">分糖果</a></li>
<li><a href="#%E9%92%B1%E5%B8%81%E6%89%BE%E9%9B%B6">钱币找零</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96">区间覆盖</a></li>
<li><a href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">霍夫曼编码</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">分治算法</a></li>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a>
<ul>
<li><a href="#%E5%85%AB%E7%9A%87%E5%90%8E">八皇后</a></li>
<li><a href="#0-1%E8%83%8C%E5%8C%85">0-1背包</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B">动态规划问题模型及演化过程</a>
<ul>
<li><a href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">0-1背包问题</a></li>
<li><a href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8D%87%E7%BA%A7%E7%89%88">0-1 背包问题升级版</a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E5%90%88%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%89%B9%E5%BE%81">适合解决的问题的特征</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9E%8B%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90">“一个模型三个特征”实例剖析</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">动态规划解题思路</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%A1%A8%E6%B3%95">状态转移表法</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E6%B3%95">状态转移方程法</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%90%84%E8%87%AA%E7%89%B9%E7%82%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">四种算法思想各自特点及适用场景</a></li>
</ul>
</li>
<li><a href="#b%E6%A0%91">B+树</a><br>
*
<ul>
<li><a href="#%E6%94%B9%E9%80%A0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">改造二叉查找树</a></li>
</ul>
</li>
<li><a href="#%E4%BD%8D%E5%9B%BE%E4%B8%8Efilter">位图与Filter</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Joshua-Chang.github.io/post/shu-ju-jie-gou-yu-suan-fa-03/">
              <h3 class="post-title">
                查找
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://Joshua-Chang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
      <div id="vcomments"></div>
    </div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'MqyUKtQmX8ouL05DG3KdXz6o-gzGzoHsz',
            appKey: 'LMzBK0QcNL65uWxkhaN1KDUe'
        })
    </script>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
